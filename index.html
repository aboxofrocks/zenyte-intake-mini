<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zenyte Holdings - ERP Intake Dashboard</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #f5f7fa;
      color: #333;
      line-height: 1.6;
      padding: 2rem;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      margin-bottom: 2rem;
    }

    header h1 {
      font-size: 1.75rem;
      font-weight: 600;
      color: #1a1a2e;
    }

    header p {
      color: #666;
      font-size: 0.9rem;
    }

    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .metric-card {
      background: #fff;
      padding: 1rem 1.25rem;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .metric-card .label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #888;
    }

    .metric-card .value {
      font-size: 1.5rem;
      font-weight: 600;
      color: #1a1a2e;
    }

    .metric-card.revenue .value {
      color: #2e7d32;
    }

    .card {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 1.5rem;
      margin-bottom: 2rem;
    }

    .card h2 {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: #1a1a2e;
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-group.full-width {
      grid-column: 1 / -1;
    }

    .form-group label {
      font-size: 0.8rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
      color: #555;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      padding: 0.6rem 0.75rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 0.9rem;
      transition: border-color 0.2s;
    }

    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #4a6cf7;
    }

    .form-group textarea {
      resize: vertical;
      min-height: 60px;
    }

    .btn {
      padding: 0.6rem 1.25rem;
      border: none;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn-primary {
      background: #4a6cf7;
      color: #fff;
    }

    .btn-primary:hover {
      background: #3a5ce5;
    }

    .btn-small {
      padding: 0.35rem 0.75rem;
      font-size: 0.75rem;
    }

    .btn-advance {
      background: #e3f2fd;
      color: #1565c0;
    }

    .btn-advance:hover {
      background: #bbdefb;
    }

    .btn-delete {
      background: #ffebee;
      color: #c62828;
    }

    .btn-delete:hover {
      background: #ffcdd2;
    }

    .form-actions {
      margin-top: 1rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      text-align: left;
      padding: 0.75rem;
      border-bottom: 1px solid #eee;
    }

    th {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #888;
      font-weight: 600;
    }

    td {
      font-size: 0.9rem;
    }

    .status-badge {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .status-lead {
      background: #fff3e0;
      color: #e65100;
    }

    .status-onboarding {
      background: #e3f2fd;
      color: #1565c0;
    }

    .status-active {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .actions {
      display: flex;
      gap: 0.5rem;
    }

    .empty-state {
      text-align: center;
      padding: 2rem;
      color: #888;
    }

    .confetti {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
    }

    .confetti-piece {
      position: absolute;
      width: 10px;
      height: 10px;
      opacity: 0;
      animation: confetti-fall 1.5s ease-out forwards;
    }

    @keyframes confetti-fall {
      0% {
        opacity: 1;
        transform: translateY(0) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: translateY(400px) rotate(720deg);
      }
    }

    /* View Toggle */
    .view-toggle {
      display: flex;
      gap: 0;
      margin-bottom: 1rem;
    }

    .view-toggle button {
      padding: 0.5rem 1rem;
      border: 1px solid #ddd;
      background: #fff;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }

    .view-toggle button:first-child {
      border-radius: 6px 0 0 6px;
    }

    .view-toggle button:not(:first-child) {
      border-left: none;
    }

    .view-toggle button:last-child {
      border-radius: 0 6px 6px 0;
    }

    .view-toggle button.active {
      background: #4a6cf7;
      color: #fff;
      border-color: #4a6cf7;
    }

    .view-toggle button:not(.active):hover {
      background: #f5f5f5;
    }

    /* Pipeline View */
    .pipeline-container {
      display: none;
    }

    .pipeline-container.visible {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
    }

    .pipeline-column {
      background: #f0f2f5;
      border-radius: 8px;
      padding: 1rem;
      min-height: 300px;
    }

    .pipeline-column-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid;
    }

    .pipeline-column-header h3 {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .pipeline-column-header .count {
      font-size: 0.75rem;
      padding: 0.2rem 0.5rem;
      border-radius: 10px;
      font-weight: 500;
    }

    .column-lead .pipeline-column-header {
      border-color: #e65100;
    }

    .column-lead .pipeline-column-header h3 {
      color: #e65100;
    }

    .column-lead .pipeline-column-header .count {
      background: #fff3e0;
      color: #e65100;
    }

    .column-onboarding .pipeline-column-header {
      border-color: #1565c0;
    }

    .column-onboarding .pipeline-column-header h3 {
      color: #1565c0;
    }

    .column-onboarding .pipeline-column-header .count {
      background: #e3f2fd;
      color: #1565c0;
    }

    .column-active .pipeline-column-header {
      border-color: #2e7d32;
    }

    .column-active .pipeline-column-header h3 {
      color: #2e7d32;
    }

    .column-active .pipeline-column-header .count {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .pipeline-card {
      background: #fff;
      border-radius: 6px;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      cursor: pointer;
      transition: box-shadow 0.2s, transform 0.1s;
    }

    .pipeline-card:hover {
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }

    .pipeline-card-name {
      font-weight: 600;
      font-size: 0.9rem;
      color: #1a1a2e;
      margin-bottom: 0.25rem;
    }

    .pipeline-card-details {
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 0.5rem;
    }

    .pipeline-card-details span {
      display: block;
      margin-bottom: 0.1rem;
    }

    .pipeline-card-revenue {
      font-weight: 600;
      color: #2e7d32;
    }

    .pipeline-card-actions {
      display: flex;
      gap: 0.35rem;
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid #eee;
    }

    .btn-back {
      background: #f5f5f5;
      color: #666;
    }

    .btn-back:hover {
      background: #e0e0e0;
    }

    .pipeline-empty {
      text-align: center;
      padding: 1.5rem 0.5rem;
      color: #999;
      font-size: 0.8rem;
    }

    .table-container {
      display: block;
    }

    .table-container.hidden {
      display: none;
    }

    /* Practice Name Link */
    .practice-name-link {
      color: #4a6cf7;
      cursor: pointer;
      text-decoration: none;
      font-weight: 500;
    }

    .practice-name-link:hover {
      text-decoration: underline;
    }

    /* Modal Overlay */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 500;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem;
      overflow-y: auto;
    }

    .modal-overlay.visible {
      display: flex;
    }

    .modal {
      background: #fff;
      border-radius: 12px;
      width: 100%;
      max-width: 700px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      animation: modal-slide-in 0.2s ease-out;
    }

    @keyframes modal-slide-in {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.25rem 1.5rem;
      border-bottom: 1px solid #eee;
    }

    .modal-header h2 {
      font-size: 1.25rem;
      font-weight: 600;
      color: #1a1a2e;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      color: #888;
      cursor: pointer;
      padding: 0.25rem;
      line-height: 1;
    }

    .modal-close:hover {
      color: #333;
    }

    .modal-body {
      padding: 1.5rem;
    }

    /* Extraction Confirmation Modal */
    .extraction-modal {
      max-width: 500px;
    }

    .extraction-modal-intro {
      color: #666;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
    }

    .extraction-data-grid {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .extraction-data-item {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .extraction-data-item label {
      font-size: 0.75rem;
      color: #666;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .extraction-value {
      font-size: 1.1rem;
      color: #1a1a2e;
      font-weight: 500;
    }

    .extraction-value.large {
      font-size: 1.5rem;
      font-weight: 700;
      color: #22c55e;
    }

    .extraction-value-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .btn-edit-small {
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      color: #374151;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-edit-small:hover {
      background: #e5e7eb;
      border-color: #9ca3af;
    }

    .period-edit-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .period-edit-row select {
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.9rem;
    }

    .confidence-display {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .confidence-bar-container {
      flex: 1;
      height: 8px;
      background: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
    }

    .confidence-bar-fill {
      height: 100%;
      background: #22c55e;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .extraction-ttm-notice {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .extraction-ttm-notice.warning {
      background: #fef3c7;
      border: 1px solid #fcd34d;
      color: #92400e;
    }

    .extraction-ttm-notice.info {
      background: #dbeafe;
      border: 1px solid #93c5fd;
      color: #1e40af;
    }

    .extraction-input-wrapper {
      display: flex;
      align-items: center;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      overflow: hidden;
      background: white;
    }

    .extraction-input-wrapper:focus-within {
      border-color: #4a6cf7;
      box-shadow: 0 0 0 3px rgba(74, 108, 247, 0.1);
    }

    .extraction-input-wrapper .input-prefix {
      padding: 0.5rem 0.75rem;
      background: #f3f4f6;
      color: #6b7280;
      font-weight: 500;
      border-right: 1px solid #d1d5db;
    }

    .extraction-input {
      flex: 1;
      padding: 0.5rem 0.75rem;
      border: none;
      font-size: 1rem;
      outline: none;
    }

    .extraction-input::placeholder {
      color: #9ca3af;
    }

    .extraction-input::-webkit-outer-spin-button,
    .extraction-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    /* Statement Period Highlighted Section */
    .extraction-period-section {
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
      border: 2px solid #3b82f6;
      border-radius: 12px;
      padding: 1.25rem;
      margin-bottom: 1.5rem;
    }

    .extraction-period-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .extraction-period-header .period-icon {
      font-size: 1.5rem;
    }

    .extraction-period-header label {
      font-size: 1.1rem;
      font-weight: 700;
      color: #1e40af;
      text-transform: none;
      letter-spacing: 0;
    }

    .required-badge {
      background: #dc2626;
      color: white;
      font-size: 0.65rem;
      font-weight: 600;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .period-help-text {
      font-size: 0.9rem;
      color: #1e40af;
      margin: 0 0 0.75rem 0;
    }

    .period-select-row {
      display: flex;
      gap: 0.75rem;
    }

    .period-select {
      flex: 1;
      padding: 0.75rem 1rem;
      font-size: 1.1rem;
      border: 2px solid #93c5fd;
      border-radius: 8px;
      background: white;
      color: #1e3a8a;
      font-weight: 600;
      cursor: pointer;
    }

    .period-select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
    }

    /* Success Toast */
    .extraction-success-toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(34, 197, 94, 0.4);
      display: flex;
      align-items: center;
      gap: 1rem;
      z-index: 10000;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
    }

    .extraction-success-toast.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .extraction-success-toast .toast-icon {
      font-size: 2rem;
      font-weight: bold;
    }

    .extraction-success-toast .toast-content strong {
      display: block;
      font-size: 1.1rem;
      margin-bottom: 0.25rem;
    }

    .extraction-success-toast .toast-content p {
      margin: 0;
      font-size: 1rem;
      opacity: 0.95;
    }

    .extraction-success-toast .toast-content small {
      opacity: 0.8;
      font-size: 0.8rem;
    }

    .extraction-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
      padding-top: 1.25rem;
      border-top: 1px solid #eee;
    }

    .btn-danger {
      background: #fee2e2;
      color: #dc2626;
      border: 1px solid #fca5a5;
    }

    .btn-danger:hover {
      background: #fecaca;
    }

    .profile-section {
      margin-bottom: 1.5rem;
    }

    .profile-section:last-child {
      margin-bottom: 0;
    }

    .profile-section h3 {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #888;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #eee;
    }

    .profile-info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }

    .profile-info-item {
      display: flex;
      flex-direction: column;
    }

    .profile-info-item.full-width {
      grid-column: 1 / -1;
    }

    .profile-info-item label {
      font-size: 0.75rem;
      font-weight: 500;
      color: #888;
      margin-bottom: 0.25rem;
    }

    .profile-info-item .value {
      font-size: 0.95rem;
      color: #333;
    }

    .profile-info-item input,
    .profile-info-item select,
    .profile-info-item textarea {
      padding: 0.5rem 0.6rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 0.9rem;
    }

    .profile-info-item input:focus,
    .profile-info-item select:focus,
    .profile-info-item textarea:focus {
      outline: none;
      border-color: #4a6cf7;
    }

    .profile-info-item textarea {
      resize: vertical;
      min-height: 60px;
    }

    .profile-dates {
      display: flex;
      gap: 2rem;
      font-size: 0.8rem;
      color: #888;
    }

    /* Quick Actions */
    .quick-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .btn-secondary {
      background: #f5f5f5;
      color: #333;
    }

    .btn-secondary:hover {
      background: #e0e0e0;
    }

    .btn-export {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .btn-export:hover {
      background: #c8e6c9;
    }

    .btn-packet {
      background: #e8eaf6;
      color: #3949ab;
    }

    .btn-packet:hover {
      background: #c5cae9;
    }

    /* Activity Log */
    .activity-log {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 6px;
    }

    .activity-log-item {
      padding: 0.6rem 0.75rem;
      border-bottom: 1px solid #eee;
      font-size: 0.85rem;
    }

    .activity-log-item:last-child {
      border-bottom: none;
    }

    .activity-log-item .timestamp {
      font-size: 0.75rem;
      color: #888;
      margin-bottom: 0.15rem;
    }

    .activity-log-item .action {
      color: #333;
    }

    .activity-log-empty {
      padding: 1rem;
      text-align: center;
      color: #888;
      font-size: 0.85rem;
    }

    /* Financial Documents Section */
    .financial-profile-summary {
      background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
      border: 1px solid #86efac;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .fin-profile-metrics {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
    }

    .fin-metric {
      flex: 1;
      min-width: 120px;
    }

    .fin-metric-label {
      font-size: 0.75rem;
      color: #166534;
      text-transform: uppercase;
      font-weight: 600;
      display: block;
      margin-bottom: 0.25rem;
    }

    .fin-metric-value {
      font-size: 0.9rem;
      color: #15803d;
      font-weight: 500;
    }

    .fin-metric-value.large {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .fin-progress-bar {
      height: 8px;
      background: #d1fae5;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.25rem;
    }

    .fin-progress-fill {
      height: 100%;
      background: #22c55e;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .fin-progress-fill.confidence {
      background: #3b82f6;
    }

    .info-tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }

    .info-icon {
      font-size: 12px;
      color: #166534;
      margin-left: 4px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .info-tooltip:hover .info-icon {
      opacity: 1;
    }

    .info-tooltip-text {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: #1f2937;
      color: #fff;
      padding: 12px 14px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 400;
      text-transform: none;
      line-height: 1.5;
      width: 260px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: opacity 0.2s, visibility 0.2s;
    }

    .info-tooltip-text::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: #1f2937;
    }

    .info-tooltip:hover .info-tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    /* Historical Data Section */
    .financial-historical-summary {
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border: 1px solid #7dd3fc;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .fin-historical-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .fin-historical-title {
      font-size: 0.75rem;
      color: #0369a1;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .fin-historical-header .info-icon {
      color: #0369a1;
    }

    .fin-historical-metrics {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
    }

    .fin-historical-item {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .fin-historical-label {
      font-size: 0.7rem;
      color: #0369a1;
      text-transform: uppercase;
      font-weight: 500;
    }

    .fin-historical-value {
      font-size: 1rem;
      color: #0c4a6e;
      font-weight: 600;
    }

    .fin-historical-value.positive {
      color: #16a34a;
    }

    .fin-historical-value.negative {
      color: #dc2626;
    }

    @media (max-width: 600px) {
      .fin-historical-metrics {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Monthly Breakdown Table Styles */
    .fin-monthly-breakdown {
      background: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
    }

    .fin-monthly-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .fin-monthly-title {
      font-size: 0.75rem;
      color: #0369a1;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .fin-monthly-toggle {
      font-size: 0.7rem;
      color: #0369a1;
      cursor: pointer;
      text-decoration: underline;
    }

    .fin-monthly-toggle:hover {
      color: #0c4a6e;
    }

    .fin-monthly-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    .fin-monthly-table th {
      text-align: left;
      padding: 0.5rem 0.75rem;
      background: #e0f2fe;
      color: #0369a1;
      font-size: 0.7rem;
      text-transform: uppercase;
      font-weight: 600;
      border-bottom: 1px solid #bae6fd;
    }

    .fin-monthly-table th:last-child {
      text-align: center;
    }

    .fin-monthly-table td {
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #e0f2fe;
      color: #0c4a6e;
    }

    .fin-monthly-table tr:last-child td {
      border-bottom: none;
    }

    .fin-monthly-table tr:hover {
      background: #e0f2fe;
    }

    .fin-monthly-period {
      font-weight: 600;
    }

    .fin-monthly-value {
      font-family: monospace;
      font-weight: 500;
    }

    .fin-monthly-source {
      font-size: 0.75rem;
    }

    .fin-monthly-source a {
      color: #0369a1;
      text-decoration: none;
    }

    .fin-monthly-source a:hover {
      text-decoration: underline;
    }

    .fin-monthly-confidence {
      text-align: center;
    }

    .fin-confidence-badge {
      display: inline-block;
      padding: 0.15rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .fin-confidence-badge.high {
      background: #dcfce7;
      color: #166534;
    }

    .fin-confidence-badge.medium {
      background: #fef9c3;
      color: #854d0e;
    }

    .fin-confidence-badge.low {
      background: #fee2e2;
      color: #991b1b;
    }

    .fin-override-indicator {
      display: inline-block;
      background: #fef3c7;
      color: #92400e;
      font-size: 0.65rem;
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
      margin-left: 0.5rem;
      font-weight: 500;
    }

    .fin-monthly-empty {
      text-align: center;
      padding: 1rem;
      color: #64748b;
      font-size: 0.85rem;
    }

    /* Evidence Drill-down Modal Styles */
    .evidence-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .evidence-modal {
      background: white;
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    }

    .evidence-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #e2e8f0;
      background: #f8fafc;
      border-radius: 12px 12px 0 0;
    }

    .evidence-modal-title {
      font-size: 1rem;
      font-weight: 600;
      color: #0c4a6e;
      margin: 0;
    }

    .evidence-modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #64748b;
      padding: 0;
      line-height: 1;
    }

    .evidence-modal-close:hover {
      color: #0c4a6e;
    }

    .evidence-modal-body {
      padding: 1.5rem;
    }

    .evidence-section {
      margin-bottom: 1.5rem;
    }

    .evidence-section:last-child {
      margin-bottom: 0;
    }

    .evidence-section-title {
      font-size: 0.7rem;
      text-transform: uppercase;
      color: #0369a1;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }

    .evidence-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #0c4a6e;
    }

    .evidence-row {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      border-bottom: 1px solid #f1f5f9;
    }

    .evidence-row:last-child {
      border-bottom: none;
    }

    .evidence-label {
      color: #64748b;
      font-size: 0.85rem;
    }

    .evidence-data {
      color: #0c4a6e;
      font-weight: 500;
      font-size: 0.85rem;
    }

    .evidence-snippet {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      padding: 0.75rem;
      font-family: monospace;
      font-size: 0.8rem;
      color: #475569;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .evidence-badge {
      display: inline-block;
      padding: 0.2rem 0.6rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .evidence-badge.verified {
      background: #dcfce7;
      color: #166534;
    }

    .evidence-badge.unverified {
      background: #fef9c3;
      color: #854d0e;
    }

    .evidence-badge.override {
      background: #fef3c7;
      color: #92400e;
    }

    .evidence-doc-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: #0369a1;
      text-decoration: none;
      font-weight: 500;
    }

    .evidence-doc-link:hover {
      text-decoration: underline;
    }

    /* Document Hub Styles */
    .doc-hub-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .doc-hub-header h3 {
      margin: 0;
    }

    .doc-hub-tabs {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .doc-hub-tab {
      padding: 0.5rem 1rem;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      background: #f9fafb;
      color: #374151;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .doc-hub-tab:hover {
      background: #f3f4f6;
      border-color: #d1d5db;
    }

    .doc-hub-tab.active {
      background: #1a1a2e;
      color: #fff;
      border-color: #1a1a2e;
    }

    .doc-hub-tab .tab-icon {
      font-size: 1rem;
    }

    .doc-tab-content {
      display: none;
    }

    .doc-tab-content.active {
      display: block;
    }

    /* DD Readiness Bar */
    .dd-readiness-bar {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      background: #fafafa;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
    }

    .dd-readiness-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .dd-readiness-track {
      flex: 1;
      height: 10px;
      background: #e5e7eb;
      border-radius: 5px;
      overflow: hidden;
    }

    .dd-readiness-fill {
      height: 100%;
      background: linear-gradient(90deg, #f59e0b, #22c55e);
      border-radius: 5px;
      transition: width 0.3s ease;
    }

    .dd-readiness-pct {
      font-size: 0.9rem;
      font-weight: 700;
      color: #1a1a2e;
      min-width: 40px;
      text-align: right;
    }

    .dd-readiness-trend {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .trend-indicator {
      font-size: 1rem;
      font-weight: 600;
    }

    .trend-indicator.up {
      color: #22c55e;
    }

    .trend-indicator.down {
      color: #ef4444;
    }

    .trend-indicator.neutral {
      color: #6b7280;
    }

    .trend-sparkline {
      color: #4a6cf7;
    }

    .trend-label {
      color: #9ca3af;
      font-size: 0.65rem;
    }

    .trend-empty {
      color: #9ca3af;
      font-size: 0.7rem;
      font-style: italic;
    }

    /* Missing Docs Report */
    .missing-docs-report {
      max-height: 500px;
      overflow-y: auto;
    }

    .missing-docs-practice {
      margin-bottom: 1.5rem;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
    }

    .missing-docs-practice-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
    }

    .missing-docs-practice-name {
      font-weight: 600;
      color: #1a1a2e;
    }

    .missing-docs-practice-score {
      font-size: 0.85rem;
      font-weight: 600;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .missing-docs-practice-score.low {
      background: #fee2e2;
      color: #dc2626;
    }

    .missing-docs-practice-score.medium {
      background: #fef3c7;
      color: #d97706;
    }

    .missing-docs-practice-score.high {
      background: #d1fae5;
      color: #059669;
    }

    .missing-docs-list {
      padding: 0.75rem 1rem;
    }

    .missing-doc-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0;
      font-size: 0.85rem;
      color: #4b5563;
    }

    .missing-doc-item .missing-icon {
      color: #ef4444;
    }

    .missing-doc-item .has-icon {
      color: #22c55e;
    }

    .missing-doc-item.blocker {
      color: #dc2626;
      font-weight: 500;
    }

    .btn-missing-report {
      padding: 0.5rem 1rem;
      background: #f59e0b;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      white-space: nowrap;
    }

    .btn-missing-report:hover {
      background: #d97706;
    }

    .btn-apply-template {
      padding: 0.5rem 1rem;
      background: #4a6cf7;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.15s;
    }

    .btn-apply-template:hover {
      background: #3a5ce5;
    }

    .btn-apply-template:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }

    .btn-apply-template.applied {
      background: #d1fae5;
      color: #065f46;
    }

    .btn-bulk-upload {
      padding: 0.5rem 1rem;
      background: #059669;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.15s;
    }

    .btn-bulk-upload:hover {
      background: #047857;
    }

    /* Bulk Upload Modal */
    .bulk-upload-preview {
      max-height: 400px;
      overflow-y: auto;
    }

    .bulk-upload-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.75rem;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      margin-bottom: 0.5rem;
    }

    .bulk-upload-item .file-icon {
      font-size: 1.5rem;
    }

    .bulk-upload-item .file-info {
      flex: 1;
      min-width: 0;
    }

    .bulk-upload-item .file-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .bulk-upload-item .file-category {
      font-size: 0.75rem;
      color: #059669;
    }

    .bulk-upload-item .file-category.unknown {
      color: #d97706;
    }

    .bulk-upload-item select {
      padding: 0.25rem 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .bulk-upload-summary {
      padding: 1rem;
      background: #f0fdf4;
      border-radius: 6px;
      margin-bottom: 1rem;
      font-size: 0.85rem;
    }

    /* Document Notes */
    .btn-doc-notes {
      font-size: 0.65rem;
      padding: 0.15rem 0.35rem;
      background: #fef3c7;
      border: 1px solid #fcd34d;
      border-radius: 3px;
      color: #92400e;
      cursor: pointer;
      margin-left: 0.25rem;
    }

    .btn-doc-notes:hover {
      background: #fcd34d;
    }

    .btn-doc-notes.has-notes {
      background: #fef3c7;
    }

    .btn-doc-notes.no-notes {
      background: #f3f4f6;
      border-color: #e5e7eb;
      color: #6b7280;
    }

    .notes-modal-content {
      padding: 1.5rem;
    }

    .notes-textarea {
      width: 100%;
      min-height: 150px;
      padding: 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.9rem;
      font-family: inherit;
      resize: vertical;
    }

    .notes-meta {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.5rem;
    }

    /* DD Checklist Section */
    .dd-checklist-section {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      margin-bottom: 1rem;
      overflow: hidden;
    }

    .dd-checklist-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f9fafb;
      cursor: pointer;
      user-select: none;
      transition: background 0.15s;
    }

    .dd-checklist-header:hover {
      background: #f3f4f6;
    }

    .dd-checklist-title {
      font-weight: 600;
      font-size: 0.9rem;
      color: #1a1a2e;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .checklist-toggle-icon {
      font-size: 0.7rem;
      transition: transform 0.2s;
    }

    .checklist-toggle-icon.open {
      transform: rotate(90deg);
    }

    .dd-checklist-summary {
      font-size: 0.8rem;
      color: #666;
      font-weight: 500;
    }

    .dd-checklist-content {
      border-top: 1px solid #e5e7eb;
    }

    .dd-checklist-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .dd-checklist-empty {
      padding: 2rem;
      text-align: center;
      color: #999;
      font-size: 0.9rem;
    }

    .dd-checklist-item {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #f3f4f6;
      transition: background 0.15s;
    }

    .dd-checklist-item:last-child {
      border-bottom: none;
    }

    .dd-checklist-item:hover {
      background: #fafafa;
    }

    .dd-checklist-item.completed {
      background: #f0fdf4;
    }

    .dd-checklist-item.blocker {
      border-left: 3px solid #ef4444;
    }

    .dd-checklist-item.blocker.completed {
      border-left-color: #22c55e;
    }

    .checklist-checkbox {
      width: 20px;
      height: 20px;
      border: 2px solid #d1d5db;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-top: 2px;
      font-size: 0.75rem;
      color: #fff;
      background: #fff;
    }

    .checklist-checkbox.checked {
      background: #22c55e;
      border-color: #22c55e;
    }

    .checklist-item-content {
      flex: 1;
      min-width: 0;
    }

    .checklist-item-title {
      font-weight: 500;
      color: #1a1a2e;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .checklist-item-title .blocker-badge {
      background: #fef2f2;
      color: #dc2626;
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .checklist-item-desc {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.25rem;
    }

    .checklist-item-progress {
      font-size: 0.75rem;
      color: #888;
      margin-top: 0.35rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .checklist-item-progress .progress-bar {
      width: 60px;
      height: 4px;
      background: #e5e7eb;
      border-radius: 2px;
      overflow: hidden;
    }

    .checklist-item-progress .progress-fill {
      height: 100%;
      background: #22c55e;
      border-radius: 2px;
    }

    /* Link Documents UI */
    .checklist-item-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .btn-link-doc {
      font-size: 0.7rem;
      padding: 0.25rem 0.5rem;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      color: #4b5563;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .btn-link-doc:hover {
      background: #e5e7eb;
    }

    .linked-docs-list {
      margin-top: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }

    .linked-doc-chip {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      background: #eff6ff;
      border: 1px solid #bfdbfe;
      border-radius: 4px;
      padding: 0.2rem 0.4rem;
      font-size: 0.7rem;
      color: #1e40af;
      max-width: 180px;
    }

    .linked-doc-chip .doc-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .linked-doc-chip .unlink-btn {
      cursor: pointer;
      color: #6b7280;
      font-size: 0.8rem;
      line-height: 1;
    }

    .linked-doc-chip .unlink-btn:hover {
      color: #dc2626;
    }

    /* Document picker dropdown */
    .doc-picker-dropdown {
      position: absolute;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 280px;
      max-height: 300px;
      overflow-y: auto;
    }

    .doc-picker-header {
      padding: 0.75rem;
      border-bottom: 1px solid #e5e7eb;
      font-weight: 600;
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .doc-picker-close {
      cursor: pointer;
      color: #6b7280;
      font-size: 1.1rem;
    }

    .doc-picker-list {
      padding: 0.5rem;
    }

    .doc-picker-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .doc-picker-item:hover {
      background: #f3f4f6;
    }

    .doc-picker-item.already-linked {
      opacity: 0.5;
      cursor: default;
    }

    .doc-picker-item .doc-icon {
      font-size: 1rem;
    }

    .doc-picker-item .doc-info {
      flex: 1;
      min-width: 0;
    }

    .doc-picker-item .doc-info .doc-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #1a1a2e;
    }

    .doc-picker-item .doc-info .doc-type {
      font-size: 0.7rem;
      color: #6b7280;
    }

    .doc-picker-empty {
      padding: 1rem;
      text-align: center;
      color: #6b7280;
      font-size: 0.8rem;
    }

    .checklist-category-header {
      padding: 0.5rem 1rem;
      background: #f3f4f6;
      font-size: 0.75rem;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
    }

    /* DD Tab Content */
    .dd-tab-header {
      margin-bottom: 1rem;
    }

    .dd-tab-header h4 {
      margin: 0 0 0.25rem 0;
      color: #1a1a2e;
      font-size: 1rem;
    }

    .dd-tab-desc {
      margin: 0;
      font-size: 0.85rem;
      color: #666;
    }

    .dd-upload-area {
      margin-bottom: 1rem;
    }

    .dd-upload-dropzone {
      border: 2px dashed #d1d5db;
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      background: #fafafa;
    }

    .dd-upload-dropzone:hover,
    .dd-upload-dropzone.dragover {
      border-color: #3b82f6;
      background: #eff6ff;
    }

    .dd-upload-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .dd-upload-text {
      font-size: 0.9rem;
      color: #666;
    }

    .dd-category-select {
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .dd-category-select label {
      font-size: 0.85rem;
      font-weight: 500;
      color: #374151;
    }

    .dd-category-select select {
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .dd-documents-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .dd-docs-empty {
      padding: 2rem;
      text-align: center;
      color: #999;
      font-size: 0.9rem;
      background: #f9fafb;
      border-radius: 8px;
    }

    .dd-doc-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      transition: all 0.15s;
    }

    .dd-doc-item:hover {
      border-color: #d1d5db;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .dd-doc-icon {
      font-size: 1.5rem;
    }

    .dd-doc-info {
      flex: 1;
      min-width: 0;
    }

    .dd-doc-name {
      font-weight: 500;
      color: #1a1a2e;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dd-doc-meta {
      font-size: 0.75rem;
      color: #888;
    }

    .dd-doc-status {
      font-size: 0.7rem;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-weight: 500;
      text-transform: uppercase;
    }

    .dd-doc-status.unreviewed,
    .dd-doc-status.pending {
      background: #fef3c7;
      color: #92400e;
    }

    .dd-doc-status.confirmed,
    .dd-doc-status.verified {
      background: #d1fae5;
      color: #065f46;
    }

    .dd-doc-status.flagged {
      background: #fee2e2;
      color: #991b1b;
    }

    .dd-doc-status.expired {
      background: #f3f4f6;
      color: #6b7280;
    }

    /* Expiration badges */
    .expiry-badge {
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-weight: 500;
      margin-left: 0.5rem;
    }

    .expiry-badge.expired {
      background: #fee2e2;
      color: #dc2626;
    }

    .expiry-badge.expiring-soon {
      background: #fef3c7;
      color: #d97706;
    }

    .expiry-badge.valid {
      background: #d1fae5;
      color: #059669;
    }

    .dd-doc-expiry {
      font-size: 0.7rem;
      color: #6b7280;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .btn-set-expiry {
      font-size: 0.65rem;
      padding: 0.15rem 0.35rem;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 3px;
      color: #6b7280;
      cursor: pointer;
    }

    .btn-set-expiry:hover {
      background: #e5e7eb;
    }

    /* Version indicator */
    .version-badge {
      font-size: 0.6rem;
      padding: 0.1rem 0.3rem;
      background: #e0e7ff;
      color: #4338ca;
      border-radius: 3px;
      margin-left: 0.4rem;
      font-weight: 600;
    }

    .version-badge.superseded {
      background: #f3f4f6;
      color: #6b7280;
      text-decoration: line-through;
    }

    .btn-new-version {
      font-size: 0.65rem;
      padding: 0.15rem 0.35rem;
      background: #e0e7ff;
      border: 1px solid #c7d2fe;
      border-radius: 3px;
      color: #4338ca;
      cursor: pointer;
      margin-left: 0.25rem;
    }

    .btn-new-version:hover {
      background: #c7d2fe;
    }

    /* Extraction styles */
    .btn-extract {
      background: #f0f9ff;
      border: 1px solid #bae6fd;
      color: #0284c7;
    }

    .btn-extract:hover {
      background: #e0f2fe;
    }

    .btn-extract.extracting {
      opacity: 0.6;
      cursor: wait;
    }

    .dd-doc-extracted {
      margin-top: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: #f0fdf4;
      border: 1px solid #bbf7d0;
      border-radius: 6px;
      font-size: 0.75rem;
    }

    .dd-doc-extracted-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.35rem;
      font-weight: 600;
      color: #15803d;
    }

    .dd-doc-extracted-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 0.35rem 1rem;
    }

    .dd-doc-extracted-field {
      display: flex;
      flex-direction: column;
    }

    .dd-doc-extracted-label {
      font-size: 0.65rem;
      color: #6b7280;
      text-transform: uppercase;
    }

    .dd-doc-extracted-value {
      color: #1f2937;
      font-weight: 500;
    }

    /* Extraction modal */
    .extraction-modal-content {
      max-width: 500px;
    }

    .extraction-fields {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin: 1rem 0;
    }

    .extraction-field {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .extraction-field label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #374151;
    }

    .extraction-field input {
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.875rem;
    }

    .extraction-field input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
    }

    .extraction-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem;
      background: #f3f4f6;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .extraction-status.processing {
      background: #fef3c7;
      color: #92400e;
    }

    .extraction-status.success {
      background: #d1fae5;
      color: #065f46;
    }

    .extraction-status.error {
      background: #fee2e2;
      color: #991b1b;
    }

    .extraction-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #d1d5db;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    /* Template picker modal */
    .template-picker-modal {
      max-width: 600px;
    }

    .template-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      max-height: 400px;
      overflow-y: auto;
    }

    .template-card {
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .template-card:hover {
      border-color: #3b82f6;
      background: #f8fafc;
    }

    .template-card.selected {
      border-color: #3b82f6;
      background: #eff6ff;
    }

    .template-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }

    .template-card-name {
      font-weight: 600;
      color: #1a1a2e;
      font-size: 0.95rem;
    }

    .template-card-badge {
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
      background: #e0e7ff;
      color: #4338ca;
      border-radius: 4px;
      font-weight: 500;
    }

    .template-card-desc {
      font-size: 0.8rem;
      color: #6b7280;
      margin-bottom: 0.75rem;
    }

    .template-card-preview {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }

    .template-item-tag {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      background: #f3f4f6;
      color: #4b5563;
      border-radius: 4px;
    }

    .template-item-tag.category {
      background: #fef3c7;
      color: #92400e;
    }

    .template-options {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e7eb;
    }

    .template-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      color: #374151;
    }

    .template-option input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }

    /* Version history dropdown */
    .version-history {
      position: absolute;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 220px;
      max-height: 200px;
      overflow-y: auto;
    }

    .version-history-header {
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #e5e7eb;
      font-weight: 600;
      font-size: 0.8rem;
    }

    .version-history-item {
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .version-history-item:hover {
      background: #f3f4f6;
    }

    .version-history-item.current {
      background: #eff6ff;
    }

    /* Expiry modal */
    .expiry-modal-content {
      padding: 1.5rem;
    }

    .expiry-form-group {
      margin-bottom: 1rem;
    }

    .expiry-form-group label {
      display: block;
      font-weight: 500;
      margin-bottom: 0.5rem;
      color: #374151;
    }

    .expiry-form-group input {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.9rem;
    }

    .expiry-form-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 1.5rem;
    }

    .dd-doc-actions button.verified {
      background: #d1fae5;
      color: #065f46;
      border-color: #a7f3d0;
    }

    .dd-doc-actions {
      display: flex;
      gap: 0.5rem;
    }

    .dd-doc-actions button {
      padding: 0.35rem 0.75rem;
      font-size: 0.75rem;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      background: #fff;
      color: #374151;
      cursor: pointer;
      transition: all 0.15s;
    }

    .dd-doc-actions button:hover {
      background: #f3f4f6;
      border-color: #d1d5db;
    }

    .fin-upload-area {
      margin-bottom: 1rem;
    }

    .fin-upload-dropzone {
      border: 2px dashed #d1d5db;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      background: #fafafa;
    }

    .fin-upload-dropzone:hover {
      border-color: #22c55e;
      background: #f0fdf4;
    }

    .fin-upload-dropzone.dragover {
      border-color: #22c55e;
      background: #dcfce7;
    }

    .fin-upload-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .fin-upload-text {
      font-size: 0.95rem;
      color: #374151;
      margin-bottom: 0.25rem;
    }

    .fin-upload-hint {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .fin-doc-type-selector {
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: #f9fafb;
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .fin-doc-type-selector label {
      font-size: 0.85rem;
      font-weight: 500;
    }

    .fin-doc-type-selector select {
      padding: 0.4rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    .fin-documents-list {
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
    }

    .fin-docs-empty {
      padding: 1.5rem;
      text-align: center;
      color: #9ca3af;
      font-size: 0.9rem;
    }

    .fin-doc-item {
      display: flex;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      gap: 0.75rem;
    }

    .fin-doc-item:last-child {
      border-bottom: none;
    }

    .fin-doc-icon {
      font-size: 1.25rem;
    }

    .fin-doc-info {
      flex: 1;
      min-width: 0;
    }

    .fin-doc-name {
      font-size: 0.9rem;
      font-weight: 500;
      color: #1f2937;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .fin-doc-meta {
      font-size: 0.75rem;
      color: #6b7280;
    }

    .fin-doc-status {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.3rem 0.5rem;
      border-radius: 4px;
      min-width: 75px;
    }

    .fin-doc-status-label {
      font-size: 0.6rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .fin-doc-status-date {
      font-size: 0.55rem;
      font-weight: 400;
      opacity: 0.85;
      margin-top: 2px;
    }

    .fin-doc-status.uploaded {
      background: #fef3c7;
      color: #92400e;
    }

    .fin-doc-status.processing {
      background: #dbeafe;
      color: #1e40af;
    }

    .fin-doc-status.completed {
      background: #dcfce7;
      color: #166534;
    }

    .fin-doc-status.failed {
      background: #fee2e2;
      color: #991b1b;
    }

    .fin-doc-actions {
      display: flex;
      gap: 0.5rem;
    }

    .fin-doc-actions button {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 4px;
      cursor: pointer;
    }

    .fin-doc-actions button:hover {
      background: #f3f4f6;
    }

    /* Practice Intelligence Panel */
    .intelligence-panel {
      background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
      border: 1px solid #e0e7ff;
      border-radius: 8px;
      padding: 1rem;
    }

    .intelligence-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .intelligence-score {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .score-circle {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.95rem;
      color: #fff;
    }

    .score-circle.green { background: linear-gradient(135deg, #10b981 0%, #059669 100%); }
    .score-circle.yellow { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }
    .score-circle.red { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); }

    .score-label {
      font-size: 0.75rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .health-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.75rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .health-badge.green { background: #d1fae5; color: #065f46; }
    .health-badge.yellow { background: #fef3c7; color: #92400e; }
    .health-badge.red { background: #fee2e2; color: #991b1b; }

    .health-badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .health-badge.green .health-badge-dot { background: #10b981; }
    .health-badge.yellow .health-badge-dot { background: #f59e0b; }
    .health-badge.red .health-badge-dot { background: #ef4444; }

    .intelligence-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    .intelligence-section {
      background: #fff;
      border-radius: 6px;
      padding: 0.75rem;
      border: 1px solid #e5e7eb;
    }

    .intelligence-section h4 {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #6b7280;
      margin-bottom: 0.5rem;
    }

    .risk-list, .action-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .risk-list li, .action-list li {
      font-size: 0.8rem;
      padding: 0.35rem 0;
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
      color: #374151;
    }

    .risk-list li:before {
      content: "!";
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background: #fef3c7;
      color: #92400e;
      border-radius: 50%;
      font-size: 0.65rem;
      font-weight: 700;
      flex-shrink: 0;
      margin-top: 1px;
    }

    .action-list li:before {
      content: counter(action-counter);
      counter-increment: action-counter;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background: #dbeafe;
      color: #1e40af;
      border-radius: 50%;
      font-size: 0.65rem;
      font-weight: 600;
      flex-shrink: 0;
      margin-top: 1px;
    }

    .action-list {
      counter-reset: action-counter;
    }

    .intelligence-empty {
      font-size: 0.8rem;
      color: #9ca3af;
      font-style: italic;
    }

    /* Portfolio Intelligence Dashboard */
    .portfolio-container {
      display: none;
    }

    .portfolio-container.visible {
      display: block;
    }

    .portfolio-dashboard {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .portfolio-kpis {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
    }

    .kpi-card {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
    }

    .kpi-value {
      font-size: 1.75rem;
      font-weight: 700;
      color: #1a1a2e;
      line-height: 1.2;
    }

    .kpi-value.green { color: #059669; }
    .kpi-value.yellow { color: #d97706; }
    .kpi-value.red { color: #dc2626; }

    .kpi-label {
      font-size: 0.7rem;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 0.25rem;
    }

    .portfolio-section {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
    }

    .portfolio-section-header {
      background: #f8f9fa;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .portfolio-section-header h3 {
      font-size: 0.85rem;
      font-weight: 600;
      color: #374151;
      margin: 0;
    }

    .portfolio-section-header .badge {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 10px;
      background: #e5e7eb;
      color: #4b5563;
    }

    .work-queue {
      max-height: 400px;
      overflow-y: auto;
    }

    .work-queue-row {
      display: grid;
      grid-template-columns: 2fr 100px 80px 80px 2fr;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #f3f4f6;
      align-items: center;
      cursor: pointer;
      transition: background 0.15s;
    }

    .work-queue-row:hover {
      background: #f9fafb;
    }

    .work-queue-row:last-child {
      border-bottom: none;
    }

    .work-queue-header {
      background: #f8f9fa;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #6b7280;
      cursor: default;
    }

    .work-queue-header:hover {
      background: #f8f9fa;
    }

    .wq-name {
      font-weight: 500;
      color: #1f2937;
      font-size: 0.85rem;
    }

    .wq-status {
      font-size: 0.75rem;
    }

    .wq-score {
      font-weight: 600;
      font-size: 0.85rem;
    }

    .wq-score.green { color: #059669; }
    .wq-score.yellow { color: #d97706; }
    .wq-score.red { color: #dc2626; }

    .wq-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.2rem 0.5rem;
      border-radius: 10px;
      font-size: 0.65rem;
      font-weight: 600;
    }

    .wq-badge.green { background: #d1fae5; color: #065f46; }
    .wq-badge.yellow { background: #fef3c7; color: #92400e; }
    .wq-badge.red { background: #fee2e2; color: #991b1b; }

    .wq-badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    .wq-badge.green .wq-badge-dot { background: #10b981; }
    .wq-badge.yellow .wq-badge-dot { background: #f59e0b; }
    .wq-badge.red .wq-badge-dot { background: #ef4444; }

    .wq-actions {
      font-size: 0.75rem;
      color: #6b7280;
      line-height: 1.3;
    }

    .wq-actions .action-item {
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .work-queue-empty {
      padding: 2rem;
      text-align: center;
      color: #9ca3af;
      font-size: 0.85rem;
    }

    .risk-overview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0;
    }

    .risk-overview-item {
      padding: 1rem;
      border-right: 1px solid #f3f4f6;
      border-bottom: 1px solid #f3f4f6;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .risk-overview-item:last-child {
      border-right: none;
    }

    .risk-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      flex-shrink: 0;
    }

    .risk-icon.warning { background: #fef3c7; }
    .risk-icon.danger { background: #fee2e2; }
    .risk-icon.info { background: #dbeafe; }

    .risk-details {
      flex: 1;
    }

    .risk-count {
      font-size: 1.25rem;
      font-weight: 700;
      color: #1f2937;
    }

    .risk-label {
      font-size: 0.7rem;
      color: #6b7280;
    }

    .capital-ready-section {
      padding: 1.25rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .capital-ready-stat {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .capital-ready-count {
      font-size: 2.5rem;
      font-weight: 700;
      color: #059669;
    }

    .capital-ready-label {
      font-size: 0.85rem;
      color: #374151;
      line-height: 1.3;
    }

    .capital-ready-label small {
      display: block;
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .capital-ready-criteria {
      font-size: 0.75rem;
      color: #6b7280;
      text-align: right;
      line-height: 1.5;
    }

    .capital-ready-criteria span {
      display: block;
    }

    /* =============================================
       OPERATOR TASKS VIEW
       ============================================= */
    #operator-tasks-container {
      padding: 1rem;
    }

    .operator-tasks-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .operator-tasks-header h2 {
      margin: 0;
      font-size: 1.25rem;
      color: #1f2937;
    }

    .operator-tasks-summary {
      font-size: 0.85rem;
      color: #6b7280;
    }

    .operator-tasks-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1rem;
      padding: 0.75rem 1rem;
      background: #f8f9fa;
      border-radius: 8px;
      align-items: flex-end;
    }

    .operator-filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .operator-filter-group label {
      font-size: 0.7rem;
      font-weight: 600;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .operator-filter-group select {
      padding: 0.4rem 0.6rem;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.8rem;
      min-width: 120px;
    }

    .operator-filter-group select:focus {
      outline: none;
      border-color: #4a6cf7;
    }

    .operator-filter-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.6rem;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .operator-filter-checkbox input {
      margin: 0;
    }

    .operator-filter-checkbox.active {
      background: #e8f4ff;
      border-color: #4a6cf7;
    }

    .operator-clear-filters {
      padding: 0.4rem 0.75rem;
      background: #6b7280;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .operator-clear-filters:hover {
      background: #4b5563;
    }

    .operator-tasks-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .operator-task-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.75rem 1rem;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .operator-task-item:hover {
      border-color: #4a6cf7;
      box-shadow: 0 2px 8px rgba(74, 108, 247, 0.1);
    }

    .task-severity-badge {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.65rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
    }

    .task-severity-badge.critical {
      background: #fee2e2;
      color: #991b1b;
    }

    .task-severity-badge.high {
      background: #ffedd5;
      color: #c2410c;
    }

    .task-severity-badge.medium {
      background: #fef3c7;
      color: #b45309;
    }

    .task-severity-badge.low {
      background: #d1fae5;
      color: #065f46;
    }

    .task-main-info {
      flex: 1;
      min-width: 0;
    }

    .task-label {
      font-weight: 600;
      font-size: 0.9rem;
      color: #1f2937;
      margin-bottom: 0.15rem;
    }

    .task-description {
      font-size: 0.8rem;
      color: #6b7280;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .task-practice-info {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.15rem;
      min-width: 140px;
    }

    .task-practice-name {
      font-weight: 600;
      font-size: 0.85rem;
      color: #374151;
      max-width: 140px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .task-practice-status {
      font-size: 0.7rem;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      background: #f3f4f6;
      color: #6b7280;
    }

    .task-practice-status.lead {
      background: #dbeafe;
      color: #1d4ed8;
    }

    .task-practice-status.onboarding {
      background: #fef3c7;
      color: #b45309;
    }

    .task-practice-status.active {
      background: #d1fae5;
      color: #065f46;
    }

    .task-urgency-score {
      font-size: 0.7rem;
      color: #9ca3af;
      text-align: right;
    }

    .task-action-hint {
      font-size: 0.75rem;
      color: #4a6cf7;
      opacity: 0;
      transition: opacity 0.15s ease;
    }

    .operator-task-item:hover .task-action-hint {
      opacity: 1;
    }

    .operator-tasks-empty {
      padding: 3rem 1rem;
      text-align: center;
      color: #6b7280;
    }

    .operator-tasks-empty-icon {
      font-size: 3rem;
      margin-bottom: 0.5rem;
    }

    .operator-tasks-empty h3 {
      margin: 0 0 0.5rem 0;
      font-size: 1rem;
      color: #374151;
    }

    .operator-tasks-empty p {
      margin: 0;
      font-size: 0.85rem;
    }

    /* Task reason (trust layer) */
    .task-reason {
      font-size: 0.7rem;
      color: #9ca3af;
      font-style: italic;
      margin-top: 0.15rem;
    }

    /* Quick action buttons */
    .task-quick-actions {
      display: flex;
      gap: 0.5rem;
      margin-left: 0.5rem;
    }

    .task-quick-btn {
      padding: 0.25rem 0.5rem;
      font-size: 0.7rem;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      background: white;
      color: #4b5563;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.15s ease;
    }

    .task-quick-btn:hover {
      background: #f3f4f6;
      border-color: #d1d5db;
    }

    .task-quick-btn.primary {
      background: #4a6cf7;
      border-color: #4a6cf7;
      color: white;
    }

    .task-quick-btn.primary:hover {
      background: #3b5de7;
    }

    /* Practice group collapse */
    .practice-task-group {
      margin-bottom: 0.25rem;
    }

    .practice-task-group-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: #f8f9fa;
      border-radius: 6px 6px 0 0;
      font-size: 0.8rem;
      color: #374151;
      font-weight: 600;
    }

    .practice-task-group-header .practice-name {
      flex: 1;
    }

    .practice-task-group-header .task-count {
      font-size: 0.7rem;
      color: #6b7280;
      font-weight: 400;
    }

    .practice-task-group .operator-task-item:first-of-type {
      border-radius: 0;
    }

    .practice-task-group .operator-task-item:last-of-type {
      border-radius: 0 0 6px 6px;
    }

    .collapsed-tasks-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: #f3f4f6;
      border: 1px dashed #d1d5db;
      border-top: none;
      border-radius: 0 0 6px 6px;
      font-size: 0.75rem;
      color: #6b7280;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .collapsed-tasks-toggle:hover {
      background: #e5e7eb;
      color: #374151;
    }

    .collapsed-tasks-toggle .expand-icon {
      font-size: 0.65rem;
    }

    .collapsed-tasks {
      display: none;
    }

    .collapsed-tasks.expanded {
      display: block;
    }

    .collapsed-tasks .operator-task-item {
      border-radius: 0;
      border-top: none;
      background: #fafafa;
    }

    .collapsed-tasks .operator-task-item:last-child {
      border-radius: 0 0 6px 6px;
    }

    /* Global Search & Filter Bar */
    .search-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 8px;
      align-items: flex-end;
    }

    .search-input-wrapper {
      flex: 1;
      min-width: 200px;
    }

    .search-input-wrapper label,
    .filter-select-wrapper label {
      display: block;
      font-size: 0.7rem;
      font-weight: 600;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }

    .search-input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .search-input:focus {
      outline: none;
      border-color: #4a6cf7;
      box-shadow: 0 0 0 2px rgba(74, 108, 247, 0.1);
    }

    .filter-select-wrapper {
      min-width: 130px;
    }

    .filter-select {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 0.85rem;
      background: #fff;
      cursor: pointer;
    }

    .filter-actions {
      display: flex;
      gap: 0.5rem;
    }

    .btn-clear-filters {
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      color: #666;
    }

    .btn-clear-filters:hover {
      background: #f5f5f5;
    }

    .active-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .filter-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.5rem;
      background: #e0e7ff;
      color: #3730a3;
      border-radius: 12px;
      font-size: 0.75rem;
    }

    .filter-chip-remove {
      cursor: pointer;
      font-weight: bold;
      opacity: 0.7;
    }

    .filter-chip-remove:hover {
      opacity: 1;
    }

    /* Tags System */
    .tags-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      align-items: center;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.2rem 0.5rem;
      background: #f3f4f6;
      color: #374151;
      border-radius: 12px;
      font-size: 0.75rem;
      border: 1px solid #e5e7eb;
    }

    .tag-remove {
      cursor: pointer;
      font-size: 0.9rem;
      line-height: 1;
      opacity: 0.6;
    }

    .tag-remove:hover {
      opacity: 1;
      color: #dc2626;
    }

    .tag-input-wrapper {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .tag-input {
      width: 100px;
      padding: 0.2rem 0.4rem;
      border: 1px dashed #d1d5db;
      border-radius: 12px;
      font-size: 0.75rem;
      background: transparent;
    }

    .tag-input:focus {
      outline: none;
      border-color: #4a6cf7;
      border-style: solid;
    }

    .tag-input::placeholder {
      color: #9ca3af;
    }

    /* Profile Sections Grid */
    .profile-details-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.75rem;
    }

    .profile-details-item {
      display: flex;
      flex-direction: column;
    }

    .profile-details-item label {
      font-size: 0.7rem;
      font-weight: 500;
      color: #6b7280;
      margin-bottom: 0.2rem;
    }

    .profile-details-item input,
    .profile-details-item select {
      padding: 0.4rem 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .profile-details-item input:focus,
    .profile-details-item select:focus {
      outline: none;
      border-color: #4a6cf7;
    }

    .profile-subsection {
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px solid #f3f4f6;
    }

    .profile-subsection h4 {
      font-size: 0.75rem;
      font-weight: 600;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.75rem;
    }

    /* Locations Section */
    .locations-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }

    .location-card {
      background: #f8f9fa;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 0.75rem;
      position: relative;
    }

    .location-card.is-primary {
      border-color: #4a6cf7;
      background: #f0f4ff;
    }

    .location-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .location-card-header .location-name {
      font-weight: 600;
      font-size: 0.85rem;
      color: #1a1a2e;
    }

    .location-card-header .primary-badge {
      font-size: 0.65rem;
      background: #4a6cf7;
      color: white;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      text-transform: uppercase;
    }

    .location-card-actions {
      display: flex;
      gap: 0.5rem;
    }

    .location-card-actions button {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border: 1px solid #ddd;
      background: white;
      border-radius: 3px;
      cursor: pointer;
    }

    .location-card-actions button:hover {
      background: #f3f4f6;
    }

    .location-card-actions .btn-delete-location {
      color: #dc2626;
      border-color: #fca5a5;
    }

    .location-card-actions .btn-delete-location:hover {
      background: #fee2e2;
    }

    .location-card-body {
      font-size: 0.8rem;
      color: #4b5563;
      line-height: 1.4;
    }

    .location-edit-form {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

    .location-edit-form .full-width {
      grid-column: 1 / -1;
    }

    .location-edit-form input,
    .location-edit-form select {
      padding: 0.4rem 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .location-edit-form label {
      font-size: 0.7rem;
      font-weight: 500;
      color: #6b7280;
      margin-bottom: 0.2rem;
      display: block;
    }

    .location-form-item {
      display: flex;
      flex-direction: column;
    }

    .location-form-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      grid-column: 1 / -1;
    }

    .btn-add-location {
      font-size: 0.8rem;
      padding: 0.5rem 1rem;
      background: #f3f4f6;
      border: 1px dashed #9ca3af;
      border-radius: 4px;
      color: #6b7280;
      cursor: pointer;
      width: 100%;
    }

    .btn-add-location:hover {
      background: #e5e7eb;
      color: #4b5563;
    }

    .locations-empty {
      font-size: 0.85rem;
      color: #9ca3af;
      text-align: center;
      padding: 1rem;
    }

    /* Specialty dropdown with optgroups */
    .specialty-select optgroup {
      font-weight: 600;
      color: #374151;
    }

    .specialty-select option {
      font-weight: 400;
      padding-left: 1rem;
    }

    /* Data Management Section */
    .data-management-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
    }

    .data-section {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.25rem;
    }

    .data-section h4 {
      font-size: 0.95rem;
      font-weight: 600;
      color: #1a1a2e;
      margin-bottom: 0.5rem;
    }

    .data-description {
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 1rem;
      line-height: 1.4;
    }

    .data-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .file-upload-btn {
      cursor: pointer;
      display: inline-block;
    }

    .diagnostics-output {
      margin-top: 1rem;
      padding: 1rem;
      background: #1a1a2e;
      color: #0f0;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.75rem;
      border-radius: 6px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    .diagnostics-output.error {
      color: #ff6b6b;
    }

    .diagnostics-output.success {
      color: #69db7c;
    }

    .import-status {
      margin-top: 0.75rem;
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .import-status.success {
      background: #d3f9d8;
      color: #2b8a3e;
    }

    .import-status.error {
      background: #ffe3e3;
      color: #c92a2a;
    }

    /* Profile Form Actions */
    .profile-form-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #eee;
    }

    .btn-save {
      background: #4a6cf7;
      color: #fff;
    }

    .btn-save:hover {
      background: #3a5ce5;
    }

    .btn-cancel {
      background: #f5f5f5;
      color: #666;
    }

    .btn-cancel:hover {
      background: #e0e0e0;
    }

    /* =============================================
       PACKET PREVIEW MODAL
       ============================================= */
    .packet-modal {
      max-width: 900px;
    }

    .packet-modal .modal-header {
      background: #1a1a2e;
      color: #fff;
      border-radius: 12px 12px 0 0;
    }

    .packet-modal .modal-header h2 {
      color: #fff;
    }

    .packet-modal .modal-close {
      color: #ccc;
    }

    .packet-modal .modal-close:hover {
      color: #fff;
    }

    .packet-actions {
      display: flex;
      gap: 0.5rem;
      padding: 1rem 1.5rem;
      background: #f8f9fa;
      border-bottom: 1px solid #eee;
    }

    .btn-print {
      background: #4a6cf7;
      color: #fff;
    }

    .btn-print:hover {
      background: #3a5ce5;
    }

    .btn-download {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .btn-download:hover {
      background: #c8e6c9;
    }

    .packet-preview-container {
      padding: 1.5rem;
      max-height: 70vh;
      overflow-y: auto;
      background: #f5f5f5;
    }

    .packet-preview {
      background: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      max-width: 8.5in;
      margin: 0 auto;
    }

    /* =============================================
       PACKET CONTENT STYLES (Screen)
       ============================================= */
    .dd-packet {
      font-family: 'Georgia', 'Times New Roman', serif;
      color: #333;
      line-height: 1.5;
      font-size: 11pt;
    }

    .dd-packet * {
      box-sizing: border-box;
    }

    .dd-cover {
      padding: 2in 1in 1in 1in;
      text-align: center;
      min-height: 10in;
      display: flex;
      flex-direction: column;
      justify-content: center;
      border-bottom: 3px solid #1a1a2e;
    }

    .dd-cover-logo {
      font-size: 14pt;
      font-weight: 600;
      letter-spacing: 2px;
      color: #1a1a2e;
      margin-bottom: 0.5in;
      text-transform: uppercase;
    }

    .dd-cover-title {
      font-size: 28pt;
      font-weight: 700;
      color: #1a1a2e;
      margin-bottom: 0.3in;
      line-height: 1.2;
    }

    .dd-cover-subtitle {
      font-size: 18pt;
      color: #4a6cf7;
      margin-bottom: 0.5in;
      font-style: italic;
    }

    .dd-cover-practice {
      font-size: 24pt;
      font-weight: 600;
      color: #333;
      margin-bottom: 1in;
      padding: 0.3in 0;
      border-top: 1px solid #ddd;
      border-bottom: 1px solid #ddd;
    }

    .dd-cover-date {
      font-size: 12pt;
      color: #666;
    }

    .dd-cover-confidential {
      margin-top: 1in;
      font-size: 10pt;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .dd-page {
      padding: 0.75in 1in;
      min-height: 10in;
    }

    .dd-page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 0.2in;
      border-bottom: 2px solid #1a1a2e;
      margin-bottom: 0.4in;
    }

    .dd-page-header-logo {
      font-size: 10pt;
      font-weight: 600;
      color: #1a1a2e;
      letter-spacing: 1px;
    }

    .dd-page-header-title {
      font-size: 10pt;
      color: #666;
    }

    .dd-section {
      margin-bottom: 0.4in;
    }

    .dd-section-title {
      font-size: 14pt;
      font-weight: 700;
      color: #1a1a2e;
      margin-bottom: 0.15in;
      padding-bottom: 0.08in;
      border-bottom: 1px solid #ddd;
    }

    .dd-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 0.2in;
    }

    .dd-table th,
    .dd-table td {
      padding: 0.12in 0.15in;
      text-align: left;
      border: 1px solid #ddd;
      font-size: 10pt;
    }

    .dd-table th {
      background: #f5f7fa;
      font-weight: 600;
      color: #1a1a2e;
      width: 35%;
    }

    .dd-table td {
      color: #333;
    }

    .dd-status-badge {
      display: inline-block;
      padding: 0.04in 0.15in;
      border-radius: 3px;
      font-size: 9pt;
      font-weight: 600;
    }

    .dd-status-lead {
      background: #fff3e0;
      color: #e65100;
    }

    .dd-status-onboarding {
      background: #e3f2fd;
      color: #1565c0;
    }

    .dd-status-active {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .dd-pipeline-box {
      background: #f8f9fa;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.2in;
      margin-bottom: 0.15in;
    }

    .dd-pipeline-stage {
      font-size: 11pt;
      margin-bottom: 0.1in;
    }

    .dd-pipeline-stage strong {
      color: #1a1a2e;
    }

    .dd-pipeline-recommendation {
      font-size: 10pt;
      color: #666;
      font-style: italic;
    }

    .dd-metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.15in;
    }

    .dd-metric-card {
      background: #f8f9fa;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.15in;
      text-align: center;
    }

    .dd-metric-label {
      font-size: 9pt;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .dd-metric-value {
      font-size: 18pt;
      font-weight: 700;
      color: #2e7d32;
    }

    .dd-timeline {
      border-left: 2px solid #4a6cf7;
      padding-left: 0.25in;
      margin-left: 0.1in;
    }

    .dd-timeline-item {
      margin-bottom: 0.15in;
      position: relative;
    }

    .dd-timeline-item::before {
      content: '';
      position: absolute;
      left: -0.31in;
      top: 0.06in;
      width: 0.1in;
      height: 0.1in;
      background: #4a6cf7;
      border-radius: 50%;
    }

    .dd-timeline-date {
      font-size: 9pt;
      color: #888;
    }

    .dd-timeline-action {
      font-size: 10pt;
      color: #333;
    }

    .dd-flags {
      margin-bottom: 0.2in;
    }

    .dd-flag {
      display: flex;
      align-items: flex-start;
      gap: 0.1in;
      padding: 0.1in 0.15in;
      margin-bottom: 0.08in;
      border-radius: 4px;
      font-size: 10pt;
    }

    .dd-flag-warning {
      background: #fff3e0;
      border-left: 3px solid #e65100;
      color: #bf360c;
    }

    .dd-flag-success {
      background: #e8f5e9;
      border-left: 3px solid #2e7d32;
      color: #1b5e20;
    }

    .dd-flag-icon {
      font-weight: bold;
    }

    .dd-checklist {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .dd-checklist li {
      display: flex;
      align-items: flex-start;
      gap: 0.1in;
      padding: 0.08in 0;
      font-size: 10pt;
      border-bottom: 1px solid #eee;
    }

    .dd-checklist li:last-child {
      border-bottom: none;
    }

    .dd-checkbox {
      width: 0.15in;
      height: 0.15in;
      border: 1px solid #999;
      border-radius: 2px;
      flex-shrink: 0;
      margin-top: 0.02in;
    }

    .dd-page-footer {
      margin-top: 0.5in;
      padding-top: 0.15in;
      border-top: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      font-size: 9pt;
      color: #888;
    }

    .page-break {
      page-break-before: always;
    }

    /* =============================================
       PRINT STYLES
       ============================================= */
    @media print {
      /* Hide app UI */
      body > .container,
      .modal-overlay:not(.packet-visible),
      .packet-actions,
      .packet-modal .modal-header {
        display: none !important;
      }

      body {
        padding: 0;
        margin: 0;
        background: white;
      }

      .modal-overlay.packet-visible {
        display: block !important;
        position: static;
        background: none;
        padding: 0;
        overflow: visible;
      }

      .packet-modal {
        box-shadow: none;
        border-radius: 0;
        max-width: none;
        width: 100%;
      }

      .packet-preview-container {
        padding: 0;
        max-height: none;
        overflow: visible;
        background: white;
      }

      .packet-preview {
        box-shadow: none;
        max-width: none;
      }

      .dd-packet {
        font-size: 10pt;
      }

      .dd-cover {
        min-height: auto;
        height: 100vh;
        padding: 1.5in 0.75in 0.75in 0.75in;
      }

      .dd-page {
        padding: 0.5in 0.75in;
        min-height: auto;
      }

      .page-break {
        page-break-before: always;
        break-before: page;
      }

      @page {
        margin: 0.5in;
        size: letter;
      }
    }

    /* Data Source Banner */
    .data-source-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 0.5rem 1rem;
      font-size: 0.75rem;
      text-align: center;
      z-index: 100;
      font-weight: 500;
    }

    .data-source-banner.supabase {
      background: #e8f5e9;
      color: #2e7d32;
      border-top: 1px solid #a5d6a7;
    }

    .data-source-banner.local {
      background: #fff3e0;
      color: #e65100;
      border-top: 1px solid #ffcc80;
    }

    .data-source-banner.error {
      background: #ffebee;
      color: #c62828;
      border-top: 1px solid #ef9a9a;
    }

    /* =============================================
       AUTH / LOGIN STYLES
       ============================================= */
    .login-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      margin: -2rem;
      padding: 2rem;
    }

    .login-card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
      padding: 2.5rem;
      width: 100%;
      max-width: 400px;
    }

    .login-logo {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .login-logo h1 {
      font-size: 1.75rem;
      font-weight: 700;
      color: #1a1a2e;
      margin-bottom: 0.25rem;
    }

    .login-logo p {
      font-size: 0.9rem;
      color: #666;
    }

    .login-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .login-form .form-group {
      display: flex;
      flex-direction: column;
    }

    .login-form .form-group label {
      font-size: 0.85rem;
      font-weight: 500;
      color: #555;
      margin-bottom: 0.35rem;
    }

    .login-form .form-group input {
      padding: 0.75rem 1rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .login-form .form-group input:focus {
      outline: none;
      border-color: #4a6cf7;
      box-shadow: 0 0 0 3px rgba(74, 108, 247, 0.1);
    }

    .login-form .btn-login {
      padding: 0.85rem 1.5rem;
      background: #4a6cf7;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
      margin-top: 0.5rem;
    }

    .login-form .btn-login:hover {
      background: #3a5ce5;
    }

    .login-form .btn-login:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }

    .login-error {
      background: #fee2e2;
      color: #dc2626;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      font-size: 0.85rem;
      display: none;
    }

    .login-error.visible {
      display: block;
    }

    .login-toggle {
      text-align: center;
      margin-top: 1.25rem;
      font-size: 0.85rem;
      color: #666;
    }

    .login-toggle a {
      color: #4a6cf7;
      text-decoration: none;
      font-weight: 500;
      cursor: pointer;
    }

    .login-toggle a:hover {
      text-decoration: underline;
    }

    /* User indicator in header */
    .user-indicator {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      background: #f3f4f6;
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      font-size: 0.8rem;
    }

    .user-indicator .user-email {
      color: #4b5563;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .user-indicator .btn-logout {
      padding: 0.3rem 0.6rem;
      background: #e5e7eb;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.75rem;
      color: #374151;
      cursor: pointer;
      transition: background 0.2s;
    }

    .user-indicator .btn-logout:hover {
      background: #d1d5db;
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    /* Hide app when not authenticated */
    .app-container {
      display: none;
    }

    .app-container.authenticated {
      display: block;
    }

    /* Awaiting Approval Screen */
    .awaiting-approval-screen {
      min-height: 100vh;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      margin: -2rem;
      padding: 2rem;
    }

    .awaiting-approval-screen.visible {
      display: flex;
    }

    .approval-card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
      padding: 2.5rem;
      width: 100%;
      max-width: 450px;
      text-align: center;
    }

    .approval-card .approval-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .approval-card h2 {
      font-size: 1.5rem;
      color: #1a1a2e;
      margin-bottom: 0.5rem;
    }

    .approval-card p {
      color: #666;
      font-size: 0.95rem;
      margin-bottom: 1.5rem;
    }

    .approval-card .user-email {
      background: #f3f4f6;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-family: monospace;
      font-size: 0.9rem;
      color: #374151;
      margin-bottom: 1.5rem;
      display: inline-block;
    }

    .approval-card .btn-logout-approval {
      padding: 0.6rem 1.25rem;
      background: #e5e7eb;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.9rem;
      color: #374151;
      cursor: pointer;
    }

    .approval-card .btn-logout-approval:hover {
      background: #d1d5db;
    }

    /* No Org Membership Screen */
    .no-org-screen {
      min-height: 100vh;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
      margin: -2rem;
      padding: 2rem;
    }

    .no-org-screen.visible {
      display: flex;
    }

    .no-org-card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
      padding: 2.5rem;
      width: 100%;
      max-width: 450px;
      text-align: center;
    }

    .no-org-card .error-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .no-org-card h2 {
      font-size: 1.5rem;
      color: #991b1b;
      margin-bottom: 0.5rem;
    }

    .no-org-card p {
      color: #666;
      font-size: 0.95rem;
      margin-bottom: 1.5rem;
    }

    /* Admin Panel */
    .admin-panel {
      background: #fef3c7;
      border: 1px solid #f59e0b;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
    }

    .admin-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .admin-panel-header h3 {
      font-size: 0.9rem;
      font-weight: 600;
      color: #92400e;
      margin: 0;
    }

    .admin-panel-header .badge-admin {
      background: #f59e0b;
      color: #fff;
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .allowlist-form {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .allowlist-form input {
      flex: 1;
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    .allowlist-form select {
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    .allowlist-form button {
      padding: 0.5rem 1rem;
      background: #f59e0b;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .allowlist-form button:hover {
      background: #d97706;
    }

    .allowlist-table {
      width: 100%;
      font-size: 0.8rem;
      border-collapse: collapse;
    }

    .allowlist-table th,
    .allowlist-table td {
      padding: 0.5rem;
      text-align: left;
      border-bottom: 1px solid #fcd34d;
    }

    .allowlist-table th {
      color: #92400e;
      font-weight: 600;
    }

    .allowlist-table .btn-toggle,
    .allowlist-table .btn-delete {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      border-radius: 3px;
      cursor: pointer;
      border: none;
      margin-right: 0.25rem;
    }

    .allowlist-table .btn-toggle {
      background: #d1d5db;
      color: #374151;
    }

    .allowlist-table .btn-toggle.active {
      background: #10b981;
      color: #fff;
    }

    .allowlist-table .btn-delete {
      background: #fee2e2;
      color: #dc2626;
    }

    .allowlist-table .btn-delete:hover {
      background: #fecaca;
    }

    /* Settings Button */
    .settings-btn {
      background: transparent;
      border: none;
      padding: 0.5rem;
      cursor: pointer;
      color: #64748b;
      border-radius: 8px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .settings-btn:hover {
      background: #f1f5f9;
      color: #334155;
    }

    /* Settings Panel Overlay */
    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .settings-panel {
      background: #fff;
      border-radius: 16px;
      width: 100%;
      max-width: 1200px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem 2rem;
      border-bottom: 1px solid #e5e7eb;
    }

    .settings-header h2 {
      margin: 0;
      font-size: 1.5rem;
      color: #1e293b;
    }

    .settings-close {
      background: none;
      border: none;
      font-size: 2rem;
      color: #64748b;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      transition: color 0.2s;
    }

    .settings-close:hover {
      color: #ef4444;
    }

    .settings-tabs {
      display: flex;
      gap: 0.5rem;
      padding: 1rem 2rem;
      border-bottom: 1px solid #e5e7eb;
      background: #f8fafc;
    }

    .settings-tab {
      padding: 0.75rem 1.5rem;
      border: none;
      background: transparent;
      color: #64748b;
      font-size: 0.95rem;
      font-weight: 500;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .settings-tab:hover {
      background: #e2e8f0;
      color: #334155;
    }

    .settings-tab.active {
      background: #3b82f6;
      color: white;
    }

    .settings-content {
      display: none;
      padding: 1.5rem 2rem;
      overflow-y: auto;
      flex: 1;
    }

    .settings-content.active {
      display: block;
    }

    .settings-placeholder {
      text-align: center;
      padding: 4rem 2rem;
      color: #64748b;
    }

    .settings-placeholder h3 {
      margin: 0 0 0.5rem 0;
      color: #334155;
    }

    /* Audit Log Styles */
    .audit-filters {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
      align-items: flex-end;
    }

    .audit-filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .audit-filter-group label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #64748b;
      text-transform: uppercase;
    }

    .audit-filter-group select,
    .audit-filter-group input {
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.9rem;
      min-width: 150px;
    }

    .audit-filter-group select:focus,
    .audit-filter-group input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .audit-export-btn {
      padding: 0.5rem 1rem;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
      white-space: nowrap;
    }

    .audit-export-btn:hover {
      background: #059669;
    }

    .audit-table-container {
      overflow-x: auto;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    .audit-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .audit-table th {
      background: #f8fafc;
      padding: 0.75rem 1rem;
      text-align: left;
      font-weight: 600;
      color: #475569;
      border-bottom: 1px solid #e5e7eb;
      white-space: nowrap;
    }

    .audit-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #f1f5f9;
      color: #334155;
    }

    .audit-table tbody tr:hover {
      background: #f8fafc;
    }

    .audit-table tbody tr:last-child td {
      border-bottom: none;
    }

    .audit-empty {
      text-align: center;
      color: #94a3b8;
      padding: 3rem 1rem !important;
    }

    .audit-event-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.6rem;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .audit-event-badge.practice {
      background: #dbeafe;
      color: #1e40af;
    }

    .audit-event-badge.document {
      background: #fef3c7;
      color: #92400e;
    }

    .audit-event-badge.extraction {
      background: #d1fae5;
      color: #065f46;
    }

    .audit-event-badge.delete {
      background: #fee2e2;
      color: #991b1b;
    }

    .audit-actor {
      max-width: 180px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #64748b;
      font-size: 0.85rem;
    }

    .audit-details {
      max-width: 250px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #64748b;
      font-size: 0.85rem;
    }

    .audit-timestamp {
      white-space: nowrap;
      color: #64748b;
      font-size: 0.85rem;
    }

    .audit-practice {
      font-weight: 500;
      color: #1e293b;
    }

    .audit-pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      padding: 1rem 0;
    }

    .audit-page-btn {
      padding: 0.5rem 1rem;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      color: #334155;
      transition: all 0.2s;
    }

    .audit-page-btn:hover:not(:disabled) {
      background: #f1f5f9;
      border-color: #94a3b8;
    }

    .audit-page-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .audit-page-info {
      color: #64748b;
      font-size: 0.9rem;
    }

    /* Document Templates Styles */
    .templates-header {
      margin-bottom: 1.5rem;
    }

    .templates-header h3 {
      margin: 0 0 0.25rem 0;
      color: #1e293b;
    }

    .templates-description {
      color: #64748b;
      margin: 0 0 1rem 0;
      font-size: 0.9rem;
    }

    .btn-create-template {
      padding: 0.6rem 1.2rem;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn-create-template:hover {
      background: #2563eb;
    }

    .templates-list {
      display: grid;
      gap: 1rem;
    }

    .templates-loading {
      text-align: center;
      padding: 3rem;
      color: #64748b;
    }

    .templates-empty {
      text-align: center;
      padding: 3rem;
      color: #64748b;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px dashed #d1d5db;
    }

    .template-card {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      padding: 1.25rem;
      transition: box-shadow 0.2s;
    }

    .template-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }

    .template-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.75rem;
    }

    .template-card-title {
      font-weight: 600;
      font-size: 1.05rem;
      color: #1e293b;
      margin: 0;
    }

    .template-card-category {
      font-size: 0.75rem;
      padding: 0.25rem 0.6rem;
      background: #e0e7ff;
      color: #4338ca;
      border-radius: 12px;
      text-transform: capitalize;
    }

    .template-card-description {
      color: #64748b;
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
    }

    .template-card-items {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .template-item-tag {
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
      background: #f1f5f9;
      color: #475569;
      border-radius: 4px;
    }

    .template-card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 0.75rem;
      border-top: 1px solid #f1f5f9;
    }

    .template-card-meta {
      font-size: 0.8rem;
      color: #94a3b8;
    }

    .template-card-actions {
      display: flex;
      gap: 0.5rem;
    }

    .template-card-actions button {
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-edit-template {
      background: #f1f5f9;
      border: 1px solid #e2e8f0;
      color: #475569;
    }

    .btn-edit-template:hover {
      background: #e2e8f0;
    }

    .btn-delete-template {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #dc2626;
    }

    .btn-delete-template:hover {
      background: #fee2e2;
    }

    /* Template Modal */
    .template-modal {
      background: white;
      width: 600px;
      max-width: 95vw;
      max-height: 90vh;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .template-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.25rem 1.5rem;
      border-bottom: 1px solid #e5e7eb;
    }

    .template-modal-header h3 {
      margin: 0;
      color: #1e293b;
    }

    .template-modal-body {
      padding: 1.5rem;
      overflow-y: auto;
      flex: 1;
    }

    .template-form-group {
      margin-bottom: 1.25rem;
    }

    .template-form-group label {
      display: block;
      font-size: 0.85rem;
      font-weight: 600;
      color: #374151;
      margin-bottom: 0.5rem;
    }

    .template-form-group input,
    .template-form-group select {
      width: 100%;
      padding: 0.6rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.95rem;
    }

    .template-form-group input:focus,
    .template-form-group select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .template-items-section {
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 1rem;
      background: #f8fafc;
    }

    .template-items-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .template-items-header label {
      font-weight: 600;
      color: #374151;
      margin: 0;
    }

    .btn-add-item {
      padding: 0.4rem 0.8rem;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .btn-add-item:hover {
      background: #059669;
    }

    .template-items-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .template-item-row {
      display: grid;
      grid-template-columns: 1fr 150px 80px 40px;
      gap: 0.5rem;
      align-items: center;
      background: white;
      padding: 0.75rem;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }

    .template-item-row input,
    .template-item-row select {
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .template-item-row .required-toggle {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.8rem;
      color: #64748b;
    }

    .template-item-row .required-toggle input {
      width: auto;
    }

    .btn-remove-item {
      padding: 0.4rem;
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #dc2626;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
    }

    .btn-remove-item:hover {
      background: #fee2e2;
    }

    .template-items-empty {
      text-align: center;
      padding: 1.5rem;
      color: #94a3b8;
      font-size: 0.9rem;
    }

    .template-modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
      padding: 1rem 1.5rem;
      border-top: 1px solid #e5e7eb;
      background: #f8fafc;
    }

    .template-modal-footer .btn-cancel {
      padding: 0.6rem 1.2rem;
      background: white;
      border: 1px solid #d1d5db;
      color: #374151;
      border-radius: 6px;
      cursor: pointer;
    }

    .template-modal-footer .btn-cancel:hover {
      background: #f1f5f9;
    }

    .template-modal-footer .btn-save {
      padding: 0.6rem 1.2rem;
      background: #3b82f6;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    }

    .template-modal-footer .btn-save:hover {
      background: #2563eb;
    }

    /* Dashboard View */
    .dashboard-container {
      display: none;
    }

    .dashboard-container.visible {
      display: block;
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .dashboard-stat {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      padding: 1.25rem;
      text-align: center;
    }

    .dashboard-stat .stat-value {
      font-size: 2rem;
      font-weight: 700;
      line-height: 1.2;
    }

    .dashboard-stat .stat-label {
      font-size: 0.75rem;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 0.25rem;
    }

    .dashboard-stat.stat-green .stat-value { color: #059669; }
    .dashboard-stat.stat-yellow .stat-value { color: #d97706; }
    .dashboard-stat.stat-red .stat-value { color: #dc2626; }
    .dashboard-stat.stat-blue .stat-value { color: #2563eb; }

    .dashboard-sections {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
    }

    .dashboard-section {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      overflow: hidden;
    }

    .dashboard-section.full-width {
      grid-column: 1 / -1;
    }

    .dashboard-section-header {
      background: #f8f9fa;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .dashboard-section-header h3 {
      font-size: 0.9rem;
      font-weight: 600;
      color: #374151;
      margin: 0;
    }

    .dashboard-section-header .badge {
      font-size: 0.7rem;
      padding: 0.2rem 0.6rem;
      border-radius: 10px;
      font-weight: 600;
    }

    .dashboard-section-header .badge-red {
      background: #fee2e2;
      color: #dc2626;
    }

    .dashboard-section-header .badge-yellow {
      background: #fef3c7;
      color: #d97706;
    }

    .dashboard-section-body {
      padding: 0;
      max-height: 350px;
      overflow-y: auto;
    }

    .dashboard-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      transition: background 0.15s;
    }

    .dashboard-row:hover {
      background: #f9fafb;
    }

    .dashboard-row:last-child {
      border-bottom: none;
    }

    .dashboard-row-info {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }

    .dashboard-row-title {
      font-weight: 500;
      font-size: 0.9rem;
      color: #1f2937;
    }

    .dashboard-row-subtitle {
      font-size: 0.75rem;
      color: #6b7280;
    }

    .dashboard-row-right {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .dashboard-score {
      font-size: 0.85rem;
      font-weight: 600;
      padding: 0.25rem 0.6rem;
      border-radius: 6px;
    }

    .dashboard-score.score-high {
      background: #d1fae5;
      color: #059669;
    }

    .dashboard-score.score-medium {
      background: #fef3c7;
      color: #d97706;
    }

    .dashboard-score.score-low {
      background: #fee2e2;
      color: #dc2626;
    }

    .dashboard-expiry-badge {
      font-size: 0.75rem;
      font-weight: 500;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
    }

    .dashboard-expiry-badge.expired {
      background: #fee2e2;
      color: #dc2626;
    }

    .dashboard-expiry-badge.expiring {
      background: #fef3c7;
      color: #d97706;
    }

    .dashboard-empty {
      padding: 2rem;
      text-align: center;
      color: #9ca3af;
      font-size: 0.9rem;
    }

    .dashboard-readiness-table {
      width: 100%;
    }

    .dashboard-readiness-row {
      display: grid;
      grid-template-columns: 2fr 80px 1fr 60px;
      gap: 0.75rem;
      padding: 0.6rem 1rem;
      border-bottom: 1px solid #f3f4f6;
      align-items: center;
      cursor: pointer;
      transition: background 0.15s;
    }

    .dashboard-readiness-row:hover {
      background: #f9fafb;
    }

    .dashboard-readiness-row:last-child {
      border-bottom: none;
    }

    .readiness-bar-container {
      background: #e5e7eb;
      border-radius: 4px;
      height: 8px;
      overflow: hidden;
    }

    .readiness-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s;
    }

    .readiness-bar-fill.bar-high { background: #059669; }
    .readiness-bar-fill.bar-medium { background: #f59e0b; }
    .readiness-bar-fill.bar-low { background: #dc2626; }

    /* Notification System */
    .header-actions {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .notification-bell {
      position: relative;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 6px;
      transition: background 0.2s;
    }

    .notification-bell:hover {
      background: #f3f4f6;
    }

    .bell-icon {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .bell-icon svg {
      width: 18px;
      height: 18px;
      fill: none;
      stroke: #4b5563;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .notification-bell:hover .bell-icon svg {
      stroke: #1f2937;
    }

    .notification-badge {
      position: absolute;
      top: 0;
      right: 0;
      background: #dc2626;
      color: #fff;
      font-size: 0.65rem;
      font-weight: 600;
      min-width: 18px;
      height: 18px;
      border-radius: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 4px;
    }

    .notification-center {
      position: absolute;
      top: 100%;
      right: 0;
      width: 400px;
      max-height: 500px;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.15);
      z-index: 1000;
      overflow: hidden;
    }

    .notification-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f8f9fa;
      border-bottom: 1px solid #e5e7eb;
    }

    .notification-header h4 {
      margin: 0;
      font-size: 0.9rem;
      font-weight: 600;
      color: #1f2937;
    }

    .notification-actions {
      display: flex;
      gap: 0.5rem;
    }

    .notification-actions button {
      padding: 0.35rem 0.6rem;
      font-size: 0.7rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }

    .btn-slack {
      background: #4a154b;
      color: #fff;
    }

    .btn-slack:hover {
      background: #611f69;
    }

    .btn-email-digest {
      background: #e5e7eb;
      color: #374151;
    }

    .btn-email-digest:hover {
      background: #d1d5db;
    }

    .notification-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .notification-item {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      transition: background 0.15s;
    }

    .notification-item:hover {
      background: #f9fafb;
    }

    .notification-item:last-child {
      border-bottom: none;
    }

    .notification-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      flex-shrink: 0;
    }

    .notification-icon.icon-expired {
      background: #fee2e2;
    }

    .notification-icon.icon-expiring {
      background: #fef3c7;
    }

    .notification-icon.icon-missing {
      background: #dbeafe;
    }

    .notification-content {
      flex: 1;
      min-width: 0;
    }

    .notification-title {
      font-size: 0.85rem;
      font-weight: 500;
      color: #1f2937;
      margin-bottom: 0.15rem;
    }

    .notification-subtitle {
      font-size: 0.75rem;
      color: #6b7280;
    }

    .notification-time {
      font-size: 0.7rem;
      color: #9ca3af;
      white-space: nowrap;
    }

    .notification-empty {
      padding: 2rem;
      text-align: center;
      color: #9ca3af;
    }

    .notification-empty-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    /* Slack Settings Modal */
    .slack-settings-content {
      padding: 1.5rem;
    }

    .slack-settings-content label {
      display: block;
      font-size: 0.85rem;
      font-weight: 500;
      color: #374151;
      margin-bottom: 0.5rem;
    }

    .slack-settings-content input {
      width: 100%;
      padding: 0.6rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }

    .slack-settings-content input:focus {
      outline: none;
      border-color: #4a154b;
    }

    .slack-test-result {
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.85rem;
      margin-bottom: 1rem;
    }

    .slack-test-result.success {
      background: #d1fae5;
      color: #059669;
    }

    .slack-test-result.error {
      background: #fee2e2;
      color: #dc2626;
    }

    .slack-actions {
      display: flex;
      gap: 0.75rem;
    }

    .slack-actions button {
      flex: 1;
      padding: 0.6rem;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
    }

    .btn-test-slack {
      background: #e5e7eb;
      color: #374151;
    }

    .btn-save-slack {
      background: #4a154b;
      color: #fff;
    }

    .btn-send-slack-now {
      background: #059669;
      color: #fff;
    }

    /* Email Digest Modal */
    .email-digest-content {
      padding: 1.5rem;
    }

    .email-digest-preview {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 1rem;
      font-family: monospace;
      font-size: 0.8rem;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 1rem;
    }

    .email-digest-actions {
      display: flex;
      gap: 0.75rem;
    }

    .email-digest-actions button {
      flex: 1;
      padding: 0.6rem;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
    }

    .btn-copy-email {
      background: #4a6cf7;
      color: #fff;
    }

    .btn-open-mailto {
      background: #059669;
      color: #fff;
    }

    /* Global Document Search */
    .global-search-container {
      position: relative;
    }

    .global-search-input-wrapper {
      display: flex;
      align-items: center;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 0.4rem 0.75rem;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .global-search-input-wrapper:focus-within {
      border-color: #4a6cf7;
      box-shadow: 0 0 0 3px rgba(74, 108, 247, 0.1);
      background: #fff;
    }

    .global-search-input-wrapper .search-icon {
      width: 16px;
      height: 16px;
      stroke: #9ca3af;
      stroke-width: 2;
      fill: none;
      margin-right: 0.5rem;
      flex-shrink: 0;
    }

    .global-search-input {
      border: none;
      background: transparent;
      font-size: 0.85rem;
      width: 200px;
      outline: none;
      color: #1f2937;
    }

    .global-search-input::placeholder {
      color: #9ca3af;
    }

    .search-shortcut {
      font-size: 0.65rem;
      color: #9ca3af;
      background: #e5e7eb;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      margin-left: 0.5rem;
      white-space: nowrap;
    }

    .global-search-results {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      width: 400px;
      max-height: 450px;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.15);
      z-index: 1001;
      overflow: hidden;
    }

    .search-results-header {
      padding: 0.6rem 1rem;
      background: #f8f9fa;
      border-bottom: 1px solid #e5e7eb;
      font-size: 0.75rem;
      color: #6b7280;
      font-weight: 500;
    }

    .search-results-list {
      max-height: 380px;
      overflow-y: auto;
    }

    .search-result-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      transition: background 0.15s;
    }

    .search-result-item:hover,
    .search-result-item.selected {
      background: #f3f4f6;
    }

    .search-result-item:last-child {
      border-bottom: none;
    }

    .search-result-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      flex-shrink: 0;
    }

    .search-result-icon.icon-financial {
      background: #d1fae5;
    }

    .search-result-icon.icon-dd {
      background: #dbeafe;
    }

    .search-result-content {
      flex: 1;
      min-width: 0;
    }

    .search-result-title {
      font-size: 0.85rem;
      font-weight: 500;
      color: #1f2937;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .search-result-title mark {
      background: #fef08a;
      color: inherit;
      padding: 0 2px;
      border-radius: 2px;
    }

    .search-result-meta {
      font-size: 0.75rem;
      color: #6b7280;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .search-result-tag {
      font-size: 0.65rem;
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
      background: #e5e7eb;
      color: #4b5563;
    }

    .search-result-tag.tag-financial {
      background: #d1fae5;
      color: #059669;
    }

    .search-result-tag.tag-dd {
      background: #dbeafe;
      color: #2563eb;
    }

    .search-no-results {
      padding: 2rem;
      text-align: center;
      color: #9ca3af;
    }

    .search-no-results-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .search-loading {
      padding: 1.5rem;
      text-align: center;
      color: #6b7280;
      font-size: 0.85rem;
    }

    /* Export Toolbar */
    .export-toolbar {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      padding: 0.75rem 1rem;
      background: #f8f9fa;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
    }

    .export-label {
      font-size: 0.8rem;
      font-weight: 500;
      color: #6b7280;
      margin-right: 0.5rem;
    }

    .export-btn {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
      font-weight: 500;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: #fff;
      color: #374151;
      cursor: pointer;
      transition: all 0.15s;
    }

    .export-btn:hover {
      background: #f3f4f6;
      border-color: #9ca3af;
    }

    .export-btn svg {
      flex-shrink: 0;
    }

    .export-btn-primary {
      background: #4a6cf7;
      color: #fff;
      border-color: #4a6cf7;
    }

    .export-btn-primary:hover {
      background: #3b5ce5;
      border-color: #3b5ce5;
    }

    /* PDF Report Styles (for print) */
    @media print {
      body * {
        visibility: hidden;
      }
      .print-report, .print-report * {
        visibility: visible;
      }
      .print-report {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
      }
    }

    .print-report {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: #fff;
    }

    .print-report h1 {
      font-size: 1.5rem;
      color: #1a1a2e;
      margin-bottom: 0.5rem;
    }

    .print-report .report-subtitle {
      color: #6b7280;
      font-size: 0.9rem;
      margin-bottom: 2rem;
    }

    .print-report .report-section {
      margin-bottom: 2rem;
    }

    .print-report .report-section h2 {
      font-size: 1rem;
      color: #374151;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
    }

    .print-report table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    .print-report th, .print-report td {
      padding: 0.5rem;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }

    .print-report th {
      background: #f8f9fa;
      font-weight: 600;
      color: #374151;
    }

    .print-report .score-cell {
      font-weight: 600;
    }

    .print-report .score-high { color: #059669; }
    .print-report .score-medium { color: #d97706; }
    .print-report .score-low { color: #dc2626; }

    .print-report .summary-stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .print-report .summary-stat {
      text-align: center;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 8px;
    }

    .print-report .summary-stat .value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #1a1a2e;
    }

    .print-report .summary-stat .label {
      font-size: 0.75rem;
      color: #6b7280;
      text-transform: uppercase;
    }

    /* Document Request Workflow */
    .btn-request-docs {
      padding: 0.4rem 0.75rem;
      font-size: 0.75rem;
      background: #8b5cf6;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
    }

    .btn-request-docs:hover {
      background: #7c3aed;
    }

    .pending-requests-section {
      background: #faf5ff;
      border: 1px solid #e9d5ff;
      border-radius: 8px;
      margin: 1rem 0;
      overflow: hidden;
    }

    .pending-requests-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #f3e8ff;
      border-bottom: 1px solid #e9d5ff;
    }

    .pending-requests-title {
      font-weight: 600;
      font-size: 0.85rem;
      color: #6b21a8;
    }

    .pending-requests-count {
      background: #8b5cf6;
      color: #fff;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 0.2rem 0.5rem;
      border-radius: 10px;
    }

    .pending-requests-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .request-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #f3e8ff;
      transition: background 0.15s;
    }

    .request-item:last-child {
      border-bottom: none;
    }

    .request-item:hover {
      background: #faf5ff;
    }

    .request-status-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      flex-shrink: 0;
    }

    .request-status-icon.status-requested {
      background: #fef3c7;
    }

    .request-status-icon.status-received {
      background: #dbeafe;
    }

    .request-status-icon.status-reviewed {
      background: #d1fae5;
    }

    .request-info {
      flex: 1;
      min-width: 0;
    }

    .request-doc-type {
      font-weight: 500;
      font-size: 0.85rem;
      color: #1f2937;
    }

    .request-meta {
      font-size: 0.75rem;
      color: #6b7280;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .request-status-badge {
      font-size: 0.65rem;
      font-weight: 600;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .request-status-badge.status-requested {
      background: #fef3c7;
      color: #d97706;
    }

    .request-status-badge.status-received {
      background: #dbeafe;
      color: #2563eb;
    }

    .request-status-badge.status-reviewed {
      background: #d1fae5;
      color: #059669;
    }

    .request-actions {
      display: flex;
      gap: 0.4rem;
    }

    .request-actions button {
      padding: 0.3rem 0.5rem;
      font-size: 0.7rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.15s;
    }

    .btn-mark-received {
      background: #dbeafe;
      color: #2563eb;
    }

    .btn-mark-received:hover {
      background: #bfdbfe;
    }

    .btn-mark-reviewed {
      background: #d1fae5;
      color: #059669;
    }

    .btn-mark-reviewed:hover {
      background: #a7f3d0;
    }

    .btn-cancel-request {
      background: #fee2e2;
      color: #dc2626;
    }

    .btn-cancel-request:hover {
      background: #fecaca;
    }

    /* Request Modal Styles */
    .request-modal-content {
      padding: 1.5rem;
    }

    .request-category-select {
      margin-bottom: 1rem;
    }

    .request-category-select label {
      display: block;
      font-size: 0.85rem;
      font-weight: 500;
      color: #374151;
      margin-bottom: 0.4rem;
    }

    .request-category-select select {
      width: 100%;
      padding: 0.6rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.9rem;
    }

    .request-doc-types {
      margin-bottom: 1rem;
    }

    .request-doc-types label {
      display: block;
      font-size: 0.85rem;
      font-weight: 500;
      color: #374151;
      margin-bottom: 0.5rem;
    }

    .request-doc-type-list {
      max-height: 250px;
      overflow-y: auto;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
    }

    .request-doc-type-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.6rem 0.75rem;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      transition: background 0.15s;
    }

    .request-doc-type-item:last-child {
      border-bottom: none;
    }

    .request-doc-type-item:hover {
      background: #f9fafb;
    }

    .request-doc-type-item input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .request-doc-type-item .doc-type-label {
      font-size: 0.85rem;
      color: #374151;
    }

    .request-notes {
      margin-bottom: 1rem;
    }

    .request-notes label {
      display: block;
      font-size: 0.85rem;
      font-weight: 500;
      color: #374151;
      margin-bottom: 0.4rem;
    }

    .request-notes textarea {
      width: 100%;
      padding: 0.6rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.85rem;
      resize: vertical;
      min-height: 80px;
    }

    .request-modal-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
    }

    .request-modal-actions button {
      padding: 0.6rem 1.25rem;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
    }

    .btn-cancel-modal {
      background: #e5e7eb;
      color: #374151;
    }

    .btn-send-requests {
      background: #8b5cf6;
      color: #fff;
    }

    .btn-send-requests:hover {
      background: #7c3aed;
    }

    .no-pending-requests {
      padding: 1.5rem;
      text-align: center;
      color: #9ca3af;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <!-- Loading Screen (shown while checking auth) -->
  <div id="auth-loading-screen" class="login-screen" style="display: none;">
    <div class="login-card">
      <div class="login-logo">
        <h1>Zenyte Holdings</h1>
        <p>Loading...</p>
      </div>
    </div>
  </div>

  <!-- Login Screen (shown when not authenticated) -->
  <div id="login-screen" class="login-screen" style="display: none;">
    <div class="login-card">
      <div class="login-logo">
        <h1>Zenyte Holdings</h1>
        <p>ERP Intake Dashboard</p>
      </div>
      <div id="login-error" class="login-error"></div>
      <form id="login-form" class="login-form">
        <div class="form-group">
          <label for="login-email">Email</label>
          <input type="email" id="login-email" required placeholder="you@company.com">
        </div>
        <div class="form-group">
          <label for="login-password">Password</label>
          <input type="password" id="login-password" required placeholder="Enter your password">
        </div>
        <button type="submit" id="login-btn" class="btn-login">Sign In</button>
      </form>
      <div id="login-toggle" class="login-toggle">
        Don't have an account? <a onclick="toggleAuthMode()">Sign Up</a>
      </div>
    </div>
  </div>

  <!-- Immediately decide which screen to show based on stored session -->
  <script>
    (function() {
      var storedSession = localStorage.getItem('zenyte-auth');
      if (storedSession) {
        try {
          var session = JSON.parse(storedSession);
          if (session && session.access_token) {
            // Session exists - show loading screen while we verify
            document.getElementById('auth-loading-screen').style.display = 'flex';
            return;
          }
        } catch (e) {}
      }
      // No valid session - show login screen
      document.getElementById('login-screen').style.display = 'flex';
    })();
  </script>

  <!-- Awaiting Approval Screen (shown when authenticated but not allowlisted) -->
  <div id="awaiting-approval-screen" class="awaiting-approval-screen">
    <div class="approval-card">
      <div class="approval-icon"></div>
      <h2>Awaiting Approval</h2>
      <p>Your account has been created but is pending administrator approval to access the ERP system.</p>
      <div class="user-email" id="approval-user-email"></div>
      <p style="font-size: 0.85rem; color: #888;">Please contact your administrator for access.</p>
      <button class="btn-logout-approval" onclick="handleLogout()">Sign Out</button>
    </div>
  </div>

  <!-- No Org Membership Screen -->
  <div id="no-org-screen" class="no-org-screen">
    <div class="no-org-card">
      <div class="error-icon"></div>
      <h2>No Organization Found</h2>
      <p>Your account is not associated with any organization. Please contact your administrator to be added to an organization.</p>
      <div class="user-email" id="no-org-user-email"></div>
      <button class="btn-logout-approval" onclick="handleLogout()">Sign Out</button>
    </div>
  </div>

  <!-- Main App (hidden until authenticated) -->
  <div id="app-container" class="app-container">
    <div class="container">
      <header>
        <div class="header-row">
          <div>
            <h1>Zenyte Holdings</h1>
            <p>ERP Intake Dashboard</p>
          </div>
          <div class="header-actions">
            <div class="global-search-container">
              <div class="global-search-input-wrapper">
                <svg class="search-icon" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path></svg>
                <input type="text" id="global-search-input" class="global-search-input" placeholder="Search documents..." oninput="handleGlobalSearch(this.value)" onfocus="showSearchResults()" onkeydown="handleSearchKeydown(event)">
                <span class="search-shortcut">Ctrl+K</span>
              </div>
              <div class="global-search-results" id="global-search-results" style="display: none;">
                <!-- Populated by JS -->
              </div>
            </div>
            <div class="notification-bell" onclick="toggleNotificationCenter()">
              <span class="bell-icon"><svg viewBox="0 0 24 24"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg></span>
              <span class="notification-badge" id="notification-badge" style="display: none;">0</span>
            </div>
            <button class="settings-btn" id="settings-btn" onclick="openSettings()" title="Settings (Admin)" style="display: none;">
              <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
              </svg>
            </button>
            <div id="user-indicator" class="user-indicator">
              <span class="user-email" id="user-email"></span>
              <button class="btn-logout" onclick="handleLogout()">Logout</button>
            </div>
          </div>
        </div>
        <div class="notification-center" id="notification-center" style="display: none;">
          <div class="notification-header">
            <h4>Notifications</h4>
            <div class="notification-actions">
              <button class="btn-slack" onclick="openSlackSettings()">Slack Settings</button>
              <button class="btn-email-digest" onclick="generateEmailDigest()">Email Digest</button>
            </div>
          </div>
          <div class="notification-list" id="notification-list">
            <!-- Populated by JS -->
          </div>
        </div>
      </header>

    <!-- Settings Panel (full-screen overlay) -->
    <div class="settings-overlay" id="settings-overlay" style="display: none;">
      <div class="settings-panel">
        <div class="settings-header">
          <h2>Account Settings</h2>
          <button class="settings-close" onclick="closeSettings()">&times;</button>
        </div>

        <!-- Settings Tabs -->
        <div class="settings-tabs">
          <button class="settings-tab active" data-tab="audit-log" onclick="switchSettingsTab('audit-log')">Audit Log</button>
          <button class="settings-tab" data-tab="preferences" onclick="switchSettingsTab('preferences')">Preferences</button>
          <button class="settings-tab" data-tab="team" onclick="switchSettingsTab('team')">Team</button>
          <button class="settings-tab" data-tab="templates" onclick="switchSettingsTab('templates')">Document Templates</button>
        </div>

        <!-- Audit Log Tab Content -->
        <div class="settings-content active" id="settings-audit-log">
          <div class="audit-filters">
            <div class="audit-filter-group">
              <label>Event Type</label>
              <select id="audit-filter-type" onchange="applyAuditFilters()">
                <option value="">All Events</option>
                <optgroup label="Practice Events">
                  <option value="practice_created">Practice Created</option>
                  <option value="practice_edited">Practice Edited</option>
                  <option value="practice_deleted">Practice Deleted</option>
                  <option value="status_changed">Status Changed</option>
                  <option value="note_added">Note Added</option>
                  <option value="tag_added">Tag Added</option>
                  <option value="tag_removed">Tag Removed</option>
                  <option value="packet_generated">Packet Generated</option>
                </optgroup>
                <optgroup label="Document Events">
                  <option value="uploaded">Document Uploaded</option>
                  <option value="deleted">Document Deleted</option>
                  <option value="extraction_confirmed">Extraction Confirmed</option>
                  <option value="verified">Document Verified</option>
                  <option value="unverified">Document Unverified</option>
                </optgroup>
              </select>
            </div>
            <div class="audit-filter-group">
              <label>Practice</label>
              <select id="audit-filter-practice" onchange="applyAuditFilters()">
                <option value="">All Practices</option>
                <!-- Populated by JS -->
              </select>
            </div>
            <div class="audit-filter-group">
              <label>From</label>
              <input type="date" id="audit-filter-from" onchange="applyAuditFilters()">
            </div>
            <div class="audit-filter-group">
              <label>To</label>
              <input type="date" id="audit-filter-to" onchange="applyAuditFilters()">
            </div>
            <div class="audit-filter-group">
              <label>Search</label>
              <input type="text" id="audit-search" placeholder="Search events..." oninput="debounceAuditSearch()">
            </div>
            <button class="audit-export-btn" onclick="exportAuditLog()">Export CSV</button>
          </div>

          <div class="audit-table-container">
            <table class="audit-table">
              <thead>
                <tr>
                  <th>Timestamp</th>
                  <th>Practice</th>
                  <th>Event</th>
                  <th>Actor</th>
                  <th>Details</th>
                </tr>
              </thead>
              <tbody id="audit-tbody">
                <tr><td colspan="5" class="audit-empty">Loading events...</td></tr>
              </tbody>
            </table>
          </div>

          <div class="audit-pagination" id="audit-pagination">
            <button class="audit-page-btn" onclick="changeAuditPage(-1)" id="audit-prev-btn" disabled>&laquo; Previous</button>
            <span class="audit-page-info" id="audit-page-info">Page 1</span>
            <button class="audit-page-btn" onclick="changeAuditPage(1)" id="audit-next-btn" disabled>Next &raquo;</button>
          </div>
        </div>

        <!-- Preferences Tab Content -->
        <div class="settings-content" id="settings-preferences">
          <div class="settings-placeholder">
            <h3>Preferences</h3>
            <p>User preferences coming soon...</p>
          </div>
        </div>

        <!-- Team Tab Content -->
        <div class="settings-content" id="settings-team">
          <div class="settings-placeholder">
            <h3>Team Management</h3>
            <p>Team management coming soon...</p>
          </div>
        </div>

        <!-- Templates Tab Content -->
        <div class="settings-content" id="settings-templates">
          <div class="templates-header">
            <h3>Document Templates</h3>
            <p class="templates-description">Create reusable document request packages for practices.</p>
            <button class="btn-create-template" onclick="openTemplateModal()">+ Create Template</button>
          </div>

          <div class="templates-list" id="templates-list">
            <div class="templates-loading">Loading templates...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Template Create/Edit Modal -->
    <div class="modal-overlay" id="template-modal-overlay" style="display: none;">
      <div class="template-modal">
        <div class="template-modal-header">
          <h3 id="template-modal-title">Create Template</h3>
          <button class="modal-close" onclick="closeTemplateModal()">&times;</button>
        </div>
        <div class="template-modal-body">
          <input type="hidden" id="template-edit-id">

          <div class="template-form-group">
            <label>Template Name *</label>
            <input type="text" id="template-name" placeholder="e.g., Credentialing Package">
          </div>

          <div class="template-form-group">
            <label>Description</label>
            <input type="text" id="template-description" placeholder="Brief description of this template">
          </div>

          <div class="template-form-group">
            <label>Category</label>
            <select id="template-category">
              <option value="intake">Initial Intake</option>
              <option value="credentialing">Credentialing</option>
              <option value="financial">Financial Review</option>
              <option value="compliance">Compliance</option>
              <option value="real_estate">Real Estate</option>
              <option value="other">Other</option>
            </select>
          </div>

          <div class="template-items-section">
            <div class="template-items-header">
              <label>Template Items</label>
              <button class="btn-add-item" onclick="addTemplateItem()">+ Add Item</button>
            </div>
            <div class="template-items-list" id="template-items-list">
              <!-- Items added dynamically -->
            </div>
          </div>
        </div>
        <div class="template-modal-footer">
          <button class="btn-cancel" onclick="closeTemplateModal()">Cancel</button>
          <button class="btn-save" onclick="saveTemplate()">Save Template</button>
        </div>
      </div>
    </div>

    <!-- Admin Panel (only visible to admins) -->
    <div id="admin-panel" class="admin-panel" style="display: none;">
      <div class="admin-panel-header">
        <h3>User Access Management</h3>
        <span class="badge-admin">Admin</span>
      </div>

      <!-- Org Info -->
      <div id="admin-org-info" style="font-size: 0.8rem; color: #92400e; margin-bottom: 1rem; padding: 0.5rem; background: rgba(245, 158, 11, 0.1); border-radius: 4px;">
        Organization: <strong id="admin-org-slug">Loading...</strong>
        <span style="color: #666; margin-left: 0.5rem;" id="admin-org-id"></span>
      </div>

      <!-- Pending Access Requests -->
      <div id="pending-requests-section" style="margin-bottom: 1.5rem;">
        <h4 style="font-size: 0.85rem; color: #92400e; margin-bottom: 0.5rem;">Pending Access Requests</h4>
        <table class="allowlist-table" id="pending-requests-table">
          <thead>
            <tr>
              <th>Email</th>
              <th>Requested</th>
              <th>Role</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="pending-requests-tbody">
            <!-- Populated by JS -->
          </tbody>
        </table>
        <div id="no-pending-requests" style="font-size: 0.8rem; color: #888; padding: 0.5rem; display: none;">No pending requests</div>
      </div>

      <!-- Invite Team Member -->
      <div id="invite-section" style="margin-bottom: 1.5rem;">
        <h4 style="font-size: 0.85rem; color: #92400e; margin-bottom: 0.5rem;">Invite Team Member</h4>
        <div class="allowlist-form" style="margin-bottom: 0.75rem;">
          <input type="email" id="invite-email" placeholder="teammate@example.com">
          <select id="invite-role">
            <option value="editor">Editor</option>
            <option value="viewer">Viewer</option>
            <option value="admin">Admin</option>
          </select>
          <button onclick="createTeamInvite()">Create Invite</button>
        </div>
        <table class="allowlist-table" id="pending-invites-table">
          <thead>
            <tr>
              <th>Email</th>
              <th>Role</th>
              <th>Expires</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="pending-invites-tbody">
            <!-- Populated by JS -->
          </tbody>
        </table>
        <div id="no-pending-invites" style="font-size: 0.8rem; color: #888; padding: 0.5rem; display: none;">No pending invites</div>
      </div>

      <!-- Team Members -->
      <div id="team-members-section" style="margin-bottom: 1.5rem;">
        <h4 style="font-size: 0.85rem; color: #92400e; margin-bottom: 0.5rem;">Team Members</h4>
        <table class="allowlist-table" id="team-members-table">
          <thead>
            <tr>
              <th>Email</th>
              <th>Role</th>
              <th>Joined</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="team-members-tbody">
            <!-- Populated by JS -->
          </tbody>
        </table>
        <div id="no-team-members" style="font-size: 0.8rem; color: #888; padding: 0.5rem; display: none;">No team members</div>
      </div>

      <!-- Allowlist Management -->
      <h4 style="font-size: 0.85rem; color: #92400e; margin-bottom: 0.5rem;">Allowlist</h4>
      <div class="allowlist-form">
        <input type="email" id="allowlist-email" placeholder="user@example.com">
        <select id="allowlist-role">
          <option value="user">User</option>
          <option value="admin">Admin</option>
        </select>
        <button onclick="addToAllowlist()">Add User</button>
      </div>
      <table class="allowlist-table">
        <thead>
          <tr>
            <th>Email</th>
            <th>Role</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="allowlist-tbody">
          <!-- Populated by JS -->
        </tbody>
      </table>
    </div>

    <div class="metrics" id="metrics">
      <div class="metric-card">
        <div class="label">Total Practices</div>
        <div class="value" id="metric-total">0</div>
      </div>
      <div class="metric-card">
        <div class="label">Leads</div>
        <div class="value" id="metric-leads">0</div>
      </div>
      <div class="metric-card">
        <div class="label">Onboarding</div>
        <div class="value" id="metric-onboarding">0</div>
      </div>
      <div class="metric-card">
        <div class="label">Active</div>
        <div class="value" id="metric-active">0</div>
      </div>
      <div class="metric-card revenue">
        <div class="label">Total Monthly Revenue</div>
        <div class="value" id="metric-revenue">$0</div>
      </div>
    </div>

    <div class="card">
      <h2>Add New Practice</h2>
      <form id="intake-form">
        <div class="form-grid">
          <div class="form-group">
            <label for="practiceName">Practice Name</label>
            <input type="text" id="practiceName" required>
          </div>
          <div class="form-group">
            <label for="specialty">Specialty</label>
            <select id="specialty" class="specialty-select" required>
              <option value="">Select specialty...</option>
              <!-- Populated by JS -->
            </select>
          </div>
          <div class="form-group">
            <label for="ownerName">Owner Name</label>
            <input type="text" id="ownerName" required>
          </div>
          <div class="form-group">
            <label for="monthlyRevenue">Monthly Revenue ($)</label>
            <input type="number" id="monthlyRevenue" min="0" step="1" required>
          </div>
          <div class="form-group full-width">
            <label for="notes">Notes</label>
            <textarea id="notes" rows="2"></textarea>
          </div>
        </div>
        <div class="form-actions">
          <button type="submit" class="btn btn-primary">Add Practice</button>
        </div>
      </form>
    </div>

    <div class="card">
      <h2>Practices</h2>

      <!-- Search & Filter Bar -->
      <div class="search-filter-bar">
        <div class="search-input-wrapper">
          <label for="global-search">Search</label>
          <input type="text" id="global-search" class="search-input" placeholder="Name, specialty, owner, tags..." oninput="applyFilters()">
        </div>
        <div class="filter-select-wrapper">
          <label for="filter-status">Status</label>
          <select id="filter-status" class="filter-select" onchange="applyFilters()">
            <option value="">All Statuses</option>
            <option value="Lead">Lead</option>
            <option value="Onboarding">Onboarding</option>
            <option value="Active">Active</option>
            <option value="Exited">Exited</option>
            <option value="Archived">Archived</option>
          </select>
        </div>
        <div class="filter-select-wrapper">
          <label for="filter-specialty">Specialty</label>
          <select id="filter-specialty" class="filter-select specialty-select" onchange="applyFilters()">
            <option value="">All Specialties</option>
          </select>
        </div>
        <div class="filter-select-wrapper">
          <label for="filter-health">Health</label>
          <select id="filter-health" class="filter-select" onchange="applyFilters()">
            <option value="">All</option>
            <option value="green">Healthy</option>
            <option value="yellow">Needs Attention</option>
            <option value="red">At Risk</option>
          </select>
        </div>
        <div class="filter-select-wrapper">
          <label for="filter-capital-ready">Capital Ready</label>
          <select id="filter-capital-ready" class="filter-select" onchange="applyFilters()">
            <option value="">All</option>
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div class="filter-select-wrapper">
          <label for="filter-tag">Tag</label>
          <select id="filter-tag" class="filter-select" onchange="applyFilters()">
            <option value="">All Tags</option>
          </select>
        </div>
        <div class="filter-actions">
          <button class="btn-missing-report" onclick="showMissingDocsReport()">Missing Docs Report</button>
          <button class="btn-clear-filters" onclick="clearFilters()">Clear</button>
        </div>
      </div>

      <div class="view-toggle">
        <button id="btn-table-view" class="active" onclick="setView('table')">Table</button>
        <button id="btn-pipeline-view" onclick="setView('pipeline')">Pipeline</button>
        <button id="btn-portfolio-view" onclick="setView('portfolio')">Portfolio Intelligence</button>
        <button id="btn-operator-tasks-view" onclick="setView('operator-tasks')">Operator Tasks</button>
        <button id="btn-dashboard-view" onclick="setView('dashboard')">Dashboard</button>
      </div>

      <div class="table-container" id="table-container">
        <table>
          <thead>
            <tr>
              <th>Practice</th>
              <th>Specialty</th>
              <th>Owner</th>
              <th>Revenue</th>
              <th>Status</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="practices-table">
            <tr class="empty-state" id="empty-row">
              <td colspan="6">No practices yet. Add one above.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="pipeline-container" id="pipeline-container">
        <div class="pipeline-column column-lead">
          <div class="pipeline-column-header">
            <h3>Lead</h3>
            <span class="count" id="pipeline-lead-count">0</span>
          </div>
          <div class="pipeline-cards" id="pipeline-lead"></div>
        </div>
        <div class="pipeline-column column-onboarding">
          <div class="pipeline-column-header">
            <h3>Onboarding</h3>
            <span class="count" id="pipeline-onboarding-count">0</span>
          </div>
          <div class="pipeline-cards" id="pipeline-onboarding"></div>
        </div>
        <div class="pipeline-column column-active">
          <div class="pipeline-column-header">
            <h3>Active</h3>
            <span class="count" id="pipeline-active-count">0</span>
          </div>
          <div class="pipeline-cards" id="pipeline-active"></div>
        </div>
      </div>

      <div class="portfolio-container" id="portfolio-container">
        <!-- Rendered by renderPortfolioIntelligence() -->
      </div>

      <div id="operator-tasks-container" style="display: none;">
        <!-- Rendered by renderOperatorTasks() -->
      </div>

      <div id="dashboard-container" class="dashboard-container">
        <!-- Rendered by renderDashboard() -->
      </div>
    </div>

    <!-- Data Management Section -->
    <div class="card">
      <h2>Data Management</h2>
      <div class="data-management-grid">
        <div class="data-section">
          <h4>Database</h4>
          <p class="data-description">Export or import the complete database as JSON.</p>
          <div class="data-actions">
            <button class="btn btn-export" onclick="exportDatabaseJSON()">
              Export Database (JSON)
            </button>
            <label class="btn btn-secondary file-upload-btn">
              Import Database (JSON)
              <input type="file" id="import-db-file" accept=".json" onchange="importDatabaseJSON(event)" hidden>
            </label>
          </div>
        </div>
        <div class="data-section">
          <h4>Portfolio Report</h4>
          <p class="data-description">Export practice summary as CSV for spreadsheet analysis.</p>
          <div class="data-actions">
            <button class="btn btn-export" onclick="exportPortfolioCSV()">
              Export Portfolio (CSV)
            </button>
          </div>
        </div>
        <div class="data-section">
          <h4>Diagnostics</h4>
          <p class="data-description">Check database integrity and schema compliance.</p>
          <div class="data-actions">
            <button class="btn btn-secondary" onclick="runDiagnosticsUI()">
              Run Diagnostics
            </button>
          </div>
          <div id="diagnostics-output" class="diagnostics-output" style="display: none;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Practice Profile Modal -->
  <div class="modal-overlay" id="profile-modal">
    <div class="modal">
      <div class="modal-header">
        <h2 id="profile-title">Practice Profile</h2>
        <button class="modal-close" onclick="closeProfile()">&times;</button>
      </div>
      <div class="modal-body">
        <form id="profile-form">
          <div class="profile-section">
            <h3>Practice Information</h3>
            <div class="profile-info-grid">
              <div class="profile-info-item">
                <label for="profile-name">Practice Name</label>
                <input type="text" id="profile-name" required>
              </div>
              <div class="profile-info-item">
                <label for="profile-specialty">Specialty</label>
                <select id="profile-specialty" class="specialty-select" required>
                  <option value="">Select specialty...</option>
                  <!-- Populated by JS -->
                </select>
              </div>
              <div class="profile-info-item">
                <label for="profile-owner">Owner Name</label>
                <input type="text" id="profile-owner" required>
              </div>
              <div class="profile-info-item">
                <label for="profile-revenue">Monthly Revenue ($)</label>
                <input type="number" id="profile-revenue" min="0" step="1" required>
              </div>
              <div class="profile-info-item full-width">
                <label for="profile-notes">Notes</label>
                <textarea id="profile-notes" rows="2"></textarea>
              </div>
              <div class="profile-info-item">
                <label>Status</label>
                <div class="value" id="profile-status-display"></div>
              </div>
              <div class="profile-info-item">
                <label>Dates</label>
                <div class="profile-dates">
                  <span id="profile-created"></span>
                  <span id="profile-updated"></span>
                </div>
              </div>
            </div>

            <!-- Tags Section -->
            <div class="profile-subsection">
              <h4>Tags</h4>
              <div class="tags-container" id="profile-tags">
                <!-- Tags rendered by JS -->
                <div class="tag-input-wrapper">
                  <input type="text" class="tag-input" id="profile-tag-input" placeholder="Add tag..." onkeydown="handleTagInput(event)">
                </div>
              </div>
            </div>

            <!-- Practice Details - Operations -->
            <div class="profile-subsection">
              <h4>Operations</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-years-operation">Years in Operation</label>
                  <input type="number" id="profile-years-operation" min="0" step="1" placeholder="e.g. 15">
                </div>
                <div class="profile-details-item">
                  <label for="profile-num-providers">Number of Providers</label>
                  <input type="number" id="profile-num-providers" min="0" step="1" placeholder="e.g. 3">
                </div>
                <div class="profile-details-item">
                  <label for="profile-num-locations">Number of Locations</label>
                  <input type="number" id="profile-num-locations" min="1" step="1" placeholder="e.g. 2">
                </div>
                <div class="profile-details-item">
                  <label for="profile-num-exam-rooms">Exam Rooms (Total)</label>
                  <input type="number" id="profile-num-exam-rooms" min="0" step="1" placeholder="e.g. 8">
                </div>
                <div class="profile-details-item">
                  <label for="profile-num-staff-clinical">Clinical Staff FTE</label>
                  <input type="number" id="profile-num-staff-clinical" min="0" step="1" placeholder="e.g. 5">
                </div>
                <div class="profile-details-item">
                  <label for="profile-num-staff-admin">Admin Staff FTE</label>
                  <input type="number" id="profile-num-staff-admin" min="0" step="1" placeholder="e.g. 3">
                </div>
                <div class="profile-details-item">
                  <label for="profile-hours-per-week">Hours/Week</label>
                  <input type="number" id="profile-hours-per-week" min="0" max="168" step="1" placeholder="e.g. 45">
                </div>
                <div class="profile-details-item">
                  <label for="profile-monthly-patient-volume">Monthly Patient Volume</label>
                  <input type="number" id="profile-monthly-patient-volume" min="0" step="1" placeholder="e.g. 500">
                </div>
                <div class="profile-details-item">
                  <label for="profile-new-patients-monthly">New Patients/Month</label>
                  <input type="number" id="profile-new-patients-monthly" min="0" step="1" placeholder="e.g. 50">
                </div>
                <div class="profile-details-item">
                  <label for="profile-replacement-doctor">Replacement Doctor Required</label>
                  <select id="profile-replacement-doctor">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-has-telehealth">Telehealth Enabled</label>
                  <select id="profile-has-telehealth">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-accepts-new-patients">Accepting New Patients</label>
                  <select id="profile-accepts-new-patients">
                    <option value="">Unknown</option>
                    <option value="true">Yes</option>
                    <option value="false">No</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Practice Details - Financial Indicators -->
            <div class="profile-subsection">
              <h4>Financial Indicators (Internal Est.)</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-revenue-model">Revenue Model</label>
                  <select id="profile-revenue-model">
                    <option value="">Not Set</option>
                    <option value="cash">Cash-Pay</option>
                    <option value="insurance">Insurance</option>
                    <option value="hybrid">Hybrid</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-ebitda-margin">Est. EBITDA Margin (%)</label>
                  <input type="number" id="profile-ebitda-margin" min="0" max="100" step="1" placeholder="e.g. 25">
                </div>
                <div class="profile-details-item">
                  <label for="profile-growth-rate">Growth Rate Est.</label>
                  <select id="profile-growth-rate">
                    <option value="Unknown">Unknown</option>
                    <option value="Declining">Declining</option>
                    <option value="Flat">Flat</option>
                    <option value="Growing">Growing</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Practice Details - Ownership / Exit Context -->
            <div class="profile-subsection">
              <h4>Ownership / Exit Context</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-owner-age">Owner Age</label>
                  <input type="number" id="profile-owner-age" min="20" max="100" step="1" placeholder="e.g. 58">
                </div>
                <div class="profile-details-item">
                  <label for="profile-exit-intent">Owner Exit Intent</label>
                  <select id="profile-exit-intent">
                    <option value="Unknown">Unknown</option>
                    <option value="1-2yrs">1-2 Years</option>
                    <option value="3-5yrs">3-5 Years</option>
                    <option value="5+yrs">5+ Years</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-rebrand">Open to Rebrand</label>
                  <select id="profile-rebrand">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-stay-on">Willingness to Stay On</label>
                  <select id="profile-stay-on">
                    <option value="Unknown">Unknown</option>
                    <option value="Full-Time">Full-Time</option>
                    <option value="Part-Time">Part-Time</option>
                    <option value="No">No</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Payer Mix -->
            <div class="profile-subsection">
              <h4>Payer Mix (%)</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-payer-commercial">Commercial/Private</label>
                  <input type="number" id="profile-payer-commercial" min="0" max="100" step="1" placeholder="e.g. 60">
                </div>
                <div class="profile-details-item">
                  <label for="profile-payer-medicare">Medicare</label>
                  <input type="number" id="profile-payer-medicare" min="0" max="100" step="1" placeholder="e.g. 25">
                </div>
                <div class="profile-details-item">
                  <label for="profile-payer-medicaid">Medicaid</label>
                  <input type="number" id="profile-payer-medicaid" min="0" max="100" step="1" placeholder="e.g. 10">
                </div>
                <div class="profile-details-item">
                  <label for="profile-payer-cash">Cash/Self-Pay</label>
                  <input type="number" id="profile-payer-cash" min="0" max="100" step="1" placeholder="e.g. 5">
                </div>
                <div class="profile-details-item">
                  <label for="profile-payer-other">Other</label>
                  <input type="number" id="profile-payer-other" min="0" max="100" step="1" placeholder="e.g. 0">
                </div>
              </div>
            </div>

            <!-- Technology -->
            <div class="profile-subsection">
              <h4>Technology</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-emr-system">EMR System</label>
                  <input type="text" id="profile-emr-system" placeholder="e.g. Epic, Athena">
                </div>
                <div class="profile-details-item">
                  <label for="profile-practice-mgmt">Practice Mgmt System</label>
                  <input type="text" id="profile-practice-mgmt" placeholder="e.g. Kareo">
                </div>
                <div class="profile-details-item">
                  <label for="profile-billing-system">Billing System</label>
                  <input type="text" id="profile-billing-system" placeholder="e.g. In-house, AdvancedMD">
                </div>
                <div class="profile-details-item">
                  <label for="profile-emr-exportable">EMR Data Exportable</label>
                  <select id="profile-emr-exportable">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Real Estate -->
            <div class="profile-subsection">
              <h4>Real Estate</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-real-estate-status">Ownership Status</label>
                  <select id="profile-real-estate-status">
                    <option value="Unknown">Unknown</option>
                    <option value="Leased">Leased</option>
                    <option value="Owned">Owned</option>
                    <option value="Mixed">Mixed</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-lease-expiration">Lease Expiration</label>
                  <input type="date" id="profile-lease-expiration">
                </div>
                <div class="profile-details-item">
                  <label for="profile-monthly-rent">Monthly Rent ($)</label>
                  <input type="number" id="profile-monthly-rent" min="0" step="100" placeholder="e.g. 8500">
                </div>
                <div class="profile-details-item">
                  <label for="profile-square-footage">Square Footage</label>
                  <input type="number" id="profile-square-footage" min="0" step="100" placeholder="e.g. 3500">
                </div>
                <div class="profile-details-item">
                  <label for="profile-facility-condition">Facility Condition</label>
                  <select id="profile-facility-condition">
                    <option value="Unknown">Unknown</option>
                    <option value="Excellent">Excellent</option>
                    <option value="Good">Good</option>
                    <option value="Fair">Fair</option>
                    <option value="Poor">Poor</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-expansion-possible">Expansion Possible</label>
                  <select id="profile-expansion-possible">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Legal & Corporate -->
            <div class="profile-subsection">
              <h4>Legal & Corporate</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-entity-type">Entity Type</label>
                  <input type="text" id="profile-entity-type" placeholder="e.g. LLC, PC, PLLC">
                </div>
                <div class="profile-details-item">
                  <label for="profile-state-incorporation">State of Incorporation</label>
                  <input type="text" id="profile-state-incorporation" placeholder="e.g. TX, FL">
                </div>
                <div class="profile-details-item">
                  <label for="profile-tax-id-last4">Tax ID (last 4)</label>
                  <input type="text" id="profile-tax-id-last4" maxlength="4" placeholder="e.g. 1234">
                </div>
                <div class="profile-details-item">
                  <label for="profile-outstanding-litigation">Outstanding Litigation</label>
                  <select id="profile-outstanding-litigation">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-malpractice-claims">Malpractice Claims (5yr)</label>
                  <input type="number" id="profile-malpractice-claims" min="0" step="1" placeholder="e.g. 0">
                </div>
                <div class="profile-details-item">
                  <label for="profile-contracts-assignable">Contracts Assignable</label>
                  <select id="profile-contracts-assignable">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Deal Terms -->
            <div class="profile-subsection">
              <h4>Deal Terms</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-asking-price">Asking Price ($)</label>
                  <input type="number" id="profile-asking-price" min="0" step="10000" placeholder="e.g. 2500000">
                </div>
                <div class="profile-details-item">
                  <label for="profile-deal-structure">Deal Structure Pref</label>
                  <select id="profile-deal-structure">
                    <option value="Unknown">Unknown</option>
                    <option value="Asset">Asset Sale</option>
                    <option value="Stock">Stock Sale</option>
                    <option value="Merger">Merger</option>
                    <option value="Flexible">Flexible</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-seller-financing">Seller Financing Available</label>
                  <select id="profile-seller-financing">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-transition-months">Transition Support (months)</label>
                  <input type="number" id="profile-transition-months" min="0" max="36" step="1" placeholder="e.g. 6">
                </div>
                <div class="profile-details-item">
                  <label for="profile-earnout-acceptable">Earnout Acceptable</label>
                  <select id="profile-earnout-acceptable">
                    <option value="Unknown">Unknown</option>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-exclusivity-status">Exclusivity Status</label>
                  <select id="profile-exclusivity-status">
                    <option value="Unknown">Unknown</option>
                    <option value="None">None</option>
                    <option value="Active">Active (Exclusive)</option>
                    <option value="Expired">Expired</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-exclusivity-expires">Exclusivity Expires</label>
                  <input type="date" id="profile-exclusivity-expires">
                </div>
              </div>
            </div>

            <!-- Quality & Market -->
            <div class="profile-subsection">
              <h4>Quality & Market</h4>
              <div class="profile-details-grid">
                <div class="profile-details-item">
                  <label for="profile-google-rating">Google Rating</label>
                  <input type="number" id="profile-google-rating" min="0" max="5" step="0.1" placeholder="e.g. 4.7">
                </div>
                <div class="profile-details-item">
                  <label for="profile-google-reviews">Google Review Count</label>
                  <input type="number" id="profile-google-reviews" min="0" step="1" placeholder="e.g. 125">
                </div>
                <div class="profile-details-item">
                  <label for="profile-quality-score">Internal Quality Score (0-100)</label>
                  <input type="number" id="profile-quality-score" min="0" max="100" step="1" placeholder="e.g. 85">
                </div>
                <div class="profile-details-item">
                  <label for="profile-market-position">Market Position</label>
                  <select id="profile-market-position">
                    <option value="Unknown">Unknown</option>
                    <option value="Leader">Market Leader</option>
                    <option value="Established">Established</option>
                    <option value="Growing">Growing</option>
                    <option value="Niche">Niche Player</option>
                  </select>
                </div>
                <div class="profile-details-item">
                  <label for="profile-competition-density">Competition Density</label>
                  <select id="profile-competition-density">
                    <option value="Unknown">Unknown</option>
                    <option value="Low">Low</option>
                    <option value="Medium">Medium</option>
                    <option value="High">High</option>
                    <option value="Saturated">Saturated</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- Locations Section -->
            <div class="profile-subsection">
              <h4>Locations</h4>
              <div id="profile-locations-list" class="locations-list">
                <!-- Rendered by JS -->
              </div>
              <button type="button" class="btn btn-add-location" onclick="addProfileLocation()">+ Add Location</button>
            </div>

            <div class="profile-form-actions">
              <button type="submit" class="btn btn-save">Save Changes</button>
              <button type="button" class="btn btn-cancel" onclick="closeProfile()">Cancel</button>
            </div>
          </div>
        </form>

        <div class="profile-section">
          <h3>Practice Intelligence</h3>
          <div class="intelligence-panel" id="intelligence-panel">
            <!-- Rendered by renderPracticeIntelligence() -->
          </div>
        </div>

        <div class="profile-section">
          <h3>Quick Actions</h3>
          <div class="quick-actions">
            <button class="btn btn-advance" id="profile-advance-btn" onclick="profileAdvanceStatus()">Advance Status</button>
            <button class="btn btn-back btn-secondary" id="profile-back-btn" onclick="profileRegressStatus()">Move Back</button>
            <button class="btn btn-delete" onclick="profileDelete()">Delete Practice</button>
            <button class="btn btn-export" onclick="exportPractice()">Export JSON</button>
            <button class="btn btn-packet" onclick="openPacketPreview()">Generate DD Packet</button>
            <button class="btn btn-request-docs" onclick="requestMissingDocsEmail()">Request Documents</button>
          </div>
        </div>

        <div class="profile-section">
          <h3>Activity Log</h3>
          <div class="activity-log" id="activity-log">
            <div class="activity-log-empty">No activity recorded yet.</div>
          </div>
        </div>

        <!-- Document Hub Section -->
        <div class="profile-section" id="document-hub-section">
          <div class="doc-hub-header">
            <h3>Document Hub</h3>
            <div class="doc-hub-tabs">
              <button class="doc-hub-tab active" data-tab="financial" onclick="switchDocTab('financial')">
                <span class="tab-icon"></span> Financial
              </button>
              <button class="doc-hub-tab" data-tab="dd-corporate" onclick="switchDocTab('dd-corporate')">
                <span class="tab-icon"></span> Corporate
              </button>
              <button class="doc-hub-tab" data-tab="dd-compliance" onclick="switchDocTab('dd-compliance')">
                <span class="tab-icon"></span> Compliance
              </button>
              <button class="doc-hub-tab" data-tab="dd-contracts" onclick="switchDocTab('dd-contracts')">
                <span class="tab-icon"></span> Contracts
              </button>
              <button class="doc-hub-tab" data-tab="dd-other" onclick="switchDocTab('dd-other')">
                <span class="tab-icon"></span> Other DD
              </button>
            </div>
          </div>

          <!-- DD Readiness Score -->
          <div class="dd-readiness-bar" id="dd-readiness-bar">
            <div class="dd-readiness-label">DD Readiness</div>
            <div class="dd-readiness-track">
              <div class="dd-readiness-fill" id="dd-readiness-fill" style="width: 0%"></div>
            </div>
            <div class="dd-readiness-pct" id="dd-readiness-pct">0%</div>
            <div class="dd-readiness-trend" id="dd-readiness-trend"></div>
            <button class="btn-bulk-upload" onclick="openBulkUpload()">
              Bulk Upload
            </button>
            <button class="btn-apply-template" id="btn-apply-template" onclick="showTemplatePickerModal()">
              Apply Template
            </button>
          </div>
          <input type="file" id="bulk-upload-input" multiple accept=".pdf,.png,.jpg,.jpeg,.doc,.docx,.xlsx" style="display:none" onchange="handleBulkUpload(event)">

          <!-- Pending Document Requests -->
          <div class="pending-requests-section" id="pending-requests-section" style="display: none;">
            <div class="pending-requests-header">
              <span class="pending-requests-title">Pending Document Requests</span>
              <span class="pending-requests-count" id="pending-requests-count">0</span>
            </div>
            <div class="pending-requests-list" id="pending-requests-list">
              <!-- Populated by JS -->
            </div>
          </div>

          <!-- DD Checklist Section -->
          <div class="dd-checklist-section" id="dd-checklist-section">
            <div class="dd-checklist-header" onclick="toggleChecklistView()">
              <span class="dd-checklist-title">
                <span class="checklist-toggle-icon" id="checklist-toggle-icon"></span>
                DD Requirements Checklist
              </span>
              <span class="dd-checklist-summary" id="dd-checklist-summary">0/0 complete</span>
            </div>
            <div class="dd-checklist-content" id="dd-checklist-content" style="display: none;">
              <div class="dd-checklist-list" id="dd-checklist-list">
                <div class="dd-checklist-empty">No checklist items. Click "Apply DD Checklist" to get started.</div>
              </div>
            </div>
          </div>

          <!-- Financial Tab Content -->
          <div class="doc-tab-content active" id="tab-financial">

          <!-- Financial Profile Summary -->
          <div class="financial-profile-summary" id="financial-profile-summary">
            <div class="fin-profile-metrics">
              <div class="fin-metric">
                <span class="fin-metric-label">Coverage</span>
                <div class="fin-progress-bar">
                  <div class="fin-progress-fill" id="fin-coverage-bar" style="width: 0%"></div>
                </div>
                <span class="fin-metric-value" id="fin-coverage-text">0/36 months</span>
              </div>
              <div class="fin-metric">
                <span class="fin-metric-label">Confidence</span>
                <div class="fin-progress-bar">
                  <div class="fin-progress-fill confidence" id="fin-confidence-bar" style="width: 0%"></div>
                </div>
                <span class="fin-metric-value" id="fin-confidence-text">--</span>
              </div>
              <div class="fin-metric">
                <span class="fin-metric-label">TTM Revenue
                  <span class="info-tooltip">
                    <span class="info-icon"></span>
                    <span class="info-tooltip-text">
                      <strong>Live Audit</strong><br>
                      Trailing Twelve Months (TTM) revenue automatically updates each month, showing the most recent 12-month rolling window of verified bank deposits.<br><br>
                       Auto-rolls forward monthly<br>
                       Historical data preserved<br>
                       Confidence scores track data quality
                    </span>
                  </span>
                  <span id="fin-ttm-range" style="font-weight: normal; font-size: 11px; color: #888;"></span>
                </span>
                <span class="fin-metric-value large" id="fin-t12-revenue">--</span>
                <span class="fin-metric-sub" id="fin-ttm-coverage" style="font-size: 11px; color: #888;"></span>
              </div>
            </div>
          </div>

          <!-- Historical Data Section -->
          <div class="financial-historical-summary" id="financial-historical-summary">
            <div class="fin-historical-header">
              <span class="fin-historical-title">Historical Data</span>
              <span class="info-tooltip">
                <span class="info-icon"></span>
                <span class="info-tooltip-text">
                  <strong>All-Time Financial Data</strong><br>
                  Includes all extracted financial data regardless of date, providing a complete picture of practice performance over time.
                </span>
              </span>
            </div>
            <div class="fin-historical-metrics">
              <div class="fin-historical-item">
                <span class="fin-historical-label">All-Time Deposits</span>
                <span class="fin-historical-value" id="fin-all-time-deposits">--</span>
              </div>
              <div class="fin-historical-item">
                <span class="fin-historical-label">Avg Monthly</span>
                <span class="fin-historical-value" id="fin-avg-monthly">--</span>
              </div>
              <div class="fin-historical-item">
                <span class="fin-historical-label">Data Range</span>
                <span class="fin-historical-value" id="fin-data-range">--</span>
              </div>
              <div class="fin-historical-item">
                <span class="fin-historical-label">YoY Growth</span>
                <span class="fin-historical-value" id="fin-yoy-growth">--</span>
              </div>
            </div>
          </div>

          <!-- Monthly Breakdown Table -->
          <div class="fin-monthly-breakdown" id="fin-monthly-breakdown">
            <div class="fin-monthly-header">
              <span class="fin-monthly-title">Monthly Breakdown</span>
              <span class="fin-monthly-toggle" id="fin-monthly-toggle" onclick="toggleMonthlyBreakdown()">Show All</span>
            </div>
            <div class="fin-monthly-table-container" id="fin-monthly-table-container">
              <table class="fin-monthly-table">
                <thead>
                  <tr>
                    <th>Period</th>
                    <th>Deposits</th>
                    <th>Source</th>
                    <th>Confidence</th>
                  </tr>
                </thead>
                <tbody id="fin-monthly-tbody">
                  <tr>
                    <td colspan="4" class="fin-monthly-empty">No monthly data available yet.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Upload Area -->
          <div class="fin-upload-area" id="fin-upload-area">
            <input type="file" id="fin-file-input" multiple accept=".pdf,.png,.jpg,.jpeg,.xlsx,.csv" style="display:none" onchange="handleFinancialDocUpload(event)">
            <div class="fin-upload-dropzone" id="fin-upload-dropzone" onclick="document.getElementById('fin-file-input').click()">
              <div class="fin-upload-icon"></div>
              <div class="fin-upload-text">Drop financial documents here or click to upload</div>
              <div class="fin-upload-hint">Bank statements, P&L, tax docs (PDF, images, Excel)</div>
            </div>
          </div>

          <!-- Document Type Selector (shown after file selected) -->
          <div class="fin-doc-type-selector" id="fin-doc-type-selector" style="display:none">
            <label>Document Type:</label>
            <select id="fin-doc-type">
              <option value="bank_statement">Bank Statement</option>
              <option value="income_statement">Income Statement / P&L</option>
              <option value="balance_sheet">Balance Sheet</option>
              <option value="tax_return">Tax Return</option>
              <option value="ar_aging">AR Aging Report</option>
              <option value="payroll_report">Payroll Report</option>
              <option value="other">Other</option>
            </select>
          </div>

          <!-- Documents List -->
          <div class="fin-documents-list" id="fin-documents-list">
            <div class="fin-docs-empty">No financial documents uploaded yet.</div>
          </div>

          </div><!-- End Financial Tab -->

          <!-- DD Corporate Tab Content -->
          <div class="doc-tab-content" id="tab-dd-corporate">
            <div class="dd-tab-header">
              <h4>Corporate & Ownership Documents</h4>
              <p class="dd-tab-desc">Articles of incorporation, operating agreements, cap table, ownership history</p>
            </div>
            <div class="dd-upload-area">
              <input type="file" id="dd-file-corporate" multiple accept=".pdf,.png,.jpg,.jpeg,.doc,.docx" style="display:none" onchange="handleDDDocUpload(event, 'dd_corporate')">
              <div class="dd-upload-dropzone" onclick="document.getElementById('dd-file-corporate').click()">
                <div class="dd-upload-icon"></div>
                <div class="dd-upload-text">Drop corporate documents here or click to upload</div>
              </div>
            </div>
            <div class="dd-documents-list" id="dd-docs-corporate">
              <div class="dd-docs-empty">No corporate documents uploaded yet.</div>
            </div>
          </div>

          <!-- DD Compliance Tab Content -->
          <div class="doc-tab-content" id="tab-dd-compliance">
            <div class="dd-tab-header">
              <h4>Licenses & Compliance</h4>
              <p class="dd-tab-desc">Medical licenses, DEA registrations, CLIA, HIPAA attestations, malpractice history</p>
            </div>
            <div class="dd-upload-area">
              <input type="file" id="dd-file-compliance" multiple accept=".pdf,.png,.jpg,.jpeg,.doc,.docx" style="display:none" onchange="handleDDDocUpload(event, 'dd_compliance')">
              <div class="dd-upload-dropzone" onclick="document.getElementById('dd-file-compliance').click()">
                <div class="dd-upload-icon"></div>
                <div class="dd-upload-text">Drop compliance documents here or click to upload</div>
              </div>
            </div>
            <div class="dd-documents-list" id="dd-docs-compliance">
              <div class="dd-docs-empty">No compliance documents uploaded yet.</div>
            </div>
          </div>

          <!-- DD Contracts Tab Content -->
          <div class="doc-tab-content" id="tab-dd-contracts">
            <div class="dd-tab-header">
              <h4>Contracts & Agreements</h4>
              <p class="dd-tab-desc">Vendor contracts, payer agreements, service agreements, employment contracts</p>
            </div>
            <div class="dd-upload-area">
              <input type="file" id="dd-file-contracts" multiple accept=".pdf,.png,.jpg,.jpeg,.doc,.docx" style="display:none" onchange="handleDDDocUpload(event, 'dd_contracts')">
              <div class="dd-upload-dropzone" onclick="document.getElementById('dd-file-contracts').click()">
                <div class="dd-upload-icon"></div>
                <div class="dd-upload-text">Drop contracts here or click to upload</div>
              </div>
            </div>
            <div class="dd-documents-list" id="dd-docs-contracts">
              <div class="dd-docs-empty">No contracts uploaded yet.</div>
            </div>
          </div>

          <!-- DD Other Tab Content -->
          <div class="doc-tab-content" id="tab-dd-other">
            <div class="dd-tab-header">
              <h4>Other Due Diligence</h4>
              <p class="dd-tab-desc">Real estate, insurance, HR, IT, equipment, and other DD documents</p>
            </div>
            <div class="dd-category-select">
              <label>Category:</label>
              <select id="dd-other-category">
                <option value="dd_real_estate">Real Estate & Lease</option>
                <option value="dd_insurance">Insurance</option>
                <option value="dd_hr">HR & Staff</option>
                <option value="dd_it">IT & Systems</option>
                <option value="dd_equipment">Equipment & Assets</option>
                <option value="practice_overview">Practice Overview</option>
              </select>
            </div>
            <div class="dd-upload-area">
              <input type="file" id="dd-file-other" multiple accept=".pdf,.png,.jpg,.jpeg,.doc,.docx,.xlsx" style="display:none" onchange="handleDDDocUpload(event, document.getElementById('dd-other-category').value)">
              <div class="dd-upload-dropzone" onclick="document.getElementById('dd-file-other').click()">
                <div class="dd-upload-icon"></div>
                <div class="dd-upload-text">Drop documents here or click to upload</div>
              </div>
            </div>
            <div class="dd-documents-list" id="dd-docs-other">
              <div class="dd-docs-empty">No other DD documents uploaded yet.</div>
            </div>
          </div>

        </div><!-- End Document Hub Section -->
      </div>
    </div>
  </div>

  <!-- Packet Preview Modal -->
  <div class="modal-overlay" id="packet-modal">
    <div class="modal packet-modal">
      <div class="modal-header">
        <h2>Due Diligence Packet Preview</h2>
        <button class="modal-close" onclick="closePacketPreview()">&times;</button>
      </div>
      <div class="packet-actions">
        <button class="btn btn-print" onclick="printPacket()">Print / Save as PDF</button>
        <button class="btn btn-download" onclick="downloadPacketHTML()">Download HTML</button>
        <button class="btn btn-secondary" onclick="closePacketPreview()">Close</button>
      </div>
      <div class="packet-preview-container">
        <div class="packet-preview" id="packet-preview">
          <!-- Packet content rendered here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Extraction Confirmation Modal -->
  <div class="modal-overlay" id="extraction-confirm-modal">
    <div class="modal extraction-modal">
      <div class="modal-header">
        <h2>Confirm Extraction</h2>
        <button class="modal-close" onclick="closeExtractionModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p class="extraction-modal-intro">Please verify the extracted data before saving to the Live Audit dashboard.</p>

        <!-- Statement Period - Highlighted Section -->
        <div class="extraction-period-section">
          <div class="extraction-period-header">
            <span class="period-icon">&#128197;</span>
            <label>Statement Period</label>
            <span class="required-badge">Required</span>
          </div>
          <p class="period-help-text">Select the month and year this bank statement covers:</p>
          <div class="period-select-row">
            <select id="extract-period-month" class="period-select">
              <option value="01">January</option>
              <option value="02">February</option>
              <option value="03">March</option>
              <option value="04">April</option>
              <option value="05">May</option>
              <option value="06">June</option>
              <option value="07">July</option>
              <option value="08">August</option>
              <option value="09">September</option>
              <option value="10">October</option>
              <option value="11">November</option>
              <option value="12">December</option>
            </select>
            <select id="extract-period-year" class="period-select">
              <!-- Populated by JS -->
            </select>
          </div>
          <span id="extract-period-display" style="display: none;"></span>
          <div id="period-edit-fields" style="display: none;"></div>
          <button id="edit-period-btn" style="display: none;"></button>
        </div>

        <div class="extraction-data-grid">

          <div class="extraction-data-item">
            <label>Total Deposits (Revenue) *</label>
            <div class="extraction-input-wrapper">
              <span class="input-prefix">$</span>
              <input type="number" id="extract-deposits-input" class="extraction-input" placeholder="0.00" step="0.01" min="0">
            </div>
            <span id="extract-deposits" class="extraction-value large" style="display: none;"></span>
          </div>

          <div class="extraction-data-item">
            <label>Ending Balance</label>
            <div class="extraction-input-wrapper">
              <span class="input-prefix">$</span>
              <input type="number" id="extract-balance-input" class="extraction-input" placeholder="0.00" step="0.01" min="0">
            </div>
            <span id="extract-balance" class="extraction-value" style="display: none;"></span>
          </div>

          <div class="extraction-data-item">
            <label>Beginning Balance (optional)</label>
            <div class="extraction-input-wrapper">
              <span class="input-prefix">$</span>
              <input type="number" id="extract-beginning-balance-input" class="extraction-input" placeholder="0.00" step="0.01" min="0">
            </div>
          </div>

          <div class="extraction-data-item">
            <label>Total Withdrawals (optional)</label>
            <div class="extraction-input-wrapper">
              <span class="input-prefix">$</span>
              <input type="number" id="extract-withdrawals-input" class="extraction-input" placeholder="0.00" step="0.01" min="0">
            </div>
          </div>

          <div class="extraction-data-item" id="confidence-display-row">
            <label>Extraction Confidence</label>
            <div class="confidence-display">
              <div class="confidence-bar-container">
                <div class="confidence-bar-fill" id="extract-confidence-bar"></div>
              </div>
              <span id="extract-confidence-text" class="extraction-value"></span>
            </div>
          </div>
        </div>

        <div class="extraction-ttm-notice" id="extraction-ttm-notice">
          <!-- Will show if period is outside TTM window -->
        </div>

        <div class="extraction-actions">
          <button class="btn btn-primary" onclick="confirmExtraction()">Confirm & Save</button>
          <button class="btn btn-danger" onclick="rejectExtraction()">Reject</button>
          <button class="btn btn-secondary" onclick="closeExtractionModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

<!-- Supabase client library -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
  const SUPABASE_URL = "https://zwdfjndmkyrrovkrennj.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_qTJDPaR2PpV6wyqI9fJMjw_La9tZPxa";
  window.sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    auth: {
      persistSession: true,
      storageKey: 'zenyte-auth',
      storage: window.localStorage,
      autoRefreshToken: true,
      detectSessionInUrl: true
    }
  });
</script>

  <script>
    // =============================================
    // CONSTANTS & ENUMS (Practice v1 Schema)
    // =============================================
    const DB_STORAGE_KEY = 'zenyte_db';
    const LEGACY_STORAGE_KEY = 'zenyte_practices';
    const DATA_VERSION = 'practice_v1';

    // Data Source Toggle: "supabase" | "local"
    const DATA_SOURCE = "supabase";


    // Practice Statuses (canonical)
    const PRACTICE_STATUSES = ['Lead', 'Onboarding', 'Active', 'Exited', 'Archived'];
    const STATUS_ORDER = ['Lead', 'Onboarding', 'Active']; // For UI advancement

    // Specialties (canonical) - Comprehensive healthcare + aesthetics taxonomy
    // Grouped for UI organization, stored as flat enum strings
    const SPECIALTY_GROUPS = {
      'Aesthetics / Cash-Pay': [
        { value: 'Med Spa', label: 'Med Spa' },
        { value: 'Plastic Surgery', label: 'Plastic Surgery' },
        { value: 'Derm Cosmetic', label: 'Dermatology (Cosmetic)' },
        { value: 'Hair Restoration', label: 'Hair Restoration' },
        { value: 'Wellness Longevity', label: 'Wellness / Longevity Clinic' }
      ],
      'Medical Specialties': [
        { value: 'Pain Mgmt', label: 'Pain Management' },
        { value: 'Cardiology', label: 'Cardiology' },
        { value: 'Orthopedics', label: 'Orthopedics' },
        { value: 'Neurology', label: 'Neurology' },
        { value: 'Gastroenterology', label: 'Gastroenterology' },
        { value: 'Urology', label: 'Urology' },
        { value: 'OB/GYN', label: 'OB/GYN' },
        { value: 'ENT', label: 'ENT' },
        { value: 'Ophthalmology', label: 'Ophthalmology' },
        { value: 'Oncology', label: 'Oncology' },
        { value: 'Pulmonology', label: 'Pulmonology' },
        { value: 'Endocrinology', label: 'Endocrinology' }
      ],
      'Primary / Outpatient': [
        { value: 'Family Med', label: 'Family Medicine' },
        { value: 'Internal Med', label: 'Internal Medicine' },
        { value: 'Urgent Care', label: 'Urgent Care' },
        { value: 'Primary Care Group', label: 'Primary Care Group' }
      ],
      'Dental / Ancillary': [
        { value: 'General Dentistry', label: 'General Dentistry' },
        { value: 'Orthodontics', label: 'Orthodontics' },
        { value: 'Oral Surgery', label: 'Oral Surgery' }
      ],
      'Other': [
        { value: 'Imaging Diagnostics', label: 'Imaging / Diagnostics' },
        { value: 'ASC', label: 'ASC / Surgical Center' },
        { value: 'Other', label: 'Other' }
      ]
    };

    // Flat SPECIALTIES array for backward compatibility
    const SPECIALTIES = Object.values(SPECIALTY_GROUPS).flat();

    // Revenue Model Options
    const REVENUE_MODELS = [
      { value: 'cash', label: 'Cash-Pay' },
      { value: 'insurance', label: 'Insurance' },
      { value: 'hybrid', label: 'Hybrid' }
    ];

    // Growth Rate Options
    const GROWTH_RATES = [
      { value: 'declining', label: 'Declining' },
      { value: 'flat', label: 'Flat' },
      { value: 'growing', label: 'Growing' },
      { value: 'unknown', label: 'Unknown' }
    ];

    // Owner Exit Intent Options
    const EXIT_INTENTS = [
      { value: '1-2yrs', label: '1-2 Years' },
      { value: '3-5yrs', label: '3-5 Years' },
      { value: '5+yrs', label: '5+ Years' },
      { value: 'unknown', label: 'Unknown' }
    ];

    // Yes/No/Unknown Options (reusable)
    const YES_NO_UNKNOWN = [
      { value: 'yes', label: 'Yes' },
      { value: 'no', label: 'No' },
      { value: 'unknown', label: 'Unknown' }
    ];

    // Willingness to Stay On Options
    const STAY_ON_OPTIONS = [
      { value: 'full', label: 'Full-Time' },
      { value: 'part-time', label: 'Part-Time' },
      { value: 'no', label: 'No' },
      { value: 'unknown', label: 'Unknown' }
    ];

    // =============================================
    // SPECIALTY KEY MAPPING (Internal Normalization)
    // =============================================
    // Maps human-readable specialty values to internal snake_case keys
    // Used for filtering, aggregation, and analytics readiness
    // The specialty field remains the source of truth for display
    const SPECIALTY_TO_KEY = {
      // Aesthetics / Cash-Pay
      'Med Spa': 'med_spa',
      'Plastic Surgery': 'plastic_surgery',
      'Derm Cosmetic': 'derm_cosmetic',
      'Hair Restoration': 'hair_restoration',
      'Wellness Longevity': 'wellness_longevity',
      // Medical Specialties
      'Pain Mgmt': 'pain_management',
      'Cardiology': 'cardiology',
      'Orthopedics': 'orthopedics',
      'Neurology': 'neurology',
      'Gastroenterology': 'gastroenterology',
      'Urology': 'urology',
      'OB/GYN': 'ob_gyn',
      'ENT': 'ent',
      'Ophthalmology': 'ophthalmology',
      'Oncology': 'oncology',
      'Pulmonology': 'pulmonology',
      'Endocrinology': 'endocrinology',
      // Primary / Outpatient
      'Family Med': 'family_medicine',
      'Internal Med': 'internal_medicine',
      'Urgent Care': 'urgent_care',
      'Primary Care Group': 'primary_care_group',
      // Dental / Ancillary
      'General Dentistry': 'general_dentistry',
      'Orthodontics': 'orthodontics',
      'Oral Surgery': 'oral_surgery',
      // Other
      'Imaging Diagnostics': 'imaging_diagnostics',
      'ASC': 'asc',
      'Other': 'other'
    };

    // Derive specialty_key from specialty value (deterministic)
    function deriveSpecialtyKey(specialty) {
      if (!specialty) return null;
      return SPECIALTY_TO_KEY[specialty] || 'other';
    }

    // =============================================
    // TAG EFFECTS MAP (Semantic Tag Signals)
    // =============================================
    // Defines how certain tags influence computed intelligence
    // Effects are applied in computePracticeIntelligence() only
    // No data is persisted - effects are computed on-the-fly
    const TAG_EFFECTS = {
      'hot-lead': {
        urgency_boost: 10,           // Adds to priority scoring
        recommended_action: 'Prioritize outreach - marked as hot lead',
        health_modifier: null        // No health change
      },
      'replacement-doctor': {
        urgency_boost: 5,
        risk_signal: 'Replacement doctor needed - acquisition complexity',
        recommended_action: 'Identify replacement physician candidates',
        health_modifier: 'yellow'    // Can downgrade green to yellow
      },
      'bank-ready': {
        capital_ready_override: true, // Overrides capital-ready calculation
        recommended_action: null,     // No specific action needed
        health_modifier: null
      },
      'needs-follow-up': {
        urgency_boost: 3,
        recommended_action: 'Schedule follow-up call',
        health_modifier: null
      },
      'high-value': {
        urgency_boost: 5,
        recommended_action: 'Prioritize - high value target',
        health_modifier: null
      },
      'stalled': {
        urgency_boost: 0,
        risk_signal: 'Deal marked as stalled - review blockers',
        recommended_action: 'Review and address blockers',
        health_modifier: 'yellow'
      },
      'ready-to-close': {
        capital_ready_boost: true,
        recommended_action: 'Finalize closing documents',
        health_modifier: null
      }
    };

    // Compute tag effects for a practice (aggregates all tag signals)
    function computeTagEffects(tags) {
      const effects = {
        urgency_boost: 0,
        risk_signals: [],
        recommended_actions: [],
        health_modifier: null,
        capital_ready_override: false,
        capital_ready_boost: false
      };

      if (!tags || tags.length === 0) return effects;

      tags.forEach(tag => {
        const tagEffect = TAG_EFFECTS[tag];
        if (!tagEffect) return;

        // Accumulate urgency boost
        if (tagEffect.urgency_boost) {
          effects.urgency_boost += tagEffect.urgency_boost;
        }

        // Collect risk signals
        if (tagEffect.risk_signal) {
          effects.risk_signals.push(tagEffect.risk_signal);
        }

        // Collect recommended actions
        if (tagEffect.recommended_action) {
          effects.recommended_actions.push(tagEffect.recommended_action);
        }

        // Health modifier (most severe wins: red > yellow > null)
        if (tagEffect.health_modifier) {
          if (tagEffect.health_modifier === 'red' ||
              (tagEffect.health_modifier === 'yellow' && effects.health_modifier !== 'red')) {
            effects.health_modifier = tagEffect.health_modifier;
          }
        }

        // Capital ready signals
        if (tagEffect.capital_ready_override) {
          effects.capital_ready_override = true;
        }
        if (tagEffect.capital_ready_boost) {
          effects.capital_ready_boost = true;
        }
      });

      return effects;
    }

    // =============================================
    // OPERATOR TASK ENGINE (Computed Only)
    // =============================================
    // Task types and their base configurations
    // All tasks are computed at runtime - no persistence

    const TASK_TYPES = {
      // Missing Data Tasks
      add_owner: {
        label: 'Add Owner',
        description: 'Practice has no owner assigned',
        recommended_action: 'Add primary owner contact information',
        base_severity: 'high',
        category: 'missing_data'
      },
      add_location: {
        label: 'Add Location',
        description: 'Practice has no location on file',
        recommended_action: 'Add practice address and location details',
        base_severity: 'high',
        category: 'missing_data'
      },
      add_revenue: {
        label: 'Add Revenue',
        description: 'No revenue data recorded for this practice',
        recommended_action: 'Record monthly revenue estimate',
        base_severity: 'high',
        category: 'missing_data'
      },
      // Aging / Stalled Tasks
      follow_up_lead: {
        label: 'Follow Up Lead',
        description: 'Lead has been inactive for 14+ days',
        recommended_action: 'Contact lead or archive if unresponsive',
        base_severity: 'medium',
        category: 'aging'
      },
      resolve_onboarding_stall: {
        label: 'Resolve Onboarding Stall',
        description: 'Onboarding has stalled for 30+ days',
        recommended_action: 'Review blockers and re-engage practice',
        base_severity: 'critical',
        category: 'aging'
      },
      // Onboarding Tasks
      complete_onboarding_item: {
        label: 'Complete Onboarding',
        description: 'Onboarding checklist items incomplete',
        recommended_action: 'Complete remaining checklist items',
        base_severity: 'medium',
        category: 'onboarding'
      },
      // Tag-Driven Tasks
      prioritize_hot_lead: {
        label: 'Prioritize Hot Lead',
        description: 'Practice is marked as a hot lead',
        recommended_action: 'Prioritize outreach immediately',
        base_severity: 'high',
        category: 'tag_driven'
      },
      identify_replacement_physician: {
        label: 'Find Replacement Physician',
        description: 'Replacement doctor needed for acquisition',
        recommended_action: 'Identify and vet replacement physician candidates',
        base_severity: 'high',
        category: 'tag_driven'
      },
      schedule_follow_up: {
        label: 'Schedule Follow-Up',
        description: 'Practice requires follow-up contact',
        recommended_action: 'Schedule and complete follow-up call',
        base_severity: 'medium',
        category: 'tag_driven'
      },
      finalize_closing: {
        label: 'Finalize Closing',
        description: 'Practice is ready to close',
        recommended_action: 'Prepare and finalize closing documents',
        base_severity: 'high',
        category: 'capital'
      },
      // Capital Tasks
      generate_capital_packet: {
        label: 'Generate Capital Packet',
        description: 'Practice is capital-ready',
        recommended_action: 'Generate DD packet for capital raise',
        base_severity: 'medium',
        category: 'capital'
      }
    };

    const SEVERITY_ORDER = {
      critical: 0,
      high: 1,
      medium: 2,
      low: 3
    };

    const SEVERITY_BASE_URGENCY = {
      critical: 100,
      high: 75,
      medium: 50,
      low: 25
    };

    // Ownership Structures (canonical)
    const OWNERSHIP_STRUCTURES = [
      { value: 'Solo', label: 'Solo Practice' },
      { value: 'Partnership', label: 'Partnership' },
      { value: 'Group', label: 'Group Practice' },
      { value: 'DSO/MSO', label: 'DSO/MSO' },
      { value: 'Unknown', label: 'Unknown' }
    ];

    // Person Roles
    const PERSON_ROLES = [
      { value: 'owner', label: 'Owner' },
      { value: 'physician', label: 'Physician' },
      { value: 'admin', label: 'Administrator' },
      { value: 'billing', label: 'Billing Contact' },
      { value: 'manager', label: 'Practice Manager' },
      { value: 'nurse', label: 'Nurse' },
      { value: 'other', label: 'Other' }
    ];

    // Practice-Person Relationship Types (for join table)
    const PRACTICE_PERSON_ROLES = [
      { value: 'owner', label: 'Owner' },
      { value: 'manager', label: 'Manager' },
      { value: 'billing', label: 'Billing Contact' },
      { value: 'primary_contact', label: 'Primary Contact' },
      { value: 'physician', label: 'Physician' },
      { value: 'staff', label: 'Staff' }
    ];

    // Metric Types (enhanced for financial core)
    const METRIC_TYPES = [
      { value: 'monthly_revenue', label: 'Monthly Revenue', category: 'financial' },
      { value: 'revenue', label: 'Revenue (legacy)', category: 'financial' }, // backward compat
      { value: 'ebitda', label: 'EBITDA', category: 'financial' },
      { value: 'ebitda_margin', label: 'EBITDA Margin (%)', category: 'financial' },
      { value: 'collections', label: 'Collections', category: 'financial' },
      { value: 'ar_current', label: 'AR Current', category: 'financial' },
      { value: 'ar_30', label: 'AR 30 Days', category: 'financial' },
      { value: 'ar_60', label: 'AR 60 Days', category: 'financial' },
      { value: 'ar_90', label: 'AR 90 Days', category: 'financial' },
      { value: 'ar_120_plus', label: 'AR 120+ Days', category: 'financial' },
      { value: 'patient_count', label: 'Total Patients', category: 'operational' },
      { value: 'visit_count', label: 'Visit Count', category: 'operational' },
      { value: 'new_patients', label: 'New Patients', category: 'operational' },
      { value: 'provider_fte', label: 'Provider FTE', category: 'operational' }
    ];

    // Event Types (canonical audit trail)
    const EVENT_TYPES = [
      'practice_created', 'practice_edited', 'status_changed',
      'owner_added', 'owner_removed',
      'location_added', 'location_updated', 'location_removed',
      'metric_added', 'metric_updated',
      'note_added', 'note_updated',
      'packet_generated'
    ];

    // Default Onboarding Checklist (v1)
    const DEFAULT_ONBOARDING_CHECKLIST = [
      { key: 'contact_verified', label: 'Contact information verified', status: 'todo' },
      { key: 'financials_received', label: 'Financial statements received', status: 'todo' },
      { key: 'contracts_reviewed', label: 'Contracts reviewed', status: 'todo' },
      { key: 'ehr_access', label: 'EHR access confirmed', status: 'todo' },
      { key: 'credentialing', label: 'Credentialing complete', status: 'todo' },
      { key: 'banking_setup', label: 'Banking setup complete', status: 'todo' }
    ];

    const DOCUMENT_CATEGORIES = [
      { value: 'financial', label: 'Financial Statements' },
      { value: 'contract', label: 'Contracts' },
      { value: 'license', label: 'Licenses & Certifications' },
      { value: 'insurance', label: 'Insurance' },
      { value: 'corporate', label: 'Corporate Documents' },
      { value: 'compliance', label: 'Compliance' },
      { value: 'other', label: 'Other' }
    ];

    const DOCUMENT_STATUSES = ['pending', 'received', 'reviewed', 'approved'];

    // =============================================
    // DATABASE STATE (Practice v1 Schema)
    // =============================================
    let db = {
      practices: [],        // Core practice records (canonical v1)
      practice_people: [],  // Join table: practice <-> person relationships
      people: [],           // Person records
      locations: [],        // Location records
      metrics: [],          // Time-series metrics
      notes: [],            // Notes/comments
      documents: [],        // Document metadata
      events: []            // Audit trail
    };

    let currentView = 'table';
    let selectedPracticeId = null;
    let currentPractice = null;

    // Document Type Registry Cache
    let documentTypeRegistry = {};  // slug -> { label, category, is_financial }
    let documentTypesByCategory = {}; // category -> [{ slug, label }]

    // =============================================
    // ID GENERATORS
    // =============================================
    function generatePracticeId() {
      return 'prc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generatePersonId() {
      return 'per_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateLocationId() {
      return 'loc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateMetricId() {
      return 'met_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateNoteId() {
      return 'not_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateDocumentId() {
      return 'doc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateEventId() {
      return 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generatePracticePersonId() {
      return 'pp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateFinancialDocumentId() {
      return 'fdoc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateFinancialExtractionId() {
      return 'fext_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateFinancialFactId() {
      return 'ffact_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function generateFinancialOverrideId() {
      return 'fover_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Legacy ID generator for backward compat
    function generateId() {
      return generatePracticeId();
    }

    // =============================================
    // DATE FORMATTING HELPERS
    // =============================================
    function formatTimestamp(date) {
      if (!date) return '';
      const d = new Date(date);
      return d.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function formatDateShort(date) {
      if (!date) return '';
      const d = new Date(date);
      return d.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
    }

    function formatDateFull(date) {
      if (!date) return '';
      const d = new Date(date);
      return d.toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      });
    }

    function getCurrentPeriod() {
      const now = new Date();
      return now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
    }

    // =============================================
    // STORAGE MANAGER
    // =============================================
    function loadDb() {
      const stored = localStorage.getItem(DB_STORAGE_KEY);
      if (stored) {
        db = JSON.parse(stored);
        // Ensure all tables exist
        db.practices = db.practices || [];
        db.practice_people = db.practice_people || [];
        db.people = db.people || [];
        db.locations = db.locations || [];
        db.metrics = db.metrics || [];
        db.notes = db.notes || [];
        db.documents = db.documents || [];
        db.events = db.events || [];
        return true;
      }
      return false;
    }

    function saveDb() {
      localStorage.setItem(DB_STORAGE_KEY, JSON.stringify(db));
    }

    // =============================================
    // DATA SOURCE BANNER
    // =============================================
    function updateDataSourceBanner(source, errorMessage = null) {
      const banner = document.getElementById('data-source-banner');
      if (!banner) return;

      banner.classList.remove('supabase', 'local', 'error');

      if (errorMessage) {
        banner.classList.add('error');
        banner.textContent = `Data Source: Local (Supabase failed: ${errorMessage})`;
      } else if (source === 'supabase') {
        banner.classList.add('supabase');
        const orgInfo = window.currentOrgSlug || (window.currentOrgId ? window.currentOrgId.substring(0, 8) : 'unknown');
        banner.textContent = `Data Source: Supabase (Org: ${orgInfo})`;
      } else {
        banner.classList.add('local');
        banner.textContent = 'Data Source: Local';
      }
    }

    // =============================================
    // ORG RESOLUTION
    // =============================================
    window.currentOrgId = null;
    window.currentOrgSlug = null;
    window.currentUserOrgRole = null;

    // =============================================
    // PERMISSIONS HELPER MODULE
    // =============================================

    // Permission mappings: action -> allowed roles
    const PERMISSIONS = {
      // Practice permissions
      CREATE_PRACTICE: ['admin', 'editor'],
      EDIT_PRACTICE: ['admin', 'editor'],
      DELETE_PRACTICE: ['admin'],
      ADVANCE_STATUS: ['admin', 'editor'],
      REGRESS_STATUS: ['admin', 'editor'],

      // People permissions
      CREATE_PERSON: ['admin', 'editor'],
      EDIT_PERSON: ['admin', 'editor'],
      DELETE_PERSON: ['admin'],

      // Notes permissions
      CREATE_NOTE: ['admin', 'editor'],
      EDIT_NOTE: ['admin', 'editor'],
      DELETE_NOTE: ['admin'], // + creator check handled separately

      // Location permissions
      CREATE_LOCATION: ['admin', 'editor'],
      EDIT_LOCATION: ['admin', 'editor'],
      DELETE_LOCATION: ['admin'], // + creator check handled separately

      // Metrics permissions
      CREATE_METRIC: ['admin', 'editor'],
      EDIT_METRIC: ['admin', 'editor'],
      DELETE_METRIC: ['admin'],

      // Admin panel
      VIEW_ADMIN_PANEL: ['admin'],
      MANAGE_USERS: ['admin'],
      APPROVE_REQUESTS: ['admin']
    };

    /**
     * Check if current user has permission for an action
     * @param {string} permission - Permission key from PERMISSIONS
     * @returns {boolean}
     */
    function hasPermission(permission) {
      const role = window.currentUserOrgRole;
      if (!role) return false;

      const allowedRoles = PERMISSIONS[permission];
      if (!allowedRoles) {
        console.warn('Unknown permission:', permission);
        return false;
      }

      return allowedRoles.includes(role);
    }

    /**
     * Check if current user can delete a record they created
     * @param {string} createdByUserId - The user ID who created the record
     * @returns {boolean}
     */
    function canDeleteOwnRecord(createdByUserId) {
      const role = window.currentUserOrgRole;
      const currentUserId = window.currentUser?.id;

      // Admins can delete anything
      if (role === 'admin') return true;

      // Editors can delete their own records
      if (role === 'editor' && currentUserId && createdByUserId === currentUserId) {
        return true;
      }

      return false;
    }

    /**
     * Check if user is read-only (viewer)
     * @returns {boolean}
     */
    function isReadOnly() {
      return window.currentUserOrgRole === 'viewer';
    }

    /**
     * Check if user is admin
     * @returns {boolean}
     */
    function isOrgAdmin() {
      return window.currentUserOrgRole === 'admin';
    }

    /**
     * Check if user is editor
     * @returns {boolean}
     */
    function isOrgEditor() {
      return window.currentUserOrgRole === 'editor';
    }

    /**
     * Show permission denied message
     * @param {string} action - Description of denied action
     */
    function showPermissionDenied(action) {
      alert(`Permission denied: You don't have access to ${action}. Contact your administrator.`);
    }

    function showNoOrgScreen(email) {
      document.getElementById('auth-loading-screen').style.display = 'none';
      document.getElementById('login-screen').style.display = 'none';
      document.getElementById('app-container').classList.remove('authenticated');
      document.getElementById('awaiting-approval-screen').classList.remove('visible');
      document.getElementById('no-org-screen').classList.add('visible');
      document.getElementById('no-org-user-email').textContent = email;
    }

    function hideNoOrgScreen() {
      document.getElementById('no-org-screen').classList.remove('visible');
    }

    async function resolveCurrentOrgId() {
      console.log('[Org] resolving org membership...');

      try {
        const { data: { user } } = await window.sb.auth.getUser();
        if (!user) {
          console.error('[Org] no authenticated user');
          return false;
        }

        // Query org_members for current user
        let { data: membership, error } = await window.sb
          .from('org_members')
          .select('org_id, role')
          .eq('user_id', user.id)
          .limit(1);

        if (error) {
          console.error('[Org] membership query error:', error);
          showNoOrgScreen(user.email);
          return false;
        }

        // If no membership, check for pending invite or allowed_users
        if (!membership || membership.length === 0) {
          console.log('[Org] no org membership, checking for invites...');

          // Check for invite token in URL or sessionStorage
          const urlParams = new URLSearchParams(window.location.search);
          const inviteToken = urlParams.get('invite') || sessionStorage.getItem('pendingInviteToken');

          // Check team_invites for pending invite (by token or email)
          let invite = null;

          if (inviteToken) {
            console.log('[Org] checking invite token:', inviteToken);
            const { data: tokenInvite } = await window.sb
              .from('team_invites')
              .select('*')
              .eq('token', inviteToken)
              .eq('status', 'pending')
              .limit(1);

            if (tokenInvite && tokenInvite.length > 0) {
              invite = tokenInvite[0];
              // Verify email matches
              if (invite.email.toLowerCase() !== user.email.toLowerCase()) {
                console.log('[Org] invite email mismatch');
                sessionStorage.removeItem('pendingInviteToken');
                alert('This invite was sent to a different email address. Please sign in with the correct email.');
                invite = null;
              }
            }
          }

          // If no token invite, check by email
          if (!invite) {
            const { data: emailInvite } = await window.sb
              .from('team_invites')
              .select('*')
              .eq('email', user.email.toLowerCase())
              .eq('status', 'pending')
              .gt('expires_at', new Date().toISOString())
              .order('invited_at', { ascending: false })
              .limit(1);

            if (emailInvite && emailInvite.length > 0) {
              invite = emailInvite[0];
            }
          }

          // If we found a valid invite, accept it
          if (invite) {
            console.log('[Org] found pending invite, accepting...', invite);

            // Check if expired
            if (new Date(invite.expires_at) < new Date()) {
              console.log('[Org] invite expired');
              alert('This invite has expired. Please request a new invite from your administrator.');
            } else {
              // Accept the invite - add to org_members
              const { error: memberError } = await window.sb
                .from('org_members')
                .insert({
                  user_id: user.id,
                  org_id: invite.org_id,
                  role: invite.role,
                  created_at: new Date().toISOString()
                });

              if (!memberError) {
                console.log('[Org] added to org via invite with role:', invite.role);

                // Update invite status to accepted
                await window.sb
                  .from('team_invites')
                  .update({ status: 'accepted', accepted_at: new Date().toISOString() })
                  .eq('id', invite.id);

                // Add to allowed_users so they can log in again
                await window.sb
                  .from('allowed_users')
                  .upsert({ email: user.email.toLowerCase(), role: 'user', is_active: true }, { onConflict: 'email' });

                // Re-fetch membership
                const { data: newMembership } = await window.sb
                  .from('org_members')
                  .select('org_id, role')
                  .eq('user_id', user.id)
                  .limit(1);
                membership = newMembership;

                // Clear invite token from storage and URL
                sessionStorage.removeItem('pendingInviteToken');
                if (urlParams.get('invite')) {
                  window.history.replaceState({}, '', window.location.pathname);
                }
              } else {
                console.error('[Org] failed to add via invite:', memberError);
              }
            }
          }

          // If still no membership, check allowed_users as fallback
          if (!membership || membership.length === 0) {
            console.log('[Org] checking allowed_users...');

            const { data: allowedUser } = await window.sb
              .from('allowed_users')
              .select('email, role, is_active')
              .eq('email', user.email.toLowerCase())
              .eq('is_active', true)
              .limit(1);

            if (allowedUser && allowedUser.length > 0) {
              console.log('[Org] user is approved, auto-adding to default org...');

              // Get the first/default organization
              const { data: defaultOrg } = await window.sb
                .from('organizations')
                .select('id')
                .limit(1);

              if (defaultOrg && defaultOrg.length > 0) {
                // Add user to org_members with default 'editor' role
                const { error: insertError } = await window.sb
                  .from('org_members')
                  .insert({
                    user_id: user.id,
                    org_id: defaultOrg[0].id,
                    role: 'editor', // Default role for auto-added users
                    created_at: new Date().toISOString()
                  });

                if (!insertError) {
                  console.log('[Org] auto-added user to org with editor role');
                  // Re-fetch membership
                  const { data: newMembership } = await window.sb
                    .from('org_members')
                    .select('org_id, role')
                    .eq('user_id', user.id)
                    .limit(1);
                  membership = newMembership;
                } else {
                  console.error('[Org] failed to auto-add user:', insertError);
                }
              }
            }
          }
        }

        if (!membership || membership.length === 0) {
          console.log('[Org] no organization membership found');
          showNoOrgScreen(user.email);
          return false;
        }

        window.currentOrgId = membership[0].org_id;
        window.currentUserOrgRole = membership[0].role;
        console.log('[Org] resolved org_id:', window.currentOrgId, 'role:', window.currentUserOrgRole);

        // Fetch org slug for display
        const { data: orgData } = await window.sb
          .from('organizations')
          .select('slug')
          .eq('id', window.currentOrgId)
          .limit(1);

        if (orgData && orgData.length > 0) {
          window.currentOrgSlug = orgData[0].slug;
          console.log('[Org] resolved org slug:', window.currentOrgSlug);
        }

        return true;
      } catch (err) {
        console.error('[Org] unexpected error:', err);
        return false;
      }
    }

    // =============================================
    // SUPABASE LOADER (org-scoped)
    // =============================================
    async function loadDbFromSupabase() {
      if (!window.currentOrgId) {
        throw new Error('No org_id set - cannot load data');
      }

      const result = {
        practices: [],
        people: [],
        practice_people: [],
        locations: [],
        metrics: [],
        notes: [],
        documents: [],
        events: []
      };

      // Step 1: Fetch org-scoped practices
      console.log('[Supabase] fetching practices for org:', window.currentOrgId);
      const { data: practicesData, error: practicesError } = await window.sb
        .from('practices')
        .select('*')
        .eq('org_id', window.currentOrgId);

      if (practicesError) {
        throw new Error(`Failed to load practices: ${practicesError.message}`);
      }

      result.practices = (practicesData || []).map(row => ({
        id: row.id,
        org_id: row.org_id,
        name: row.legal_name || row.name || '',
        legal_name: row.legal_name || '',
        dba: row.dba || '',
        dba_name: row.dba_name || '',
        specialty: row.specialty || null,
        status: row.status || 'Lead',
        revenue: row.revenue || 0,
        owner: row.owner || '',
        contact_email: row.contact_email || '',
        contact_phone: row.contact_phone || '',
        website: row.website || '',
        address: row.address || '',
        city: row.city || '',
        state: row.state || '',
        zip: row.zip || '',
        ein: row.ein || '',
        npi: row.npi || '',
        year_founded: row.year_founded || null,
        provider_count: row.provider_count || 0,
        staff_count: row.staff_count || 0,
        patient_volume_monthly: row.patient_volume_monthly || 0,
        revenue_model: row.revenue_model || '',
        payer_mix_commercial: row.payer_mix_commercial || 0,
        payer_mix_medicare: row.payer_mix_medicare || 0,
        payer_mix_medicaid: row.payer_mix_medicaid || 0,
        payer_mix_cash: row.payer_mix_cash || 0,
        growth_rate: row.growth_rate || '',
        ebitda_margin: row.ebitda_margin || 0,
        has_emr: row.has_emr || 'Unknown',
        emr_system: row.emr_system || '',
        exit_intent: row.exit_intent || '',
        stay_on_preference: row.stay_on_preference || '',
        source: row.source || '',
        tags: row.tags || [],
        riskFlags: row.risk_flags || row.riskFlags || [],
        years_in_operation: row.years_in_operation,
        num_providers: row.num_providers,
        replacement_doctor_required: row.replacement_doctor_required,
        est_ebitda_margin: row.est_ebitda_margin,
        growth_rate_est: row.growth_rate_est,
        owner_age: row.owner_age,
        owner_exit_intent: row.owner_exit_intent,
        openness_to_rebrand: row.openness_to_rebrand,
        willingness_to_stay_on: row.willingness_to_stay_on,
        created_at: row.created_at || new Date().toISOString(),
        updated_at: row.updated_at || new Date().toISOString(),
        createdAt: row.created_at || new Date().toISOString(),
        updatedAt: row.updated_at || new Date().toISOString()
      }));
      console.log(`[Supabase] fetched practices: ${result.practices.length} rows`);

      // Get practice IDs for scoping child tables
      const practiceIds = result.practices.map(p => p.id);

      if (practiceIds.length === 0) {
        console.log('[Supabase] no practices found, skipping child tables');
        return result;
      }

      // Step 2: Fetch practice_people scoped by practice_ids
      console.log('[Supabase] fetching practice_people...');
      const { data: ppData, error: ppError } = await window.sb
        .from('practice_people')
        .select('*')
        .in('practice_id', practiceIds);

      if (ppError) {
        console.warn('[Supabase] practice_people error:', ppError.message);
      } else {
        result.practice_people = (ppData || []).map(row => ({
          id: row.id,
          practice_id: row.practice_id,
          person_id: row.person_id,
          role: row.role || '',
          is_primary: row.is_primary || false,
          ownership_pct: row.ownership_pct || null,
          createdAt: row.created_at || new Date().toISOString()
        }));
        console.log(`[Supabase] fetched practice_people: ${result.practice_people.length} rows`);
      }

      // Step 3: Fetch people scoped by person_ids from practice_people
      const personIds = [...new Set(result.practice_people.map(pp => pp.person_id))];
      if (personIds.length > 0) {
        console.log('[Supabase] fetching people...');
        const { data: peopleData, error: peopleError } = await window.sb
          .from('people')
          .select('*')
          .in('id', personIds);

        if (peopleError) {
          console.warn('[Supabase] people error:', peopleError.message);
        } else {
          result.people = (peopleData || []).map(row => ({
            id: row.id,
            first_name: row.first_name || '',
            last_name: row.last_name || '',
            email: row.email || '',
            phone: row.phone || '',
            role_type: row.role_type || '',
            credential: row.credential || '',
            npi: row.npi || '',
            specialty: row.specialty || '',
            createdAt: row.created_at || new Date().toISOString(),
            updatedAt: row.updated_at || new Date().toISOString()
          }));
          console.log(`[Supabase] fetched people: ${result.people.length} rows`);
        }
      }

      // Step 4: Fetch locations scoped by practice_ids
      console.log('[Supabase] fetching locations...');
      const { data: locData, error: locError } = await window.sb
        .from('locations')
        .select('*')
        .in('practice_id', practiceIds);

      if (locError) {
        console.warn('[Supabase] locations error:', locError.message);
      } else {
        result.locations = (locData || []).map(row => ({
          id: row.id,
          practice_id: row.practice_id,
          name: row.name || '',
          address1: row.address1 || row.address || '',
          address2: row.address2 || '',
          city: row.city || '',
          state: row.state || '',
          zip: row.zip || '',
          phone: row.phone || '',
          fax: row.fax || '',
          is_primary: row.is_primary || false,
          services: row.services || [],
          created_at: row.created_at || new Date().toISOString(),
          updated_at: row.updated_at || new Date().toISOString()
        }));
        console.log(`[Supabase] fetched locations: ${result.locations.length} rows`);
      }

      // Step 5: Fetch metrics scoped by practice_ids
      console.log('[Supabase] fetching metrics...');
      const { data: metricsData, error: metricsError } = await window.sb
        .from('metrics')
        .select('*')
        .in('practice_id', practiceIds);

      if (metricsError) {
        console.warn('[Supabase] metrics error:', metricsError.message);
      } else {
        result.metrics = (metricsData || []).map(row => ({
          id: row.id,
          practice_id: row.practice_id,
          location_id: row.location_id || null,
          period: row.period || '',
          type: row.type || 'monthly_revenue',
          metric_type: row.type || 'monthly_revenue',
          value: row.value || 0,
          source: row.source || 'user',
          created_at: row.created_at || new Date().toISOString(),
          createdAt: row.created_at || new Date().toISOString()
        }));
        console.log(`[Supabase] fetched metrics: ${result.metrics.length} rows`);
      }

      // Step 6: Fetch notes scoped by practice_ids
      console.log('[Supabase] fetching notes...');
      const { data: notesData, error: notesError } = await window.sb
        .from('notes')
        .select('*')
        .in('practice_id', practiceIds);

      if (notesError) {
        console.warn('[Supabase] notes error:', notesError.message);
      } else {
        result.notes = (notesData || []).map(row => ({
          id: row.id,
          practice_id: row.practice_id,
          content: row.content || '',
          author: row.author || 'System',
          author_id: row.author_id || null,
          is_pinned: row.is_pinned || false,
          createdAt: row.created_at || new Date().toISOString(),
          updated_at: row.updated_at || new Date().toISOString()
        }));
        console.log(`[Supabase] fetched notes: ${result.notes.length} rows`);
      }

      // Step 7: Fetch documents scoped by practice_ids
      console.log('[Supabase] fetching documents...');
      const { data: docsData, error: docsError } = await window.sb
        .from('documents')
        .select('*')
        .in('practice_id', practiceIds);

      if (docsError) {
        console.warn('[Supabase] documents error:', docsError.message);
      } else {
        result.documents = (docsData || []).map(row => ({
          id: row.id,
          practice_id: row.practice_id,
          name: row.name || '',
          type: row.type || '',
          status: row.status || 'pending',
          url: row.url || '',
          createdAt: row.created_at || new Date().toISOString()
        }));
        console.log(`[Supabase] fetched documents: ${result.documents.length} rows`);
      }

      // Step 8: Fetch events scoped by practice_ids
      console.log('[Supabase] fetching events...');
      const { data: eventsData, error: eventsError } = await window.sb
        .from('events')
        .select('*')
        .in('practice_id', practiceIds);

      if (eventsError) {
        console.warn('[Supabase] events error:', eventsError.message);
      } else {
        result.events = (eventsData || []).map(row => ({
          id: row.id,
          practice_id: row.practice_id,
          event_type: row.event_type || '',
          description: row.description || '',
          metadata: row.metadata || {},
          timestamp: row.timestamp || row.created_at,
          createdAt: row.created_at || new Date().toISOString()
        }));
        console.log(`[Supabase] fetched events: ${result.events.length} rows`);
      }

      return result;
    }

    // =============================================
    // ORG-SCOPED WRITE SAFETY
    // =============================================
    function ensurePracticeInCurrentOrg(practiceId) {
      if (!window.currentOrgId) {
        throw new Error('No org_id set - cannot verify practice ownership');
      }
      const practice = db.practices.find(p => p.id === practiceId);
      if (!practice) {
        throw new Error(`Practice not found: ${practiceId}`);
      }
      if (practice.org_id && practice.org_id !== window.currentOrgId) {
        throw new Error('Cross-org write blocked');
      }
      return true;
    }

    // =============================================
    // SUPABASE WRITE HELPERS (practices only)
    // =============================================

    // Column allowlist for practices table - only these fields will be sent to Supabase
    const PRACTICES_COLUMN_ALLOWLIST = [
      // Core fields
      'id',
      'org_id',
      'created_at',
      'created_by',
      'updated_at',
      'assigned_to',
      'status',
      'specialty',
      'specialty_key',
      'legal_name',
      'dba_name',
      'ownership_structure',
      'primary_location_id',
      'onboarding_state',
      'risk_flags',
      'data_version',
      'tags',
      'source',
      // Original deal context fields
      'years_in_operation',
      'num_providers',
      'replacement_doctor_required',
      'revenue_model',
      'est_ebitda_margin',
      'growth_rate_est',
      'owner_age',
      'owner_exit_intent',
      'openness_to_rebrand',
      'willingness_to_stay_on',
      // Operations
      'num_locations',
      'num_exam_rooms',
      'num_staff_clinical',
      'num_staff_admin',
      'monthly_patient_volume_claimed',
      'new_patients_monthly_claimed',
      'has_telehealth',
      'hours_per_week',
      'accepts_new_patients',
      // Payer Mix
      'payer_mix_commercial',
      'payer_mix_medicare',
      'payer_mix_medicaid',
      'payer_mix_cash',
      'payer_mix_other',
      'top_payers',
      // Technology
      'emr_system',
      'practice_mgmt_system',
      'billing_system',
      'emr_data_exportable',
      // Real Estate
      'real_estate_status',
      'lease_expiration',
      'lease_monthly_rent_claimed',
      'square_footage',
      'facility_condition',
      'expansion_possible',
      // Legal
      'entity_type',
      'state_of_incorporation',
      'tax_id_last4',
      'outstanding_litigation',
      'malpractice_claims_5yr',
      'contracts_assignable',
      // Deal Intent
      'asking_price',
      'deal_structure_pref',
      'seller_financing_available',
      'transition_support_months',
      'earnout_acceptable',
      'exclusivity_status',
      'exclusivity_expires',
      // Quality & Market
      'google_rating_claimed',
      'google_review_count_claimed',
      'accreditations',
      'quality_score_internal',
      'market_position',
      'competition_density',
      'referral_sources'
    ];

    // Track if we've warned about ignored fields (once per page load)
    let _practicesIgnoredFieldsWarned = false;

    // Filter object to only include allowlisted columns
    function filterPracticeRow(row) {
      const filtered = {};
      const ignored = [];

      for (const [key, value] of Object.entries(row)) {
        if (PRACTICES_COLUMN_ALLOWLIST.includes(key)) {
          filtered[key] = value;
        } else {
          ignored.push(key);
        }
      }

      // Warn once per page load about ignored fields
      if (ignored.length > 0 && !_practicesIgnoredFieldsWarned) {
        console.warn('Ignored practice fields not in Supabase allowlist:', ignored);
        _practicesIgnoredFieldsWarned = true;
      }

      return filtered;
    }

    // Convert app practice object to Supabase row format
    function practiceToSupabaseRow(practice) {
      const row = {
        id: practice.id,
        org_id: window.currentOrgId, // Always inject current org
        legal_name: practice.legal_name || practice.name || '',
        dba_name: practice.dba_name || practice.name || '',
        specialty: practice.specialty || null,
        status: practice.status || 'Lead',
        ownership_structure: practice.ownership_structure || 'Unknown',
        revenue_model: practice.revenue_model || null,
        years_in_operation: practice.years_in_operation || null,
        num_providers: practice.num_providers || null,
        replacement_doctor_required: practice.replacement_doctor_required || null,
        est_ebitda_margin: practice.est_ebitda_margin || null,
        growth_rate_est: practice.growth_rate_est || null,
        owner_age: practice.owner_age || null,
        owner_exit_intent: practice.owner_exit_intent || null,
        openness_to_rebrand: practice.openness_to_rebrand || null,
        willingness_to_stay_on: practice.willingness_to_stay_on || null,
        specialty_key: practice.specialty_key || null,
        source: practice.source || null,
        tags: practice.tags || [],
        risk_flags: practice.riskFlags || practice.risk_flags || [],
        onboarding_state: practice.onboarding_state || null,
        assigned_to: practice.assigned_to || null,
        primary_location_id: practice.primary_location_id || null,
        created_at: practice.created_at || practice.createdAt || new Date().toISOString(),
        updated_at: practice.updated_at || practice.updatedAt || new Date().toISOString()
      };

      // Filter to only allowlisted columns
      return filterPracticeRow(row);
    }

    async function supabaseInsertPractice(practice) {
      const row = practiceToSupabaseRow(practice);
      const { data, error } = await window.sb
        .from('practices')
        .insert([row])
        .select();

      if (error) {
        throw new Error(`Insert failed: ${error.message}`);
      }
      return data;
    }

    async function supabaseUpdatePractice(practiceId, updates) {
      // Verify practice belongs to current org before updating
      ensurePracticeInCurrentOrg(practiceId);

      // Build Supabase-compatible update object
      const supabaseUpdates = {};

      // Map app field names to Supabase column names
      // Most fields pass through unchanged via the fallback (fieldMap[key] || key)
      // This map handles legacy/alternate names
      const fieldMap = {
        name: 'legal_name',
        riskFlags: 'risk_flags',
        updatedAt: 'updated_at'
      };

      for (const [key, value] of Object.entries(updates)) {
        const supabaseKey = fieldMap[key] || key;
        supabaseUpdates[supabaseKey] = value;
      }

      // Always update updated_at
      supabaseUpdates.updated_at = new Date().toISOString();

      // Filter to only allowlisted columns
      const filteredUpdates = filterPracticeRow(supabaseUpdates);

      const { data, error } = await window.sb
        .from('practices')
        .update(filteredUpdates)
        .eq('id', practiceId)
        .select();

      if (error) {
        throw new Error(`Update failed: ${error.message}`);
      }
      return data;
    }

    async function supabaseDeletePractice(practiceId) {
      // Verify practice belongs to current org before deleting
      ensurePracticeInCurrentOrg(practiceId);

      const { error } = await window.sb
        .from('practices')
        .delete()
        .eq('id', practiceId);

      if (error) {
        throw new Error(`Delete failed: ${error.message}`);
      }
      return true;
    }

    // =============================================
    // SUPABASE WRITE HELPERS (people)
    // =============================================

    // Column allowlist for people table
    const PEOPLE_COLUMN_ALLOWLIST = [
      'id',
      'created_at',
      'updated_at',
      'first_name',
      'last_name',
      'email',
      'phone',
      'role_type',
      'credential',
      'npi',
      'specialty',
      'org_id'
    ];

    // Track if we've warned about ignored fields (once per page load)
    let _peopleIgnoredFieldsWarned = false;

    // Filter object to only include allowlisted columns
    function filterPeopleRow(row) {
      const filtered = {};
      const ignored = [];

      for (const [key, value] of Object.entries(row)) {
        if (PEOPLE_COLUMN_ALLOWLIST.includes(key)) {
          filtered[key] = value;
        } else {
          ignored.push(key);
        }
      }

      if (ignored.length > 0 && !_peopleIgnoredFieldsWarned) {
        console.warn('Ignored people fields not in Supabase allowlist:', ignored);
        _peopleIgnoredFieldsWarned = true;
      }

      return filtered;
    }

    // Convert app person object to Supabase row format
    function personToSupabaseRow(person) {
      const row = {
        id: person.id,
        first_name: person.first_name || person.firstName || '',
        last_name: person.last_name || person.lastName || '',
        email: person.email || '',
        phone: person.phone || '',
        role_type: person.role_type || null,
        credential: person.credential || null,
        npi: person.npi || null,
        specialty: person.specialty || null,
        created_at: person.created_at || person.createdAt || new Date().toISOString(),
        updated_at: person.updated_at || person.updatedAt || new Date().toISOString(),
        org_id: person.org_id || window.currentOrgId
      };

      return filterPeopleRow(row);
    }

    async function supabaseUpsertPerson(person) {
      const row = personToSupabaseRow(person);

      // Use upsert with onConflict to handle insert-or-update
      const { data, error } = await window.sb
        .from('people')
        .upsert([row], { onConflict: 'id' })
        .select();

      if (error) {
        throw new Error(`Person upsert failed: ${error.message}`);
      }
      return data;
    }

    async function supabaseUpdatePerson(personId, updates) {
      const supabaseUpdates = { ...updates };
      supabaseUpdates.updated_at = new Date().toISOString();

      const filteredUpdates = filterPeopleRow(supabaseUpdates);

      const { data, error } = await window.sb
        .from('people')
        .update(filteredUpdates)
        .eq('id', personId)
        .select();

      if (error) {
        throw new Error(`Person update failed: ${error.message}`);
      }
      return data;
    }

    // =============================================
    // SUPABASE WRITE HELPERS (practice_people)
    // =============================================

    // Column allowlist for practice_people table
    const PRACTICE_PEOPLE_COLUMN_ALLOWLIST = [
      'id',
      'created_at',
      'practice_id',
      'person_id',
      'role',
      'is_primary',
      'ownership_pct',
      'start_date',
      'end_date'
    ];

    // Track if we've warned about ignored fields (once per page load)
    let _practicePeopleIgnoredFieldsWarned = false;

    // Filter object to only include allowlisted columns
    function filterPracticePeopleRow(row) {
      const filtered = {};
      const ignored = [];

      for (const [key, value] of Object.entries(row)) {
        if (PRACTICE_PEOPLE_COLUMN_ALLOWLIST.includes(key)) {
          filtered[key] = value;
        } else {
          ignored.push(key);
        }
      }

      if (ignored.length > 0 && !_practicePeopleIgnoredFieldsWarned) {
        console.warn('Ignored practice_people fields not in Supabase allowlist:', ignored);
        _practicePeopleIgnoredFieldsWarned = true;
      }

      return filtered;
    }

    // Convert app practice_people link to Supabase row format
    function practicePeopleLinkToSupabaseRow(link) {
      const row = {
        id: link.id,
        practice_id: link.practice_id,
        person_id: link.person_id,
        role: link.role || 'owner',
        is_primary: link.is_primary || false,
        ownership_pct: link.ownership_pct || null,
        start_date: link.start_date || null,
        end_date: link.end_date || null,
        created_at: link.created_at || link.createdAt || new Date().toISOString()
      };

      return filterPracticePeopleRow(row);
    }

    async function supabaseUpsertPracticePersonLink(link) {
      const row = practicePeopleLinkToSupabaseRow(link);

      // Use upsert with onConflict to handle insert-or-update
      const { data, error } = await window.sb
        .from('practice_people')
        .upsert([row], { onConflict: 'id' })
        .select();

      if (error) {
        throw new Error(`Practice-person link upsert failed: ${error.message}`);
      }
      return data;
    }

    async function supabaseUpdatePracticePersonLink(linkId, updates) {
      const filteredUpdates = filterPracticePeopleRow(updates);

      const { data, error } = await window.sb
        .from('practice_people')
        .update(filteredUpdates)
        .eq('id', linkId)
        .select();

      if (error) {
        throw new Error(`Practice-person link update failed: ${error.message}`);
      }
      return data;
    }

    // Find existing practice_people link by practice and person
    async function supabaseFindPracticePersonLink(practiceId, personId) {
      const { data, error } = await window.sb
        .from('practice_people')
        .select('*')
        .eq('practice_id', practiceId)
        .eq('person_id', personId)
        .limit(1);

      if (error) {
        throw new Error(`Find link failed: ${error.message}`);
      }
      return data && data.length > 0 ? data[0] : null;
    }

    // =============================================
    // SUPABASE WRITE HELPERS (notes)
    // =============================================

    // Column allowlist for notes table
    const NOTES_COLUMN_ALLOWLIST = [
      'id',
      'practice_id',
      'author_id',
      'content',
      'is_pinned',
      'created_at',
      'updated_at',
      'org_id',
      'created_by_user_id'
    ];

    // Track if we've warned about ignored fields (once per page load)
    let _notesIgnoredFieldsWarned = false;

    // Filter object to only include allowlisted columns
    function filterNoteRow(row) {
      const filtered = {};
      const ignored = [];

      for (const [key, value] of Object.entries(row)) {
        if (NOTES_COLUMN_ALLOWLIST.includes(key)) {
          filtered[key] = value;
        } else {
          ignored.push(key);
        }
      }

      if (ignored.length > 0 && !_notesIgnoredFieldsWarned) {
        console.warn('Ignored notes fields not in Supabase allowlist:', ignored);
        _notesIgnoredFieldsWarned = true;
      }

      return filtered;
    }

    // Convert app note object to Supabase row format
    function noteToSupabaseRow(note) {
      const row = {
        id: note.id,
        practice_id: note.practice_id || note.practiceId,
        author_id: note.author_id || note.authorId || null,
        content: note.content || '',
        is_pinned: note.is_pinned || note.isPinned || false,
        created_at: note.created_at || note.createdAt || new Date().toISOString(),
        updated_at: note.updated_at || note.updatedAt || new Date().toISOString(),
        org_id: note.org_id || window.currentOrgId,
        created_by_user_id: note.created_by_user_id || window.currentUser?.id || null
      };

      return filterNoteRow(row);
    }

    async function supabaseInsertNote(note) {
      const row = noteToSupabaseRow(note);

      const { data, error } = await window.sb
        .from('notes')
        .insert([row])
        .select();

      if (error) {
        throw new Error(`Note insert failed: ${error.message}`);
      }
      return data;
    }

    async function supabaseUpdateNote(noteId, updates) {
      const supabaseUpdates = { ...updates };
      supabaseUpdates.updated_at = new Date().toISOString();

      const filteredUpdates = filterNoteRow(supabaseUpdates);

      const { data, error } = await window.sb
        .from('notes')
        .update(filteredUpdates)
        .eq('id', noteId)
        .select();

      if (error) {
        throw new Error(`Note update failed: ${error.message}`);
      }
      return data;
    }

    async function supabaseDeleteNote(noteId) {
      const { error } = await window.sb
        .from('notes')
        .delete()
        .eq('id', noteId);

      if (error) {
        throw new Error(`Note delete failed: ${error.message}`);
      }
      return true;
    }

    // =============================================
    // SUPABASE WRITE HELPERS (events)
    // =============================================

    // Column allowlist for events table
    const EVENTS_COLUMN_ALLOWLIST = [
      'id',
      'practice_id',
      'event_type',
      'actor_id',
      'timestamp',
      'payload',
      'org_id'
    ];

    // Track if we've warned about ignored fields (once per page load)
    let _eventsIgnoredFieldsWarned = false;

    // Filter object to only include allowlisted columns
    function filterEventRow(row) {
      const filtered = {};
      const ignored = [];

      for (const [key, value] of Object.entries(row)) {
        if (EVENTS_COLUMN_ALLOWLIST.includes(key)) {
          filtered[key] = value;
        } else {
          ignored.push(key);
        }
      }

      if (ignored.length > 0 && !_eventsIgnoredFieldsWarned) {
        console.warn('Ignored events fields not in Supabase allowlist:', ignored);
        _eventsIgnoredFieldsWarned = true;
      }

      return filtered;
    }

    // Convert app event object to Supabase row format
    function eventToSupabaseRow(event) {
      const row = {
        id: event.id,
        practice_id: event.practice_id || event.practiceId || null,
        event_type: event.event_type || event.eventType || 'unknown',
        actor_id: event.actor_id || event.actorId || null,
        timestamp: event.timestamp || new Date().toISOString(),
        payload: event.payload || null,
        org_id: event.org_id || window.currentOrgId
      };

      return filterEventRow(row);
    }

    async function supabaseInsertEvent(event) {
      const row = eventToSupabaseRow(event);

      const { data, error } = await window.sb
        .from('events')
        .insert([row])
        .select();

      if (error) {
        throw new Error(`Event insert failed: ${error.message}`);
      }
      return data;
    }

    // =============================================
    // SUPABASE WRITE HELPERS (metrics)
    // =============================================

    // Column allowlist for metrics table
    const METRICS_COLUMN_ALLOWLIST = [
      'id',
      'practice_id',
      'location_id',
      'period',
      'type',
      'value',
      'source',
      'created_at',
      'org_id'
    ];

    // Track if we've warned about ignored fields (once per page load)
    let _metricsIgnoredFieldsWarned = false;

    // Filter object to only include allowlisted columns
    function filterMetricRow(row) {
      const filtered = {};
      const ignored = [];

      for (const [key, value] of Object.entries(row)) {
        if (METRICS_COLUMN_ALLOWLIST.includes(key)) {
          filtered[key] = value;
        } else {
          ignored.push(key);
        }
      }

      if (ignored.length > 0 && !_metricsIgnoredFieldsWarned) {
        console.warn('Ignored metrics fields not in Supabase allowlist:', ignored);
        _metricsIgnoredFieldsWarned = true;
      }

      return filtered;
    }

    // Get current period as YYYY-MM
    function getCurrentPeriodYYYYMM() {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      return `${year}-${month}`;
    }

    // Convert app metric object to Supabase row format
    function metricToSupabaseRow(metric) {
      const row = {
        id: metric.id,
        practice_id: metric.practice_id || metric.practiceId,
        location_id: metric.location_id || metric.locationId || null,
        period: metric.period || getCurrentPeriodYYYYMM(),
        type: metric.type || metric.metric_type || 'monthly_revenue',
        value: typeof metric.value === 'number' ? metric.value : parseFloat(metric.value) || 0,
        source: metric.source || 'user',
        created_at: metric.created_at || metric.createdAt || new Date().toISOString(),
        org_id: metric.org_id || window.currentOrgId
      };

      return filterMetricRow(row);
    }

    // Upsert metric - select then insert/update pattern
    async function supabaseUpsertMetric(metric) {
      const practiceId = metric.practice_id || metric.practiceId;
      const metricType = metric.type || metric.metric_type || 'monthly_revenue';
      const period = metric.period || getCurrentPeriodYYYYMM();

      // Check if metric exists for this practice+type+period
      const { data: existing, error: selectError } = await window.sb
        .from('metrics')
        .select('id')
        .eq('practice_id', practiceId)
        .eq('type', metricType)
        .eq('period', period)
        .limit(1);

      if (selectError) {
        throw new Error(`Metric lookup failed: ${selectError.message}`);
      }

      if (existing && existing.length > 0) {
        // Update existing metric
        const filteredUpdates = filterMetricRow({
          value: typeof metric.value === 'number' ? metric.value : parseFloat(metric.value) || 0,
          source: metric.source || 'user'
        });

        const { data, error } = await window.sb
          .from('metrics')
          .update(filteredUpdates)
          .eq('id', existing[0].id)
          .select();

        if (error) {
          throw new Error(`Metric update failed: ${error.message}`);
        }
        return data;
      } else {
        // Insert new metric
        const row = metricToSupabaseRow({
          ...metric,
          id: metric.id || generateMetricId(),
          practice_id: practiceId,
          type: metricType,
          period: period
        });

        const { data, error } = await window.sb
          .from('metrics')
          .insert([row])
          .select();

        if (error) {
          throw new Error(`Metric insert failed: ${error.message}`);
        }
        return data;
      }
    }

    // =============================================
    // SUPABASE WRITE HELPERS (locations)
    // =============================================

    // Column allowlist for locations table
    const LOCATIONS_COLUMN_ALLOWLIST = [
      'id',
      'practice_id',
      'name',
      'address1',
      'address2',
      'city',
      'state',
      'zip',
      'phone',
      'fax',
      'is_primary',
      'services',
      'created_at',
      'updated_at',
      'org_id',
      'created_by_user_id'
    ];

    // Track if we've warned about ignored fields (once per page load)
    let _locationsIgnoredFieldsWarned = false;

    // Filter object to only include allowlisted columns
    function filterLocationRow(row) {
      const filtered = {};
      const ignored = [];

      for (const [key, value] of Object.entries(row)) {
        if (LOCATIONS_COLUMN_ALLOWLIST.includes(key)) {
          filtered[key] = value;
        } else {
          ignored.push(key);
        }
      }

      if (ignored.length > 0 && !_locationsIgnoredFieldsWarned) {
        console.warn('Ignored locations fields not in Supabase allowlist:', ignored);
        _locationsIgnoredFieldsWarned = true;
      }

      return filtered;
    }

    // Convert app location object to Supabase row format
    function locationToSupabaseRow(location) {
      const row = {
        id: location.id,
        practice_id: location.practice_id || location.practiceId,
        name: location.name || '',
        address1: location.address1 || location.address || '',
        address2: location.address2 || '',
        city: location.city || '',
        state: location.state || '',
        zip: location.zip || '',
        phone: location.phone || '',
        fax: location.fax || '',
        is_primary: location.is_primary || location.isPrimary || false,
        services: location.services || [],
        created_at: location.created_at || location.createdAt || new Date().toISOString(),
        updated_at: location.updated_at || location.updatedAt || new Date().toISOString(),
        org_id: location.org_id || window.currentOrgId,
        created_by_user_id: location.created_by_user_id || window.currentUser?.id || null
      };

      return filterLocationRow(row);
    }

    // Upsert location - select then insert/update pattern
    async function supabaseUpsertLocation(location) {
      const locationId = location.id;

      // Check if location exists
      const { data: existing, error: selectError } = await window.sb
        .from('locations')
        .select('id')
        .eq('id', locationId)
        .limit(1);

      if (selectError) {
        throw new Error(`Location lookup failed: ${selectError.message}`);
      }

      if (existing && existing.length > 0) {
        // Update existing location
        const row = locationToSupabaseRow(location);
        row.updated_at = new Date().toISOString();

        const { data, error } = await window.sb
          .from('locations')
          .update(row)
          .eq('id', locationId)
          .select();

        if (error) {
          throw new Error(`Location update failed: ${error.message}`);
        }
        return data;
      } else {
        // Insert new location
        const row = locationToSupabaseRow(location);

        const { data, error } = await window.sb
          .from('locations')
          .insert([row])
          .select();

        if (error) {
          throw new Error(`Location insert failed: ${error.message}`);
        }
        return data;
      }
    }

    async function supabaseDeleteLocation(locationId) {
      const { error } = await window.sb
        .from('locations')
        .delete()
        .eq('id', locationId);

      if (error) {
        throw new Error(`Location delete failed: ${error.message}`);
      }
      return true;
    }

    // Get locations for a practice
    function getLocationsByPractice(practiceId) {
      return db.locations
        .filter(l => l.practice_id === practiceId)
        .sort((a, b) => {
          // Primary location first
          if (a.is_primary && !b.is_primary) return -1;
          if (!a.is_primary && b.is_primary) return 1;
          return (a.name || '').localeCompare(b.name || '');
        });
    }

    // Get primary location for a practice
    function getPrimaryLocation(practiceId) {
      const locations = getLocationsByPractice(practiceId);
      return locations.find(l => l.is_primary) || locations[0] || null;
    }

    // Helper to refresh from Supabase and re-render
    async function refreshFromSupabase() {
      try {
        db = await loadDbFromSupabase();
        renderAll();
        return true;
      } catch (error) {
        console.error('Failed to refresh from Supabase:', error);
        updateDataSourceBanner('local', 'Refresh failed: ' + error.message);
        return false;
      }
    }

    // Show write error in banner
    function showSupabaseWriteError(errorMessage) {
      const banner = document.getElementById('data-source-banner');
      if (!banner) return;
      banner.classList.remove('supabase', 'local');
      banner.classList.add('error');
      banner.textContent = `Supabase write failed: ${errorMessage}`;
    }

    function insertRecord(tableName, record) {
      if (!db[tableName]) {
        console.error('Unknown table:', tableName);
        return null;
      }
      db[tableName].push(record);
      saveDb();
      return record;
    }

    function updateRecord(tableName, id, updates) {
      const table = db[tableName];
      if (!table) return null;

      const index = table.findIndex(r => r.id === id);
      if (index === -1) return null;

      table[index] = { ...table[index], ...updates, updatedAt: new Date().toISOString() };
      saveDb();
      return table[index];
    }

    function deleteRecord(tableName, id) {
      const table = db[tableName];
      if (!table) return false;

      const index = table.findIndex(r => r.id === id);
      if (index === -1) return false;

      table.splice(index, 1);
      saveDb();
      return true;
    }

    // =============================================
    // QUERY HELPERS
    // =============================================
    function getPracticeById(id) {
      return db.practices.find(p => p.id === id);
    }

    function getPracticeIndexById(id) {
      return db.practices.findIndex(p => p.id === id);
    }

    // ---- Practice-People Join Table Helpers ----
    function getPracticePersonLinks(practiceId) {
      return db.practice_people.filter(pp => pp.practice_id === practiceId);
    }

    function getPersonPracticeLinks(personId) {
      return db.practice_people.filter(pp => pp.person_id === personId);
    }

    function getOwnersByPracticeViaJoin(practiceId) {
      const links = db.practice_people.filter(pp => pp.practice_id === practiceId && pp.role === 'owner');
      return links.map(link => {
        const person = db.people.find(p => p.id === link.person_id);
        return person ? { ...person, ownership_pct: link.ownership_pct, is_primary: link.is_primary } : null;
      }).filter(Boolean);
    }

    function getPrimaryOwnerViaJoin(practiceId) {
      const link = db.practice_people.find(pp =>
        pp.practice_id === practiceId && pp.role === 'owner' && pp.is_primary
      );
      if (!link) return null;
      const person = db.people.find(p => p.id === link.person_id);
      return person ? { ...person, ownership_pct: link.ownership_pct, is_primary: link.is_primary } : null;
    }

    function addPracticePersonLink(practiceId, personId, role, isPrimary = false, ownershipPct = null) {
      const link = {
        id: generatePracticePersonId(),
        practice_id: practiceId,
        person_id: personId,
        role: role,
        is_primary: isPrimary,
        ownership_pct: ownershipPct,
        created_at: new Date().toISOString()
      };
      insertRecord('practice_people', link);
      return link;
    }

    // ---- People Helpers (snake_case) ----
    function getPeopleByPractice(practiceId) {
      // Use join table - get all people linked to this practice
      const links = getPracticePersonLinks(practiceId);
      return links.map(link => db.people.find(p => p.id === link.person_id)).filter(Boolean);
    }

    function getOwnersByPractice(practiceId) {
      return getOwnersByPracticeViaJoin(practiceId);
    }

    function getPrimaryOwner(practiceId) {
      return getPrimaryOwnerViaJoin(practiceId);
    }

    // ---- Location Helpers (snake_case) ----
    function getLocationsByPractice(practiceId) {
      return db.locations.filter(l => l.practice_id === practiceId);
    }

    function getPrimaryLocation(practiceId) {
      // First try practice.primary_location_id
      const practice = getPracticeById(practiceId);
      if (practice && practice.primary_location_id) {
        const loc = db.locations.find(l => l.id === practice.primary_location_id);
        if (loc) return loc;
      }
      // Fall back to is_primary flag
      return db.locations.find(l => l.practice_id === practiceId && l.is_primary);
    }

    // ---- Metrics Helpers (snake_case, metric_type) ----
    function getMetricsByPractice(practiceId, period = null) {
      let metrics = db.metrics.filter(m => m.practice_id === practiceId);
      if (period) {
        metrics = metrics.filter(m => m.period === period);
      }
      return metrics;
    }

    function getLatestMetric(practiceId, metricType) {
      const metrics = db.metrics
        .filter(m => m.practice_id === practiceId &&
          (m.metric_type === metricType || m.type === metricType))
        .sort((a, b) => (b.period || '').localeCompare(a.period || ''));
      return metrics[0] || null;
    }

    function getMetricHistory(practiceId, metricType, limit = 12) {
      return db.metrics
        .filter(m => m.practice_id === practiceId &&
          (m.metric_type === metricType || m.type === metricType))
        .sort((a, b) => (b.period || '').localeCompare(a.period || ''))
        .slice(0, limit);
    }

    function getLatestRevenue(practiceId) {
      // Check monthly_revenue first
      const metric = getLatestMetric(practiceId, 'monthly_revenue');
      return metric ? metric.value : 0;
    }

    function getRevenueHistory(practiceId, months = 6) {
      return getMetricHistory(practiceId, 'monthly_revenue', months);
    }

    // ---- Notes Helpers (snake_case) ----
    function getNotesByPractice(practiceId) {
      return db.notes
        .filter(n => n.practice_id === practiceId)
        .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
    }

    function getLatestNote(practiceId) {
      const notes = getNotesByPractice(practiceId);
      return notes[0] || null;
    }

    function getPinnedNotes(practiceId) {
      return db.notes.filter(n => n.practice_id === practiceId && n.is_pinned);
    }

    // ---- Documents Helpers (snake_case) ----
    function getDocumentsByPractice(practiceId) {
      return db.documents.filter(d => d.practice_id === practiceId);
    }

    function getDocumentsByCategory(practiceId, category) {
      return db.documents.filter(d => d.practice_id === practiceId && d.category === category);
    }

    // ---- Events Helpers (snake_case) ----
    function getEventsByPractice(practiceId) {
      return db.events
        .filter(e => e.practice_id === practiceId)
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    }

    function getEventsByType(practiceId, eventType) {
      return db.events
        .filter(e => e.practice_id === practiceId && e.event_type === eventType)
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    }

    // =============================================
    // BACKWARD COMPATIBILITY LAYER
    // =============================================
    // Returns practice data in computed display format for UI
    // All values are derived from canonical snake_case records
    function getPracticeDisplayData(practiceId) {
      const practice = getPracticeById(practiceId);
      if (!practice) return null;

      const primaryOwner = getPrimaryOwner(practiceId);
      const latestRevenue = getLatestRevenue(practiceId);
      const latestNote = getLatestNote(practiceId);
      const events = getEventsByPractice(practiceId);

      // Convert events to activityLog format for UI (from canonical snake_case fields)
      const activityLog = events.map(e => {
        const eventType = e.event_type || '';
        return {
          timestamp: e.timestamp,
          action: eventType.charAt(0).toUpperCase() + eventType.slice(1).replace(/_/g, ' '),
          details: formatEventDetails(e)
        };
      });

      // Compute owner display name from canonical snake_case fields
      const ownerName = primaryOwner
        ? `${primaryOwner.first_name || ''} ${primaryOwner.last_name || ''}`.trim()
        : '';

      return {
        ...practice,
        // Computed display fields (NOT stored, derived from canonical records)
        name: practice.dba_name || practice.legal_name || '',  // Computed for backward compat
        owner: ownerName,
        revenue: latestRevenue,
        notes: latestNote ? latestNote.content : '',
        activityLog: activityLog
      };
    }

    function formatEventDetails(event) {
      const eventType = event.event_type || '';
      const payload = event.payload || {};

      if (eventType === 'status_changed' && payload.old !== undefined) {
        return `${payload.old || ''}  ${payload.new || ''}`;
      }
      if (eventType === 'practice_created' || eventType === 'created') {
        return 'Practice record created';
      }
      if (eventType === 'practice_updated' || eventType === 'updated') {
        if (payload && typeof payload === 'object') {
          const changeList = Object.keys(payload)
            .filter(k => payload[k] && payload[k].old !== undefined)
            .map(k => `${k}: ${payload[k].old}  ${payload[k].new}`)
            .join('; ');
          return changeList || 'Record updated';
        }
        return 'Record updated';
      }
      if (eventType === 'owner_added') {
        return `Owner added: ${payload.name || 'Unknown'}`;
      }
      if (eventType === 'metric_added') {
        return `Metric added: ${payload.type || 'Unknown'}`;
      }
      if (eventType === 'note_added') {
        return 'Note added';
      }
      return payload.details || eventType.replace(/_/g, ' ') || '';
    }

    // Get all practices in display format (for table/pipeline)
    function getAllPracticesDisplay() {
      return db.practices.map(p => getPracticeDisplayData(p.id));
    }

    // Legacy compatibility getter
    function getPractices() {
      return getAllPracticesDisplay();
    }

    // =============================================
    // EVENT LOGGING (Canonical Audit Trail)
    // =============================================
    // Standard event types: practice_created, practice_edited, status_changed,
    // owner_added, owner_removed, location_added, location_updated, location_removed,
    // metric_added, metric_updated, note_added, note_updated, packet_generated

    function logEvent(practiceId, eventType, payload = null, actorId = null) {
      const now = new Date().toISOString();
      const event = createCanonicalEvent({
        practice_id: practiceId,
        event_type: eventType,
        actor_id: actorId,
        timestamp: now,
        payload: payload
      }, now);
      // NO legacy fields - use canonical snake_case only

      // Supabase write path (fire-and-forget, errors logged but don't block)
      if (DATA_SOURCE === 'supabase') {
        supabaseInsertEvent(event).then(() => {
          console.log('Event logged to Supabase:', eventType);
        }).catch((error) => {
          console.error('Failed to log event to Supabase:', error);
          // Don't show banner for event logging failures - they're non-critical
        });
        // Also insert locally for immediate UI update
        db.events.push(event);
        return event;
      }

      // Local storage path
      insertRecord('events', event);
      return event;
    }

    // Legacy function for backward compat
    function addActivityLogEntry(practiceOrId, action, details) {
      const practiceId = typeof practiceOrId === 'string' ? practiceOrId : practiceOrId.id;

      // Map old action names to new event_type format
      const actionMap = {
        'Created': 'practice_created',
        'Edited': 'practice_edited',
        'Status Changed': 'status_changed',
        'Deleted': 'practice_deleted'
      };

      const eventType = actionMap[action] || action.toLowerCase().replace(' ', '_');
      logEvent(practiceId, eventType, { details: details });
    }

    // =============================================
    // RISK FLAGS COMPUTATION
    // =============================================
    function computePracticeRiskFlags(practiceId) {
      const practice = getPracticeById(practiceId);
      if (!practice) return { missing_fields: [], aging_flags: [], computed_at: new Date().toISOString() };

      const missing_fields = [];
      const aging_flags = [];

      // Check for missing fields
      if (!practice.legal_name || practice.legal_name.trim() === '') {
        missing_fields.push('legal_name');
      }
      if (!practice.dba_name || practice.dba_name.trim() === '') {
        missing_fields.push('dba_name');
      }
      if (!practice.specialty || practice.specialty.trim() === '') {
        missing_fields.push('specialty');
      }

      // Check for at least 1 owner
      const owners = getOwnersByPractice(practiceId);
      if (owners.length === 0) {
        missing_fields.push('owner');
      }

      // Check for at least 1 location
      const locations = getLocationsByPractice(practiceId);
      if (locations.length === 0) {
        missing_fields.push('location');
      }

      // Check for latest monthly_revenue
      const latestRevenue = getLatestRevenue(practiceId);
      if (!latestRevenue || latestRevenue === 0) {
        missing_fields.push('monthly_revenue');
      }

      // Check aging flags (use canonical created_at field)
      const now = new Date();
      const createdAt = new Date(practice.created_at);
      const daysSinceCreated = Math.floor((now - createdAt) / (1000 * 60 * 60 * 24));

      // Lead older than 14 days since created_at -> stale_lead_14d
      if (practice.status === 'Lead' && daysSinceCreated > 14) {
        aging_flags.push('stale_lead_14d');
      }

      // Onboarding older than 30 days since status change -> stale_onboarding_30d
      if (practice.status === 'Onboarding') {
        // Try to find the last status_changed event (use canonical event_type)
        const statusEvents = db.events.filter(e =>
          e.practice_id === practiceId &&
          e.event_type === 'status_changed'
        ).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        let daysSinceStatusChange = daysSinceCreated; // Default to days since created
        if (statusEvents.length > 0) {
          const lastStatusChange = new Date(statusEvents[0].timestamp);
          daysSinceStatusChange = Math.floor((now - lastStatusChange) / (1000 * 60 * 60 * 24));
        }

        if (daysSinceStatusChange > 30) {
          aging_flags.push('stale_onboarding_30d');
        }
      }

      return {
        missing_fields,
        aging_flags,
        computed_at: new Date().toISOString()
      };
    }

    function updatePracticeRiskFlags(practiceId) {
      const riskFlags = computePracticeRiskFlags(practiceId);
      const practice = getPracticeById(practiceId);
      if (practice) {
        practice.risk_flags = riskFlags;
        saveDb();
      }
      return riskFlags;
    }

    // Recompute risk flags after relevant changes
    function recomputeRiskFlagsAfterChange(practiceId) {
      updatePracticeRiskFlags(practiceId);
    }

    // =============================================
    // PRACTICE INTELLIGENCE (Computed-only)
    // =============================================
    // Computes practice health score, risks, and recommendations
    // No persistence - recomputes on every call

    /**
     * computePracticeIntelligence(practice_id)
     *
     * Returns computed intelligence about a practice:
     * - completeness_score: 0-100% based on data completeness
     * - health: 'green' | 'yellow' | 'red' based on score + risks
     * - risks: Human-readable risk explanations
     * - next_actions: Top 3 recommended actions
     *
     * Score Calculation:
     * - Base fields (legal_name, dba_name, specialty): 15 pts each (45 total)
     * - Owner present: 20 pts
     * - Location present: 15 pts
     * - Revenue metric present: 10 pts
     * - Onboarding checklist progress: 10 pts (proportional)
     *
     * Health Badge:
     * - Green: score >= 80 AND no aging_flags
     * - Yellow: score >= 50 OR has aging_flags
     * - Red: score < 50 OR has critical aging_flags
     */
    function computePracticeIntelligence(practiceId) {
      const practice = getPracticeById(practiceId);
      if (!practice) {
        return {
          completeness_score: 0,
          health: 'red',
          risks: ['Practice not found'],
          next_actions: ['Verify practice exists']
        };
      }

      // Recompute fresh risk flags
      const riskFlags = computePracticeRiskFlags(practiceId);
      const missing = riskFlags.missing_fields || [];
      const aging = riskFlags.aging_flags || [];

      // ========== COMPLETENESS SCORE ==========
      let score = 0;
      const scoreBreakdown = {};

      // Base fields: 15 pts each (45 total)
      if (practice.legal_name && practice.legal_name.trim()) {
        score += 15;
        scoreBreakdown.legal_name = 15;
      }
      if (practice.dba_name && practice.dba_name.trim()) {
        score += 15;
        scoreBreakdown.dba_name = 15;
      }
      if (practice.specialty && practice.specialty.trim()) {
        score += 15;
        scoreBreakdown.specialty = 15;
      }

      // Owner present: 20 pts
      const owners = getOwnersByPractice(practiceId);
      if (owners.length > 0) {
        score += 20;
        scoreBreakdown.owner = 20;
      }

      // Location present: 15 pts
      const locations = getLocationsByPractice(practiceId);
      if (locations.length > 0) {
        score += 15;
        scoreBreakdown.location = 15;
      }

      // Revenue metric present: 10 pts
      const latestRevenue = getLatestRevenue(practiceId);
      if (latestRevenue && latestRevenue > 0) {
        score += 10;
        scoreBreakdown.revenue = 10;
      }

      // Onboarding checklist progress: 10 pts (proportional)
      const onboardingState = practice.onboarding_state || {};
      const checklistItems = onboardingState.items || [];
      if (checklistItems.length > 0) {
        const completedItems = checklistItems.filter(item => item.completed).length;
        const checklistScore = Math.round((completedItems / checklistItems.length) * 10);
        score += checklistScore;
        scoreBreakdown.checklist = checklistScore;
      } else {
        // No checklist items = assume complete for scoring
        score += 10;
        scoreBreakdown.checklist = 10;
      }

      // ========== TAG EFFECTS ==========
      const tagEffects = computeTagEffects(practice.tags || []);

      // ========== HUMAN-READABLE RISKS ==========
      const risks = [];

      // Tag-derived risk signals (highest priority)
      tagEffects.risk_signals.forEach(signal => {
        risks.push(signal);
      });

      // Missing field risks
      const fieldLabels = {
        legal_name: 'Legal name is missing',
        dba_name: 'DBA/Practice name is missing',
        specialty: 'Specialty is not set',
        owner: 'No owner assigned to practice',
        location: 'No location on file',
        monthly_revenue: 'No revenue data recorded'
      };

      missing.forEach(field => {
        if (fieldLabels[field]) {
          risks.push(fieldLabels[field]);
        }
      });

      // Aging flag risks
      const agingLabels = {
        stale_lead_14d: 'Lead has been inactive for 14+ days',
        stale_onboarding_30d: 'Onboarding stalled for 30+ days'
      };

      aging.forEach(flag => {
        if (agingLabels[flag]) {
          risks.push(agingLabels[flag]);
        }
      });

      // ========== HEALTH BADGE ==========
      let health = 'green';

      // Red conditions
      if (score < 50 || aging.includes('stale_onboarding_30d')) {
        health = 'red';
      }
      // Yellow conditions
      else if (score < 80 || aging.length > 0) {
        health = 'yellow';
      }

      // Apply tag-derived health modifier (can only downgrade, never upgrade)
      if (tagEffects.health_modifier) {
        if (tagEffects.health_modifier === 'red') {
          health = 'red';
        } else if (tagEffects.health_modifier === 'yellow' && health === 'green') {
          health = 'yellow';
        }
      }

      // ========== RECOMMENDED NEXT ACTIONS ==========
      const actions = [];

      // Priority 1: Status-based actions
      if (practice.status === 'Lead') {
        if (missing.includes('owner')) {
          actions.push('Add primary owner contact');
        }
        if (missing.includes('monthly_revenue')) {
          actions.push('Record initial revenue estimate');
        }
        if (score >= 60 && !aging.includes('stale_lead_14d')) {
          actions.push('Advance to Onboarding');
        } else if (aging.includes('stale_lead_14d')) {
          actions.push('Follow up or archive stale lead');
        }
      }

      if (practice.status === 'Onboarding') {
        if (missing.includes('location')) {
          actions.push('Add practice location');
        }
        if (checklistItems.length > 0) {
          const incompleteItems = checklistItems.filter(item => !item.completed);
          if (incompleteItems.length > 0) {
            actions.push(`Complete onboarding checklist (${incompleteItems.length} items remaining)`);
          }
        }
        if (aging.includes('stale_onboarding_30d')) {
          actions.push('Review onboarding blockers');
        }
        if (score >= 80 && aging.length === 0) {
          actions.push('Advance to Active');
        }
      }

      if (practice.status === 'Active') {
        if (missing.includes('monthly_revenue')) {
          actions.push('Update monthly revenue');
        }
        // Active practices in good standing
        if (risks.length === 0) {
          actions.push('Schedule quarterly review');
        }
      }

      // Priority 2: Fill in missing data
      if (missing.includes('legal_name') && !actions.includes('Add primary owner contact')) {
        actions.push('Add legal entity name');
      }
      if (missing.includes('specialty')) {
        actions.push('Set practice specialty');
      }

      // Prepend tag-derived recommended actions (highest priority)
      const tagActions = tagEffects.recommended_actions.filter(a => a); // Filter null
      const allActions = [...tagActions, ...actions];

      // Limit to top 3 actions (tag actions first)
      const topActions = allActions.slice(0, 3);

      // If no actions, provide a default
      if (topActions.length === 0) {
        if (health === 'green') {
          topActions.push('Practice data is complete');
        } else {
          topActions.push('Review practice details');
        }
      }

      return {
        completeness_score: Math.min(100, score),
        health,
        risks,
        next_actions: topActions,
        urgency_boost: tagEffects.urgency_boost,
        capital_ready_override: tagEffects.capital_ready_override,
        capital_ready_boost: tagEffects.capital_ready_boost,
        _debug: { scoreBreakdown, missing, aging, tagEffects }
      };
    }

    /**
     * renderPracticeIntelligence(practiceId)
     * Renders the intelligence panel HTML into #intelligence-panel
     */
    function renderPracticeIntelligence(practiceId) {
      const container = document.getElementById('intelligence-panel');
      if (!container) return;

      const intel = computePracticeIntelligence(practiceId);

      const healthLabels = {
        green: 'Healthy',
        yellow: 'Needs Attention',
        red: 'At Risk'
      };

      const risksHtml = intel.risks.length > 0
        ? `<ul class="risk-list">${intel.risks.map(r => `<li><span>${r}</span></li>`).join('')}</ul>`
        : `<div class="intelligence-empty">No current risks</div>`;

      const actionsHtml = intel.next_actions.length > 0
        ? `<ul class="action-list">${intel.next_actions.map(a => `<li><span>${a}</span></li>`).join('')}</ul>`
        : `<div class="intelligence-empty">No pending actions</div>`;

      container.innerHTML = `
        <div class="intelligence-header">
          <div class="intelligence-score">
            <div class="score-circle ${intel.health}">${intel.completeness_score}%</div>
            <div class="score-label">Completeness</div>
          </div>
          <div class="health-badge ${intel.health}">
            <span class="health-badge-dot"></span>
            ${healthLabels[intel.health]}
          </div>
        </div>
        <div class="intelligence-grid">
          <div class="intelligence-section">
            <h4>Current Risks</h4>
            ${risksHtml}
          </div>
          <div class="intelligence-section">
            <h4>Recommended Actions</h4>
            ${actionsHtml}
          </div>
        </div>
      `;
    }

    // =============================================
    // PORTFOLIO INTELLIGENCE (Aggregated Dashboard)
    // =============================================
    // Aggregates intelligence across all practices
    // No persistence - recomputes on every render

    /**
     * computePortfolioIntelligence()
     *
     * Aggregates practice intelligence across entire portfolio.
     * Reuses computePracticeIntelligence() for each practice.
     *
     * Returns:
     * - summary: Total counts, avg score, health distribution
     * - priorityQueue: Practices sorted by urgency (red first, then yellow, lowest score)
     * - risks: Aggregated risk counts
     * - capitalReady: Practices meeting capital-ready criteria
     */
    function computePortfolioIntelligence() {
      // Use filtered practices if filters are active
      const rawPractices = hasActiveFilters() ? getFilteredPractices() : getPractices();
      const practices = rawPractices.map(p => getPracticeById(p.id)).filter(Boolean);

      // Compute intelligence for each practice
      const practiceIntel = practices.map(p => {
        const intel = computePracticeIntelligence(p.id);
        return {
          id: p.id,
          name: p.dba_name || p.legal_name || 'Unnamed Practice',
          status: p.status,
          tags: p.tags || [],
          ...intel
        };
      });

      // ========== SUMMARY STATS ==========
      const totalPractices = practiceIntel.length;

      // Count by status
      const byStatus = {
        Lead: 0,
        Onboarding: 0,
        Active: 0,
        Exited: 0,
        Archived: 0
      };
      practiceIntel.forEach(p => {
        if (byStatus.hasOwnProperty(p.status)) {
          byStatus[p.status]++;
        }
      });

      // Count by health
      const byHealth = { green: 0, yellow: 0, red: 0 };
      practiceIntel.forEach(p => {
        byHealth[p.health]++;
      });

      // Average score (exclude Exited/Archived from avg)
      const activePractices = practiceIntel.filter(p =>
        !['Exited', 'Archived'].includes(p.status)
      );
      const avgScore = activePractices.length > 0
        ? Math.round(activePractices.reduce((sum, p) => sum + p.completeness_score, 0) / activePractices.length)
        : 0;

      // ========== PRIORITY WORK QUEUE ==========
      // Filter to practices needing attention (exclude Exited/Archived)
      // Also include practices with urgency_boost from tags
      const needsAttention = practiceIntel
        .filter(p => !['Exited', 'Archived'].includes(p.status))
        .filter(p => p.health !== 'green' || p.risks.length > 0 || (p.urgency_boost && p.urgency_boost > 0));

      // Sort: First by urgency_boost (higher first), then health (red < yellow < green), then by score
      const healthPriority = { red: 0, yellow: 1, green: 2 };
      const priorityQueue = needsAttention.sort((a, b) => {
        // First by urgency boost (higher = more urgent = comes first)
        const urgencyA = a.urgency_boost || 0;
        const urgencyB = b.urgency_boost || 0;
        if (urgencyB !== urgencyA) return urgencyB - urgencyA;
        // Then by health (red < yellow < green)
        const healthDiff = healthPriority[a.health] - healthPriority[b.health];
        if (healthDiff !== 0) return healthDiff;
        // Then by score (lowest first)
        return a.completeness_score - b.completeness_score;
      });

      // ========== AGGREGATED RISKS ==========
      const risks = {
        missing_owner: 0,
        missing_location: 0,
        missing_revenue: 0,
        stale_lead_14d: 0,
        stale_onboarding_30d: 0
      };

      practiceIntel.forEach(p => {
        if (['Exited', 'Archived'].includes(p.status)) return;

        const debug = p._debug || {};
        const missing = debug.missing || [];
        const aging = debug.aging || [];

        if (missing.includes('owner')) risks.missing_owner++;
        if (missing.includes('location')) risks.missing_location++;
        if (missing.includes('monthly_revenue')) risks.missing_revenue++;
        if (aging.includes('stale_lead_14d')) risks.stale_lead_14d++;
        if (aging.includes('stale_onboarding_30d')) risks.stale_onboarding_30d++;
      });

      // ========== CAPITAL READINESS ==========
      // Criteria: Score >= 80, Status = Active, No aging flags
      // OR: bank-ready tag overrides to include
      // OR: ready-to-close tag boosts (lower score threshold to 70)
      const capitalReady = practiceIntel.filter(p => {
        const debug = p._debug || {};
        const aging = debug.aging || [];

        // bank-ready tag = always capital ready (override)
        if (p.capital_ready_override) {
          return true;
        }

        // Must be Active and no aging flags
        if (p.status !== 'Active' || aging.length > 0) {
          return false;
        }

        // ready-to-close tag = lower threshold to 70
        const scoreThreshold = p.capital_ready_boost ? 70 : 80;
        return p.completeness_score >= scoreThreshold;
      });

      return {
        summary: {
          total: totalPractices,
          byStatus,
          byHealth,
          avgScore
        },
        priorityQueue,
        risks,
        capitalReady
      };
    }

    /**
     * renderPortfolioIntelligence()
     * Renders the portfolio dashboard into #portfolio-container
     */
    function renderPortfolioIntelligence() {
      const container = document.getElementById('portfolio-container');
      if (!container) return;

      const portfolio = computePortfolioIntelligence();
      const { summary, priorityQueue, risks, capitalReady } = portfolio;

      // ========== KPI CARDS ==========
      const kpisHtml = `
        <div class="portfolio-kpis">
          <div class="kpi-card">
            <div class="kpi-value">${summary.total}</div>
            <div class="kpi-label">Total Practices</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-value">${summary.byStatus.Lead}</div>
            <div class="kpi-label">Leads</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-value">${summary.byStatus.Onboarding}</div>
            <div class="kpi-label">Onboarding</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-value">${summary.byStatus.Active}</div>
            <div class="kpi-label">Active</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-value">${summary.avgScore}%</div>
            <div class="kpi-label">Avg Score</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-value green">${summary.byHealth.green}</div>
            <div class="kpi-label">Healthy</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-value yellow">${summary.byHealth.yellow}</div>
            <div class="kpi-label">Needs Attention</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-value red">${summary.byHealth.red}</div>
            <div class="kpi-label">At Risk</div>
          </div>
        </div>
      `;

      // ========== PRIORITY WORK QUEUE ==========
      const healthLabels = { green: 'OK', yellow: 'Attention', red: 'At Risk' };

      let workQueueRowsHtml = '';
      if (priorityQueue.length === 0) {
        workQueueRowsHtml = '<div class="work-queue-empty">All practices are healthy. Nice work!</div>';
      } else {
        workQueueRowsHtml = priorityQueue.slice(0, 20).map(p => {
          const statusClass = 'status-' + p.status.toLowerCase();
          const topActions = p.next_actions.slice(0, 2);
          const actionsHtml = topActions.map(a => `<span class="action-item">${a}</span>`).join('');

          return `
            <div class="work-queue-row" onclick="openProfile('${p.id}')">
              <div class="wq-name">${p.name}</div>
              <div class="wq-status"><span class="status-badge ${statusClass}">${p.status}</span></div>
              <div class="wq-score ${p.health}">${p.completeness_score}%</div>
              <div>
                <span class="wq-badge ${p.health}">
                  <span class="wq-badge-dot"></span>
                  ${healthLabels[p.health]}
                </span>
              </div>
              <div class="wq-actions">${actionsHtml}</div>
            </div>
          `;
        }).join('');
      }

      const workQueueHtml = `
        <div class="portfolio-section">
          <div class="portfolio-section-header">
            <h3>Priority Work Queue</h3>
            <span class="badge">${priorityQueue.length} practices need attention</span>
          </div>
          <div class="work-queue">
            <div class="work-queue-row work-queue-header">
              <div>Practice</div>
              <div>Status</div>
              <div>Score</div>
              <div>Health</div>
              <div>Next Actions</div>
            </div>
            ${workQueueRowsHtml}
          </div>
        </div>
      `;

      // ========== RISK OVERVIEW ==========
      const riskOverviewHtml = `
        <div class="portfolio-section">
          <div class="portfolio-section-header">
            <h3>Risk Overview</h3>
          </div>
          <div class="risk-overview-grid">
            <div class="risk-overview-item">
              <div class="risk-icon warning">&#128100;</div>
              <div class="risk-details">
                <div class="risk-count">${risks.missing_owner}</div>
                <div class="risk-label">Missing Owner</div>
              </div>
            </div>
            <div class="risk-overview-item">
              <div class="risk-icon warning">&#128205;</div>
              <div class="risk-details">
                <div class="risk-count">${risks.missing_location}</div>
                <div class="risk-label">Missing Location</div>
              </div>
            </div>
            <div class="risk-overview-item">
              <div class="risk-icon warning">&#128176;</div>
              <div class="risk-details">
                <div class="risk-count">${risks.missing_revenue}</div>
                <div class="risk-label">Missing Revenue</div>
              </div>
            </div>
            <div class="risk-overview-item">
              <div class="risk-icon danger">&#9203;</div>
              <div class="risk-details">
                <div class="risk-count">${risks.stale_lead_14d}</div>
                <div class="risk-label">Stale Leads (14d+)</div>
              </div>
            </div>
            <div class="risk-overview-item">
              <div class="risk-icon danger">&#9888;</div>
              <div class="risk-details">
                <div class="risk-count">${risks.stale_onboarding_30d}</div>
                <div class="risk-label">Stale Onboarding (30d+)</div>
              </div>
            </div>
          </div>
        </div>
      `;

      // ========== CAPITAL READINESS ==========
      const capitalReadyHtml = `
        <div class="portfolio-section">
          <div class="portfolio-section-header">
            <h3>Capital Readiness Snapshot</h3>
          </div>
          <div class="capital-ready-section">
            <div class="capital-ready-stat">
              <div class="capital-ready-count">${capitalReady.length}</div>
              <div class="capital-ready-label">
                Capital-Ready Practices
                <small>(Internal Assessment)</small>
              </div>
            </div>
            <div class="capital-ready-criteria">
              <span>Criteria:</span>
              <span>Score &ge; 80%</span>
              <span>Status = Active</span>
              <span>No aging flags</span>
            </div>
          </div>
        </div>
      `;

      // ========== ASSEMBLE DASHBOARD ==========
      container.innerHTML = `
        <div class="portfolio-dashboard">
          ${kpisHtml}
          ${workQueueHtml}
          ${riskOverviewHtml}
          ${capitalReadyHtml}
        </div>
      `;
    }

    // =============================================
    // OPERATOR TASK COMPUTATION (No Persistence)
    // =============================================
    // All tasks are computed at runtime from existing intelligence,
    // risk flags, onboarding state, metrics, and tags.
    // No task data is stored - everything recomputes on load.

    /**
     * computePracticeTasks(practiceId)
     * Generates all tasks for a single practice based on existing signals.
     * Returns an array of task objects (not persisted).
     */
    function computePracticeTasks(practiceId) {
      const practice = getPracticeById(practiceId);
      if (!practice) return [];

      // Skip Exited/Archived practices
      if (['Exited', 'Archived'].includes(practice.status)) return [];

      // Get intelligence data (reuse existing function)
      const intel = computePracticeIntelligence(practiceId);
      const debug = intel._debug || {};
      const missing = debug.missing || [];
      const aging = debug.aging || [];
      const tagEffects = debug.tagEffects || {};

      const tasks = [];
      const practiceName = practice.dba_name || practice.legal_name || 'Unnamed Practice';

      // Helper to create a task object
      // reason: explains WHY this task exists (trust layer)
      function createTask(taskType, reason, customDescription, customSeverity) {
        const config = TASK_TYPES[taskType];
        if (!config) return null;

        const severity = customSeverity || config.base_severity;
        const baseUrgency = SEVERITY_BASE_URGENCY[severity] || 50;

        // Apply tag urgency boost
        const tagBoost = intel.urgency_boost || 0;

        // Apply score penalty (lower score = higher urgency)
        const scorePenalty = Math.max(0, (100 - intel.completeness_score) / 5);

        const urgencyScore = baseUrgency + tagBoost + scorePenalty;

        return {
          task_id: `${practiceId}:${taskType}`,
          practice_id: practiceId,
          practice_name: practiceName,
          practice_status: practice.status,
          task_type: taskType,
          task_label: config.label,
          severity: severity,
          category: config.category,
          description: customDescription || config.description,
          reason: reason,  // Why this task exists (computed, not stored)
          recommended_action: config.recommended_action,
          urgency_score: Math.round(urgencyScore),
          completeness_score: intel.completeness_score,
          health: intel.health
        };
      }

      // ========== A) MISSING DATA TASKS ==========
      if (missing.includes('owner')) {
        const task = createTask('add_owner', 'No owner linked to this practice');
        if (task) tasks.push(task);
      }
      if (missing.includes('location')) {
        const task = createTask('add_location', 'No location on file for this practice');
        if (task) tasks.push(task);
      }
      if (missing.includes('monthly_revenue')) {
        const task = createTask('add_revenue', 'No monthly revenue metric recorded');
        if (task) tasks.push(task);
      }

      // ========== B) AGING / STALLED TASKS ==========
      if (aging.includes('stale_lead_14d')) {
        const task = createTask('follow_up_lead', 'Lead has been inactive for 14+ days');
        if (task) tasks.push(task);
      }
      if (aging.includes('stale_onboarding_30d')) {
        const task = createTask('resolve_onboarding_stall', 'Onboarding inactive for 30+ days');
        if (task) tasks.push(task);
      }

      // ========== C) ONBOARDING CHECKLIST TASKS ==========
      const onboardingState = practice.onboarding_state || {};
      const checklistItems = onboardingState.items || [];
      const incompleteItems = checklistItems.filter(item => !item.completed);

      if (incompleteItems.length > 0 && practice.status === 'Onboarding') {
        // Severity increases with number of incomplete items
        let severity = 'low';
        if (incompleteItems.length >= 5) severity = 'high';
        else if (incompleteItems.length >= 3) severity = 'medium';

        const reason = `${incompleteItems.length} checklist item${incompleteItems.length > 1 ? 's' : ''} still pending`;
        const task = createTask(
          'complete_onboarding_item',
          reason,
          `${incompleteItems.length} onboarding checklist item${incompleteItems.length > 1 ? 's' : ''} incomplete`,
          severity
        );
        if (task) tasks.push(task);
      }

      // ========== D) TAG-DRIVEN TASKS ==========
      const tags = practice.tags || [];

      if (tags.includes('hot-lead')) {
        const task = createTask('prioritize_hot_lead', 'Practice tagged as hot-lead');
        if (task) tasks.push(task);
      }
      if (tags.includes('replacement-doctor')) {
        const task = createTask('identify_replacement_physician', 'Practice tagged as replacement-doctor needed');
        if (task) tasks.push(task);
      }
      if (tags.includes('needs-follow-up')) {
        const task = createTask('schedule_follow_up', 'Practice tagged as needs-follow-up');
        if (task) tasks.push(task);
      }
      if (tags.includes('ready-to-close')) {
        const task = createTask('finalize_closing', 'Practice tagged as ready-to-close');
        if (task) tasks.push(task);
      }

      // ========== E) CAPITAL TASKS ==========
      // Check if practice is capital-ready (using existing logic from portfolio intel)
      const isCapitalReady = (
        intel.capital_ready_override ||
        (practice.status === 'Active' &&
         intel.completeness_score >= (intel.capital_ready_boost ? 70 : 80) &&
         aging.length === 0)
      );

      if (isCapitalReady && !tags.includes('ready-to-close')) {
        // Only add if not already tagged ready-to-close (which has finalize_closing)
        const capitalReason = intel.capital_ready_override
          ? 'Practice has bank-ready tag override'
          : `Practice meets capital-ready criteria (score ${intel.completeness_score}%, Active, no flags)`;
        const task = createTask('generate_capital_packet', capitalReason);
        if (task) tasks.push(task);
      }

      return tasks;
    }

    /**
     * computeOperatorTasks()
     * Aggregates all tasks across all practices.
     * Returns sorted array of tasks for the operator view.
     */
    function computeOperatorTasks() {
      const practices = getPractices();
      let allTasks = [];

      // Generate tasks for each practice
      practices.forEach(practice => {
        const practiceTasks = computePracticeTasks(practice.id);
        allTasks = allTasks.concat(practiceTasks);
      });

      // Sort tasks by: Severity (critical first), Urgency score (desc), Practice score (asc)
      allTasks.sort((a, b) => {
        // First by severity
        const severityDiff = SEVERITY_ORDER[a.severity] - SEVERITY_ORDER[b.severity];
        if (severityDiff !== 0) return severityDiff;

        // Then by urgency score (higher = more urgent = comes first)
        if (b.urgency_score !== a.urgency_score) {
          return b.urgency_score - a.urgency_score;
        }

        // Then by practice score (lower score = needs more attention = comes first)
        return a.completeness_score - b.completeness_score;
      });

      return allTasks;
    }

    // Current operator task filter state
    let operatorTaskFilters = {
      severity: null,      // 'critical', 'high', 'medium', 'low', or null for all
      task_type: null,     // specific task_type or null for all
      status: null,        // practice status or null for all
      capital_only: false  // show only capital-related tasks
    };

    function getFilteredOperatorTasks() {
      let tasks = computeOperatorTasks();

      if (operatorTaskFilters.severity) {
        tasks = tasks.filter(t => t.severity === operatorTaskFilters.severity);
      }
      if (operatorTaskFilters.task_type) {
        tasks = tasks.filter(t => t.task_type === operatorTaskFilters.task_type);
      }
      if (operatorTaskFilters.status) {
        tasks = tasks.filter(t => t.practice_status === operatorTaskFilters.status);
      }
      if (operatorTaskFilters.capital_only) {
        tasks = tasks.filter(t => t.category === 'capital');
      }

      return tasks;
    }

    function clearOperatorTaskFilters() {
      operatorTaskFilters = {
        severity: null,
        task_type: null,
        status: null,
        capital_only: false
      };
    }

    function hasActiveOperatorTaskFilters() {
      return operatorTaskFilters.severity ||
             operatorTaskFilters.task_type ||
             operatorTaskFilters.status ||
             operatorTaskFilters.capital_only;
    }

    /**
     * renderOperatorTasks()
     * Renders the operator task list into #operator-tasks-container
     * Includes: reason display, visibility limits (3 per practice), quick actions
     */
    function renderOperatorTasks() {
      const container = document.getElementById('operator-tasks-container');
      if (!container) return;

      const tasks = getFilteredOperatorTasks();
      const allTasks = computeOperatorTasks();

      // Get unique values for filter dropdowns
      const severities = ['critical', 'high', 'medium', 'low'];
      const taskTypes = [...new Set(allTasks.map(t => t.task_type))].sort();
      const statuses = ['Lead', 'Onboarding', 'Active'];

      // Build filter options HTML
      const severityOptions = severities.map(s =>
        `<option value="${s}" ${operatorTaskFilters.severity === s ? 'selected' : ''}>${s.charAt(0).toUpperCase() + s.slice(1)}</option>`
      ).join('');

      const taskTypeOptions = taskTypes.map(t => {
        const config = TASK_TYPES[t];
        const label = config ? config.label : t;
        return `<option value="${t}" ${operatorTaskFilters.task_type === t ? 'selected' : ''}>${label}</option>`;
      }).join('');

      const statusOptions = statuses.map(s =>
        `<option value="${s}" ${operatorTaskFilters.status === s ? 'selected' : ''}>${s}</option>`
      ).join('');

      const capitalCheckClass = operatorTaskFilters.capital_only ? 'active' : '';

      // Filters HTML
      const filtersHtml = `
        <div class="operator-tasks-filters">
          <div class="operator-filter-group">
            <label>Severity</label>
            <select id="filter-task-severity" onchange="handleOperatorTaskFilterChange('severity', this.value)">
              <option value="">All Severities</option>
              ${severityOptions}
            </select>
          </div>
          <div class="operator-filter-group">
            <label>Task Type</label>
            <select id="filter-task-type" onchange="handleOperatorTaskFilterChange('task_type', this.value)">
              <option value="">All Types</option>
              ${taskTypeOptions}
            </select>
          </div>
          <div class="operator-filter-group">
            <label>Practice Status</label>
            <select id="filter-task-status" onchange="handleOperatorTaskFilterChange('status', this.value)">
              <option value="">All Statuses</option>
              ${statusOptions}
            </select>
          </div>
          <label class="operator-filter-checkbox ${capitalCheckClass}" onclick="toggleCapitalOnlyFilter()">
            <input type="checkbox" ${operatorTaskFilters.capital_only ? 'checked' : ''}>
            Capital Only
          </label>
          ${hasActiveOperatorTaskFilters() ? `<button class="operator-clear-filters" onclick="handleClearOperatorTaskFilters()">Clear Filters</button>` : ''}
        </div>
      `;

      // Tasks list HTML with visibility limits
      let tasksListHtml = '';

      if (tasks.length === 0) {
        tasksListHtml = `
          <div class="operator-tasks-empty">
            <div class="operator-tasks-empty-icon">&#9989;</div>
            <h3>${hasActiveOperatorTaskFilters() ? 'No matching tasks' : 'All caught up!'}</h3>
            <p>${hasActiveOperatorTaskFilters() ? 'Try adjusting your filters.' : 'No operator tasks at this time.'}</p>
          </div>
        `;
      } else {
        // Group tasks by practice for visibility limits
        const tasksByPractice = {};
        tasks.forEach(task => {
          if (!tasksByPractice[task.practice_id]) {
            tasksByPractice[task.practice_id] = [];
          }
          tasksByPractice[task.practice_id].push(task);
        });

        // Helper to render a single task item
        function renderTaskItem(task, showPracticeInfo = true) {
          const statusClass = task.practice_status.toLowerCase().replace(/\s+/g, '-');
          const reasonHtml = task.reason ? `<div class="task-reason">${task.reason}</div>` : '';
          const practiceInfoHtml = showPracticeInfo ? `
            <div class="task-practice-info">
              <div class="task-practice-name" title="${task.practice_name}">${task.practice_name}</div>
              <span class="task-practice-status ${statusClass}">${task.practice_status}</span>
              <div class="task-urgency-score">Urgency: ${task.urgency_score}</div>
            </div>
          ` : '';

          return `
            <div class="operator-task-item" data-practice-id="${task.practice_id}" data-task-type="${task.task_type}">
              <span class="task-severity-badge ${task.severity}">${task.severity}</span>
              <div class="task-main-info">
                <div class="task-label">${task.task_label}</div>
                <div class="task-description">${task.description}</div>
                ${reasonHtml}
              </div>
              ${practiceInfoHtml}
              <div class="task-quick-actions">
                <button class="task-quick-btn primary" onclick="event.stopPropagation(); handleOperatorTaskClick('${task.practice_id}', '${task.task_type}')">Open</button>
                <button class="task-quick-btn" onclick="event.stopPropagation(); copyDDPacketFromTask('${task.practice_id}')">DD Packet</button>
              </div>
            </div>
          `;
        }

        // Apply visibility limits: max 3 visible per practice, critical always shows
        const MAX_VISIBLE_PER_PRACTICE = 3;
        let groupedHtml = '';

        Object.keys(tasksByPractice).forEach(practiceId => {
          const practiceTasks = tasksByPractice[practiceId];
          const practiceName = practiceTasks[0].practice_name;
          const practiceStatus = practiceTasks[0].practice_status;

          // Sort: critical first, then by urgency
          practiceTasks.sort((a, b) => {
            if (a.severity === 'critical' && b.severity !== 'critical') return -1;
            if (b.severity === 'critical' && a.severity !== 'critical') return 1;
            return b.urgency_score - a.urgency_score;
          });

          // Determine visible vs collapsed tasks
          // Critical tasks always visible, then fill up to MAX_VISIBLE_PER_PRACTICE
          const criticalTasks = practiceTasks.filter(t => t.severity === 'critical');
          const nonCriticalTasks = practiceTasks.filter(t => t.severity !== 'critical');

          let visibleTasks = [...criticalTasks];
          let collapsedTasks = [];

          // Fill visible slots with non-critical tasks
          const remainingSlots = Math.max(0, MAX_VISIBLE_PER_PRACTICE - visibleTasks.length);
          visibleTasks = visibleTasks.concat(nonCriticalTasks.slice(0, remainingSlots));
          collapsedTasks = nonCriticalTasks.slice(remainingSlots);

          // If only 1 task for this practice, render inline (no grouping)
          if (practiceTasks.length === 1) {
            groupedHtml += renderTaskItem(practiceTasks[0], true);
          } else {
            // Multiple tasks: use grouped view with collapse
            const statusClass = practiceStatus.toLowerCase().replace(/\s+/g, '-');
            const groupId = `task-group-${practiceId.replace(/[^a-zA-Z0-9]/g, '')}`;

            groupedHtml += `<div class="practice-task-group">`;
            groupedHtml += `
              <div class="practice-task-group-header">
                <span class="practice-name">${practiceName}</span>
                <span class="task-practice-status ${statusClass}">${practiceStatus}</span>
                <span class="task-count">${practiceTasks.length} task${practiceTasks.length > 1 ? 's' : ''}</span>
              </div>
            `;

            // Render visible tasks
            visibleTasks.forEach(task => {
              groupedHtml += renderTaskItem(task, false);
            });

            // Render collapsed tasks with toggle
            if (collapsedTasks.length > 0) {
              groupedHtml += `
                <div class="collapsed-tasks-toggle" onclick="toggleCollapsedTasks('${groupId}')">
                  <span class="expand-icon" id="${groupId}-icon">&#9660;</span>
                  <span id="${groupId}-text">+${collapsedTasks.length} more task${collapsedTasks.length > 1 ? 's' : ''}</span>
                </div>
                <div class="collapsed-tasks" id="${groupId}">
              `;
              collapsedTasks.forEach(task => {
                groupedHtml += renderTaskItem(task, false);
              });
              groupedHtml += `</div>`;
            }

            groupedHtml += `</div>`;
          }
        });

        tasksListHtml = `<div class="operator-tasks-list">${groupedHtml}</div>`;
      }

      // Summary stats
      const criticalCount = tasks.filter(t => t.severity === 'critical').length;
      const highCount = tasks.filter(t => t.severity === 'high').length;
      const summaryParts = [];
      if (criticalCount > 0) summaryParts.push(`${criticalCount} critical`);
      if (highCount > 0) summaryParts.push(`${highCount} high`);
      const summaryText = summaryParts.length > 0
        ? `${tasks.length} tasks (${summaryParts.join(', ')})`
        : `${tasks.length} tasks`;

      // Assemble view
      container.innerHTML = `
        <div class="operator-tasks-header">
          <h2>Operator Task Queue</h2>
          <span class="operator-tasks-summary">${summaryText}</span>
        </div>
        ${filtersHtml}
        ${tasksListHtml}
      `;
    }

    // =============================================
    // DASHBOARD VIEW
    // =============================================
    async function renderDashboard() {
      const container = document.getElementById('dashboard-container');
      if (!container) return;

      container.innerHTML = '<div class="dashboard-empty">Loading dashboard...</div>';

      const practices = getPractices();
      const now = new Date();
      const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

      // Fetch all DD documents for expiration checking
      let expiringDocs = [];
      let expiredDocs = [];
      try {
        const { data: ddDocs } = await window.sb
          .from('dd_documents')
          .select('id, file_name, document_type, expires_at, practice_id')
          .not('expires_at', 'is', null)
          .eq('is_current_version', true);

        if (ddDocs) {
          ddDocs.forEach(doc => {
            const expiresAt = new Date(doc.expires_at);
            const practice = getPracticeById(doc.practice_id);
            doc.practice_name = practice ? practice.name : 'Unknown';

            if (expiresAt < now) {
              expiredDocs.push(doc);
            } else if (expiresAt <= thirtyDaysFromNow) {
              expiringDocs.push(doc);
            }
          });
        }
      } catch (e) {
        console.error('Error fetching DD docs for dashboard:', e);
      }

      // Collect readiness data for each practice
      const practiceReadiness = [];
      for (const practice of practices) {
        const readinessScore = practice.dd_readiness_score || 0;
        const checklistCounts = await getDDChecklistCounts(practice.id);
        practiceReadiness.push({
          id: practice.id,
          name: practice.name,
          status: practice.status,
          score: readinessScore,
          completed: checklistCounts.completed,
          total: checklistCounts.total,
          missing: checklistCounts.total - checklistCounts.completed
        });
      }

      // Sort by score ascending (worst first)
      practiceReadiness.sort((a, b) => a.score - b.score);

      // Calculate aggregate stats
      const totalPractices = practices.length;
      const avgScore = totalPractices > 0
        ? Math.round(practiceReadiness.reduce((sum, p) => sum + p.score, 0) / totalPractices)
        : 0;
      const totalMissing = practiceReadiness.reduce((sum, p) => sum + p.missing, 0);
      const totalExpiring = expiringDocs.length + expiredDocs.length;

      // Stats row
      const statsHtml = `
        <div class="dashboard-grid">
          <div class="dashboard-stat stat-blue">
            <div class="stat-value">${totalPractices}</div>
            <div class="stat-label">Total Practices</div>
          </div>
          <div class="dashboard-stat ${avgScore >= 80 ? 'stat-green' : avgScore >= 50 ? 'stat-yellow' : 'stat-red'}">
            <div class="stat-value">${avgScore}%</div>
            <div class="stat-label">Avg DD Readiness</div>
          </div>
          <div class="dashboard-stat ${totalExpiring > 0 ? 'stat-red' : 'stat-green'}">
            <div class="stat-value">${totalExpiring}</div>
            <div class="stat-label">Expiring Docs</div>
          </div>
          <div class="dashboard-stat ${totalMissing > 0 ? 'stat-yellow' : 'stat-green'}">
            <div class="stat-value">${totalMissing}</div>
            <div class="stat-label">Missing Items</div>
          </div>
        </div>
      `;

      // Readiness by practice section
      let readinessRowsHtml = '';
      if (practiceReadiness.length === 0) {
        readinessRowsHtml = '<div class="dashboard-empty">No practices found</div>';
      } else {
        practiceReadiness.forEach(p => {
          const barClass = p.score >= 80 ? 'bar-high' : p.score >= 50 ? 'bar-medium' : 'bar-low';
          const scoreClass = p.score >= 80 ? 'score-high' : p.score >= 50 ? 'score-medium' : 'score-low';
          readinessRowsHtml += `
            <div class="dashboard-readiness-row" onclick="openPracticeDetail('${p.id}')">
              <div>
                <div class="dashboard-row-title">${p.name}</div>
                <div class="dashboard-row-subtitle">${p.status} | ${p.completed}/${p.total} items</div>
              </div>
              <div class="dashboard-score ${scoreClass}">${p.score}%</div>
              <div class="readiness-bar-container">
                <div class="readiness-bar-fill ${barClass}" style="width: ${p.score}%"></div>
              </div>
              <div style="color: ${p.missing > 0 ? '#dc2626' : '#059669'}; font-weight: 500; font-size: 0.85rem;">
                ${p.missing > 0 ? p.missing + ' missing' : 'Complete'}
              </div>
            </div>
          `;
        });
      }

      const readinessSectionHtml = `
        <div class="dashboard-section">
          <div class="dashboard-section-header">
            <h3>DD Readiness by Practice</h3>
            <span class="badge ${avgScore < 50 ? 'badge-red' : avgScore < 80 ? 'badge-yellow' : ''}">${avgScore}% avg</span>
          </div>
          <div class="dashboard-section-body dashboard-readiness-table">
            ${readinessRowsHtml}
          </div>
        </div>
      `;

      // Expiring/Expired documents section
      let expiryRowsHtml = '';
      const allExpiryDocs = [...expiredDocs, ...expiringDocs];

      if (allExpiryDocs.length === 0) {
        expiryRowsHtml = '<div class="dashboard-empty">No expiring documents</div>';
      } else {
        // Sort: expired first, then by expiration date
        allExpiryDocs.sort((a, b) => new Date(a.expires_at) - new Date(b.expires_at));

        allExpiryDocs.slice(0, 15).forEach(doc => {
          const expiresAt = new Date(doc.expires_at);
          const isExpired = expiresAt < now;
          const daysUntil = Math.ceil((expiresAt - now) / (1000 * 60 * 60 * 24));
          const badgeClass = isExpired ? 'expired' : 'expiring';
          const badgeText = isExpired ? 'Expired' : `${daysUntil}d left`;

          expiryRowsHtml += `
            <div class="dashboard-row" onclick="openPracticeDetail('${doc.practice_id}')">
              <div class="dashboard-row-info">
                <div class="dashboard-row-title">${doc.file_name}</div>
                <div class="dashboard-row-subtitle">${doc.practice_name} | ${formatDocumentType(doc.document_type)}</div>
              </div>
              <div class="dashboard-row-right">
                <span class="dashboard-expiry-badge ${badgeClass}">${badgeText}</span>
              </div>
            </div>
          `;
        });
      }

      const expirySectionHtml = `
        <div class="dashboard-section">
          <div class="dashboard-section-header">
            <h3>Expiring Documents</h3>
            ${totalExpiring > 0 ? `<span class="badge badge-red">${expiredDocs.length} expired, ${expiringDocs.length} soon</span>` : ''}
          </div>
          <div class="dashboard-section-body">
            ${expiryRowsHtml}
          </div>
        </div>
      `;

      // Practices needing attention (lowest scores)
      let attentionRowsHtml = '';
      const needsAttention = practiceReadiness.filter(p => p.score < 50);

      if (needsAttention.length === 0) {
        attentionRowsHtml = '<div class="dashboard-empty">All practices at 50%+ readiness</div>';
      } else {
        needsAttention.slice(0, 10).forEach(p => {
          attentionRowsHtml += `
            <div class="dashboard-row" onclick="openPracticeDetail('${p.id}')">
              <div class="dashboard-row-info">
                <div class="dashboard-row-title">${p.name}</div>
                <div class="dashboard-row-subtitle">${p.missing} missing items | ${p.status}</div>
              </div>
              <div class="dashboard-row-right">
                <span class="dashboard-score score-low">${p.score}%</span>
              </div>
            </div>
          `;
        });
      }

      const attentionSectionHtml = `
        <div class="dashboard-section">
          <div class="dashboard-section-header">
            <h3>Needs Attention</h3>
            ${needsAttention.length > 0 ? `<span class="badge badge-red">${needsAttention.length} practices</span>` : ''}
          </div>
          <div class="dashboard-section-body">
            ${attentionRowsHtml}
          </div>
        </div>
      `;

      // Export toolbar
      const exportToolbarHtml = `
        <div class="export-toolbar">
          <span class="export-label">Export Reports:</span>
          <button class="export-btn" onclick="exportPracticesCSV()">
            <svg viewBox="0 0 24 24" width="16" height="16"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="none" stroke="currentColor" stroke-width="2"/><polyline points="14 2 14 8 20 8" fill="none" stroke="currentColor" stroke-width="2"/><line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2"/><line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2"/></svg>
            Practices (CSV)
          </button>
          <button class="export-btn" onclick="exportDocumentsCSV()">
            <svg viewBox="0 0 24 24" width="16" height="16"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="none" stroke="currentColor" stroke-width="2"/><polyline points="14 2 14 8 20 8" fill="none" stroke="currentColor" stroke-width="2"/><line x1="16" y1="13" x2="8" y2="13" stroke="currentColor" stroke-width="2"/><line x1="16" y1="17" x2="8" y2="17" stroke="currentColor" stroke-width="2"/></svg>
            Documents (CSV)
          </button>
          <button class="export-btn export-btn-primary" onclick="exportDDReadinessReport()">
            <svg viewBox="0 0 24 24" width="16" height="16"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" fill="none" stroke="currentColor" stroke-width="2"/><polyline points="14 2 14 8 20 8" fill="none" stroke="currentColor" stroke-width="2"/></svg>
            DD Readiness Report (PDF)
          </button>
        </div>
      `;

      // Assemble dashboard
      container.innerHTML = `
        ${statsHtml}
        ${exportToolbarHtml}
        <div class="dashboard-sections">
          ${readinessSectionHtml}
          ${expirySectionHtml}
          ${attentionSectionHtml}
        </div>
      `;
    }

    // Helper to get DD checklist counts for a practice
    async function getDDChecklistCounts(practiceId) {
      try {
        const { data: items } = await window.sb
          .from('dd_checklist_items')
          .select('id, is_complete')
          .eq('practice_id', practiceId);

        if (!items) return { completed: 0, total: 0 };
        const completed = items.filter(i => i.is_complete).length;
        return { completed, total: items.length };
      } catch (e) {
        return { completed: 0, total: 0 };
      }
    }

    // Helper to format document type for display
    function formatDocumentType(docType) {
      if (!docType) return 'Document';
      return docType
        .split('_')
        .map(w => w.charAt(0).toUpperCase() + w.slice(1))
        .join(' ');
    }

    // =============================================
    // NOTIFICATION SYSTEM
    // =============================================
    let cachedNotifications = null;
    let notificationCenterOpen = false;

    function toggleNotificationCenter() {
      const center = document.getElementById('notification-center');
      notificationCenterOpen = !notificationCenterOpen;

      if (notificationCenterOpen) {
        center.style.display = 'block';
        loadNotifications();
        // Close when clicking outside
        setTimeout(() => {
          document.addEventListener('click', closeNotificationOnClickOutside);
        }, 100);
      } else {
        center.style.display = 'none';
        document.removeEventListener('click', closeNotificationOnClickOutside);
      }
    }

    function closeNotificationOnClickOutside(e) {
      const center = document.getElementById('notification-center');
      const bell = document.querySelector('.notification-bell');
      if (!center.contains(e.target) && !bell.contains(e.target)) {
        center.style.display = 'none';
        notificationCenterOpen = false;
        document.removeEventListener('click', closeNotificationOnClickOutside);
      }
    }

    async function loadNotifications() {
      const listEl = document.getElementById('notification-list');
      listEl.innerHTML = '<div class="notification-empty">Loading...</div>';

      const notifications = await getNotifications();
      cachedNotifications = notifications;

      if (notifications.length === 0) {
        listEl.innerHTML = `
          <div class="notification-empty">
            <div class="notification-empty-icon">&#10004;</div>
            <div>All caught up! No alerts.</div>
          </div>
        `;
        return;
      }

      let html = '';
      notifications.forEach(n => {
        const iconClass = n.type === 'expired' ? 'icon-expired' :
                          n.type === 'expiring' ? 'icon-expiring' : 'icon-missing';
        const icon = n.type === 'expired' ? '&#9888;' :
                     n.type === 'expiring' ? '&#128337;' : '&#128196;';

        html += `
          <div class="notification-item" onclick="openPracticeDetail('${n.practiceId}'); toggleNotificationCenter();">
            <div class="notification-icon ${iconClass}">${icon}</div>
            <div class="notification-content">
              <div class="notification-title">${n.title}</div>
              <div class="notification-subtitle">${n.subtitle}</div>
            </div>
            <div class="notification-time">${n.timeLabel}</div>
          </div>
        `;
      });

      listEl.innerHTML = html;
    }

    async function getNotifications() {
      const notifications = [];
      const now = new Date();
      const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
      const practices = getPractices();

      // Get expiring/expired documents
      try {
        const { data: ddDocs } = await window.sb
          .from('dd_documents')
          .select('id, file_name, document_type, expires_at, practice_id')
          .not('expires_at', 'is', null)
          .eq('is_current_version', true);

        if (ddDocs) {
          ddDocs.forEach(doc => {
            const expiresAt = new Date(doc.expires_at);
            const practice = getPracticeById(doc.practice_id);
            const practiceName = practice ? practice.name : 'Unknown';
            const daysUntil = Math.ceil((expiresAt - now) / (1000 * 60 * 60 * 24));

            if (expiresAt < now) {
              // Expired
              const daysAgo = Math.abs(daysUntil);
              notifications.push({
                type: 'expired',
                title: `${doc.file_name} has expired`,
                subtitle: `${practiceName} - ${formatDocumentType(doc.document_type)}`,
                timeLabel: daysAgo === 0 ? 'Today' : `${daysAgo}d ago`,
                practiceId: doc.practice_id,
                priority: 1,
                date: expiresAt
              });
            } else if (expiresAt <= thirtyDaysFromNow) {
              // Expiring soon
              notifications.push({
                type: 'expiring',
                title: `${doc.file_name} expiring soon`,
                subtitle: `${practiceName} - ${formatDocumentType(doc.document_type)}`,
                timeLabel: `${daysUntil}d left`,
                practiceId: doc.practice_id,
                priority: 2,
                date: expiresAt
              });
            }
          });
        }
      } catch (e) {
        console.error('Error fetching docs for notifications:', e);
      }

      // Get practices with low readiness (below 30%)
      for (const practice of practices) {
        if (practice.dd_readiness_score !== undefined && practice.dd_readiness_score < 30) {
          notifications.push({
            type: 'missing',
            title: `${practice.name} needs documents`,
            subtitle: `DD Readiness at ${practice.dd_readiness_score}%`,
            timeLabel: 'Action needed',
            practiceId: practice.id,
            priority: 3,
            date: new Date()
          });
        }
      }

      // Sort: expired first, then expiring, then missing
      notifications.sort((a, b) => {
        if (a.priority !== b.priority) return a.priority - b.priority;
        return a.date - b.date;
      });

      return notifications;
    }

    async function updateNotificationBadge() {
      const notifications = await getNotifications();
      const badge = document.getElementById('notification-badge');

      if (notifications.length > 0) {
        badge.textContent = notifications.length > 99 ? '99+' : notifications.length;
        badge.style.display = 'flex';
      } else {
        badge.style.display = 'none';
      }
    }

    // Slack Integration
    function getSlackWebhookUrl() {
      return localStorage.getItem('zenyte_slack_webhook') || '';
    }

    function setSlackWebhookUrl(url) {
      localStorage.setItem('zenyte_slack_webhook', url);
    }

    function openSlackSettings() {
      const currentUrl = getSlackWebhookUrl();

      showModal('Slack Integration', `
        <div class="slack-settings-content">
          <label>Slack Webhook URL</label>
          <input type="text" id="slack-webhook-input" placeholder="https://hooks.slack.com/services/..." value="${currentUrl}">
          <p style="font-size: 0.75rem; color: #6b7280; margin-bottom: 1rem;">
            Create an incoming webhook in your Slack workspace settings and paste the URL here.
          </p>
          <div id="slack-test-result"></div>
          <div class="slack-actions">
            <button class="btn-test-slack" onclick="testSlackWebhook()">Test Connection</button>
            <button class="btn-save-slack" onclick="saveSlackSettings()">Save</button>
            <button class="btn-send-slack-now" onclick="sendSlackDigestNow()">Send Digest Now</button>
          </div>
        </div>
      `);
    }

    async function testSlackWebhook() {
      const url = document.getElementById('slack-webhook-input').value.trim();
      const resultEl = document.getElementById('slack-test-result');

      if (!url) {
        resultEl.innerHTML = '<div class="slack-test-result error">Please enter a webhook URL</div>';
        return;
      }

      resultEl.innerHTML = '<div class="slack-test-result">Testing...</div>';

      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          mode: 'no-cors', // Slack webhooks don't support CORS
          body: JSON.stringify({
            text: ' Zenyte ERP test message - Slack integration is working!'
          })
        });

        // With no-cors, we can't read the response, so assume success if no error thrown
        resultEl.innerHTML = '<div class="slack-test-result success">Test message sent! Check your Slack channel.</div>';
      } catch (e) {
        resultEl.innerHTML = `<div class="slack-test-result error">Failed to send: ${e.message}</div>`;
      }
    }

    function saveSlackSettings() {
      const url = document.getElementById('slack-webhook-input').value.trim();
      setSlackWebhookUrl(url);
      closeModal();
      alert('Slack settings saved!');
    }

    async function sendSlackDigestNow() {
      const url = getSlackWebhookUrl();
      if (!url) {
        alert('Please configure a Slack webhook URL first');
        return;
      }

      const notifications = cachedNotifications || await getNotifications();

      if (notifications.length === 0) {
        alert('No notifications to send');
        return;
      }

      // Build Slack message
      const expiredCount = notifications.filter(n => n.type === 'expired').length;
      const expiringCount = notifications.filter(n => n.type === 'expiring').length;
      const missingCount = notifications.filter(n => n.type === 'missing').length;

      let blocks = [
        {
          type: 'header',
          text: { type: 'plain_text', text: ' Zenyte Document Alert Digest' }
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Summary:* ${expiredCount} expired, ${expiringCount} expiring soon, ${missingCount} practices need attention`
          }
        },
        { type: 'divider' }
      ];

      // Add top 10 notifications
      notifications.slice(0, 10).forEach(n => {
        const emoji = n.type === 'expired' ? '' : n.type === 'expiring' ? '' : '';
        blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `${emoji} *${n.title}*\n${n.subtitle} - ${n.timeLabel}`
          }
        });
      });

      if (notifications.length > 10) {
        blocks.push({
          type: 'context',
          elements: [{ type: 'mrkdwn', text: `_...and ${notifications.length - 10} more alerts_` }]
        });
      }

      try {
        await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          mode: 'no-cors',
          body: JSON.stringify({ blocks })
        });
        alert('Digest sent to Slack!');
      } catch (e) {
        alert('Failed to send to Slack: ' + e.message);
      }
    }

    // Email Digest Generator
    async function generateEmailDigest() {
      const notifications = cachedNotifications || await getNotifications();

      if (notifications.length === 0) {
        showModal('Email Digest', `
          <div class="email-digest-content">
            <div class="notification-empty">
              <div class="notification-empty-icon">&#10004;</div>
              <div>No alerts to include in digest.</div>
            </div>
          </div>
        `);
        return;
      }

      const expiredCount = notifications.filter(n => n.type === 'expired').length;
      const expiringCount = notifications.filter(n => n.type === 'expiring').length;
      const missingCount = notifications.filter(n => n.type === 'missing').length;

      const today = new Date().toLocaleDateString('en-US', {
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
      });

      let emailBody = `ZENYTE DOCUMENT ALERT DIGEST
${today}

SUMMARY
-------
- ${expiredCount} expired document(s)
- ${expiringCount} document(s) expiring within 30 days
- ${missingCount} practice(s) with low DD readiness

DETAILS
-------
`;

      if (expiredCount > 0) {
        emailBody += '\n EXPIRED DOCUMENTS:\n';
        notifications.filter(n => n.type === 'expired').forEach(n => {
          emailBody += `    ${n.title}\n     ${n.subtitle}\n`;
        });
      }

      if (expiringCount > 0) {
        emailBody += '\n EXPIRING SOON:\n';
        notifications.filter(n => n.type === 'expiring').forEach(n => {
          emailBody += `    ${n.title} (${n.timeLabel})\n     ${n.subtitle}\n`;
        });
      }

      if (missingCount > 0) {
        emailBody += '\n NEEDS ATTENTION:\n';
        notifications.filter(n => n.type === 'missing').forEach(n => {
          emailBody += `    ${n.title}\n     ${n.subtitle}\n`;
        });
      }

      emailBody += `
-------
This digest was generated from Zenyte ERP.
`;

      const subject = `Zenyte Document Alerts: ${expiredCount} expired, ${expiringCount} expiring`;
      const mailtoUrl = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(emailBody)}`;

      showModal('Email Digest', `
        <div class="email-digest-content">
          <div class="email-digest-preview">${emailBody}</div>
          <div class="email-digest-actions">
            <button class="btn-copy-email" onclick="copyEmailDigest()">Copy to Clipboard</button>
            <button class="btn-open-mailto" onclick="window.open('${mailtoUrl}')">Open in Email App</button>
          </div>
        </div>
      `);

      // Store for copy function
      window._emailDigestContent = emailBody;
    }

    function copyEmailDigest() {
      if (window._emailDigestContent && navigator.clipboard) {
        navigator.clipboard.writeText(window._emailDigestContent).then(() => {
          const btn = event.target;
          btn.textContent = 'Copied!';
          btn.style.background = '#059669';
          setTimeout(() => {
            btn.textContent = 'Copy to Clipboard';
            btn.style.background = '';
          }, 1500);
        });
      }
    }

    // Update notification badge on page load and periodically
    function initNotifications() {
      updateNotificationBadge();
      // Update every 5 minutes
      setInterval(updateNotificationBadge, 5 * 60 * 1000);
    }

    // =============================================
    // GLOBAL DOCUMENT SEARCH
    // =============================================
    let searchDebounceTimer = null;
    let searchResultsVisible = false;
    let selectedSearchIndex = -1;
    let currentSearchResults = [];

    function handleGlobalSearch(query) {
      // Debounce search
      clearTimeout(searchDebounceTimer);

      if (!query || query.trim().length < 2) {
        hideSearchResults();
        return;
      }

      const resultsEl = document.getElementById('global-search-results');
      resultsEl.style.display = 'block';
      resultsEl.innerHTML = '<div class="search-loading">Searching...</div>';
      searchResultsVisible = true;

      searchDebounceTimer = setTimeout(() => {
        performSearch(query.trim());
      }, 300);
    }

    async function performSearch(query) {
      const resultsEl = document.getElementById('global-search-results');
      const lowerQuery = query.toLowerCase();
      const results = [];

      try {
        // Search financial_documents
        const { data: financialDocs } = await window.sb
          .from('financial_documents')
          .select('id, file_name, document_type, practice_id, notes, created_at')
          .or(`file_name.ilike.%${query}%,document_type.ilike.%${query}%,notes.ilike.%${query}%`)
          .limit(20);

        if (financialDocs) {
          financialDocs.forEach(doc => {
            const practice = getPracticeById(doc.practice_id);
            results.push({
              id: doc.id,
              type: 'financial',
              fileName: doc.file_name,
              docType: doc.document_type,
              practiceName: practice ? practice.name : 'Unknown',
              practiceId: doc.practice_id,
              notes: doc.notes,
              createdAt: doc.created_at
            });
          });
        }

        // Search dd_documents
        const { data: ddDocs } = await window.sb
          .from('dd_documents')
          .select('id, file_name, document_type, category_slug, practice_id, notes, created_at')
          .eq('is_current_version', true)
          .or(`file_name.ilike.%${query}%,document_type.ilike.%${query}%,notes.ilike.%${query}%`)
          .limit(20);

        if (ddDocs) {
          ddDocs.forEach(doc => {
            const practice = getPracticeById(doc.practice_id);
            results.push({
              id: doc.id,
              type: 'dd',
              category: doc.category_slug,
              fileName: doc.file_name,
              docType: doc.document_type,
              practiceName: practice ? practice.name : 'Unknown',
              practiceId: doc.practice_id,
              notes: doc.notes,
              createdAt: doc.created_at
            });
          });
        }

        // Also search practices by name
        const practices = getPractices();
        practices.forEach(p => {
          if (p.name.toLowerCase().includes(lowerQuery)) {
            results.push({
              id: p.id,
              type: 'practice',
              fileName: p.name,
              docType: 'Practice',
              practiceName: p.name,
              practiceId: p.id,
              status: p.status
            });
          }
        });

      } catch (e) {
        console.error('Search error:', e);
      }

      currentSearchResults = results;
      selectedSearchIndex = -1;
      renderSearchResults(results, query);
    }

    function renderSearchResults(results, query) {
      const resultsEl = document.getElementById('global-search-results');

      if (results.length === 0) {
        resultsEl.innerHTML = `
          <div class="search-no-results">
            <div class="search-no-results-icon">&#128269;</div>
            <div>No documents found for "${query}"</div>
          </div>
        `;
        return;
      }

      // Group by type
      const financialResults = results.filter(r => r.type === 'financial');
      const ddResults = results.filter(r => r.type === 'dd');
      const practiceResults = results.filter(r => r.type === 'practice');

      let html = `<div class="search-results-header">${results.length} result${results.length !== 1 ? 's' : ''} for "${query}"</div>`;
      html += '<div class="search-results-list">';

      let idx = 0;

      // Practice results first
      if (practiceResults.length > 0) {
        practiceResults.forEach(r => {
          html += renderSearchResultItem(r, query, idx++);
        });
      }

      // Financial documents
      if (financialResults.length > 0) {
        financialResults.forEach(r => {
          html += renderSearchResultItem(r, query, idx++);
        });
      }

      // DD documents
      if (ddResults.length > 0) {
        ddResults.forEach(r => {
          html += renderSearchResultItem(r, query, idx++);
        });
      }

      html += '</div>';
      resultsEl.innerHTML = html;
    }

    function renderSearchResultItem(result, query, index) {
      const highlightedName = highlightMatch(result.fileName, query);
      const icon = result.type === 'financial' ? '' : result.type === 'dd' ? '' : '';
      const iconClass = result.type === 'financial' ? 'icon-financial' : result.type === 'dd' ? 'icon-dd' : 'icon-financial';
      const tagClass = result.type === 'financial' ? 'tag-financial' : result.type === 'dd' ? 'tag-dd' : '';
      const tagLabel = result.type === 'financial' ? 'Financial' : result.type === 'dd' ? (result.category || 'DD').replace('dd-', '').replace('-', ' ') : 'Practice';

      let meta = result.practiceName;
      if (result.docType && result.type !== 'practice') {
        meta += `  ${formatDocumentType(result.docType)}`;
      }
      if (result.status) {
        meta += `  ${result.status}`;
      }

      return `
        <div class="search-result-item" data-index="${index}" onclick="selectSearchResult(${index})" onmouseenter="highlightSearchResult(${index})">
          <div class="search-result-icon ${iconClass}">${icon}</div>
          <div class="search-result-content">
            <div class="search-result-title">${highlightedName}</div>
            <div class="search-result-meta">
              <span class="search-result-tag ${tagClass}">${tagLabel}</span>
              <span>${meta}</span>
            </div>
          </div>
        </div>
      `;
    }

    function highlightMatch(text, query) {
      if (!text || !query) return text || '';
      const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
      return text.replace(regex, '<mark>$1</mark>');
    }

    function escapeRegex(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function showSearchResults() {
      const input = document.getElementById('global-search-input');
      if (input.value.trim().length >= 2 && currentSearchResults.length > 0) {
        const resultsEl = document.getElementById('global-search-results');
        resultsEl.style.display = 'block';
        searchResultsVisible = true;
      }
    }

    function hideSearchResults() {
      const resultsEl = document.getElementById('global-search-results');
      resultsEl.style.display = 'none';
      searchResultsVisible = false;
      selectedSearchIndex = -1;
    }

    function highlightSearchResult(index) {
      selectedSearchIndex = index;
      const items = document.querySelectorAll('.search-result-item');
      items.forEach((item, i) => {
        item.classList.toggle('selected', i === index);
      });
    }

    function selectSearchResult(index) {
      const result = currentSearchResults[index];
      if (!result) return;

      hideSearchResults();
      document.getElementById('global-search-input').value = '';

      if (result.type === 'practice') {
        openPracticeDetail(result.practiceId);
      } else {
        // Open practice and switch to appropriate document tab
        openPracticeDetail(result.practiceId);
        setTimeout(() => {
          if (result.type === 'financial') {
            switchDocTab('financial');
          } else if (result.type === 'dd' && result.category) {
            switchDocTab(result.category);
          }
        }, 100);
      }
    }

    function handleSearchKeydown(event) {
      if (!searchResultsVisible) return;

      const items = document.querySelectorAll('.search-result-item');

      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          selectedSearchIndex = Math.min(selectedSearchIndex + 1, items.length - 1);
          highlightSearchResult(selectedSearchIndex);
          items[selectedSearchIndex]?.scrollIntoView({ block: 'nearest' });
          break;
        case 'ArrowUp':
          event.preventDefault();
          selectedSearchIndex = Math.max(selectedSearchIndex - 1, 0);
          highlightSearchResult(selectedSearchIndex);
          items[selectedSearchIndex]?.scrollIntoView({ block: 'nearest' });
          break;
        case 'Enter':
          event.preventDefault();
          if (selectedSearchIndex >= 0) {
            selectSearchResult(selectedSearchIndex);
          }
          break;
        case 'Escape':
          hideSearchResults();
          document.getElementById('global-search-input').blur();
          break;
      }
    }

    // Global keyboard shortcut: Ctrl+K or Cmd+K to focus search
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        const input = document.getElementById('global-search-input');
        if (input) {
          input.focus();
          input.select();
        }
      }
    });

    // Close search results when clicking outside
    document.addEventListener('click', (e) => {
      const container = document.querySelector('.global-search-container');
      if (container && !container.contains(e.target)) {
        hideSearchResults();
      }
    });

    // =============================================
    // EXPORT FUNCTIONS
    // =============================================

    function downloadCSV(filename, csvContent) {
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function escapeCSV(value) {
      if (value === null || value === undefined) return '';
      const str = String(value);
      if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return '"' + str.replace(/"/g, '""') + '"';
      }
      return str;
    }

    async function exportPracticesCSV() {
      const practices = getPractices();
      const headers = ['Name', 'Specialty', 'Owner', 'Revenue', 'Status', 'DD Readiness %', 'Tags', 'Created At'];

      let csv = headers.join(',') + '\n';

      for (const p of practices) {
        const tags = (p.tags || []).join('; ');
        const row = [
          escapeCSV(p.name),
          escapeCSV(p.specialty),
          escapeCSV(p.owner),
          escapeCSV(p.revenue),
          escapeCSV(p.status),
          escapeCSV(p.dd_readiness_score || 0),
          escapeCSV(tags),
          escapeCSV(p.created_at ? new Date(p.created_at).toLocaleDateString() : '')
        ];
        csv += row.join(',') + '\n';
      }

      const date = new Date().toISOString().split('T')[0];
      downloadCSV(`zenyte-practices-${date}.csv`, csv);
    }

    async function exportDocumentsCSV() {
      const practices = getPractices();
      const headers = ['Practice', 'Document Name', 'Category', 'Document Type', 'Expires At', 'Version', 'Notes', 'Uploaded At'];

      let csv = headers.join(',') + '\n';

      // Fetch all financial documents
      try {
        const { data: financialDocs } = await window.sb
          .from('financial_documents')
          .select('file_name, document_type, practice_id, notes, created_at');

        if (financialDocs) {
          financialDocs.forEach(doc => {
            const practice = getPracticeById(doc.practice_id);
            const row = [
              escapeCSV(practice ? practice.name : 'Unknown'),
              escapeCSV(doc.file_name),
              escapeCSV('Financial'),
              escapeCSV(formatDocumentType(doc.document_type)),
              escapeCSV(''),
              escapeCSV(''),
              escapeCSV(doc.notes || ''),
              escapeCSV(doc.created_at ? new Date(doc.created_at).toLocaleDateString() : '')
            ];
            csv += row.join(',') + '\n';
          });
        }
      } catch (e) {
        console.error('Error fetching financial docs:', e);
      }

      // Fetch all DD documents
      try {
        const { data: ddDocs } = await window.sb
          .from('dd_documents')
          .select('file_name, document_type, category_slug, practice_id, expires_at, version_number, notes, created_at')
          .eq('is_current_version', true);

        if (ddDocs) {
          ddDocs.forEach(doc => {
            const practice = getPracticeById(doc.practice_id);
            const categoryLabel = (doc.category_slug || 'DD').replace('dd-', '').replace('-', ' ');
            const row = [
              escapeCSV(practice ? practice.name : 'Unknown'),
              escapeCSV(doc.file_name),
              escapeCSV(categoryLabel.charAt(0).toUpperCase() + categoryLabel.slice(1)),
              escapeCSV(formatDocumentType(doc.document_type)),
              escapeCSV(doc.expires_at ? new Date(doc.expires_at).toLocaleDateString() : ''),
              escapeCSV(doc.version_number || 1),
              escapeCSV(doc.notes || ''),
              escapeCSV(doc.created_at ? new Date(doc.created_at).toLocaleDateString() : '')
            ];
            csv += row.join(',') + '\n';
          });
        }
      } catch (e) {
        console.error('Error fetching DD docs:', e);
      }

      const date = new Date().toISOString().split('T')[0];
      downloadCSV(`zenyte-documents-${date}.csv`, csv);
    }

    async function exportDDReadinessReport() {
      const practices = getPractices();
      const now = new Date();
      const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

      // Collect data
      const practiceData = [];
      let totalScore = 0;
      let expiredCount = 0;
      let expiringCount = 0;

      for (const practice of practices) {
        const score = practice.dd_readiness_score || 0;
        totalScore += score;

        const counts = await getDDChecklistCounts(practice.id);

        practiceData.push({
          name: practice.name,
          status: practice.status,
          score: score,
          completed: counts.completed,
          total: counts.total
        });
      }

      // Get expiring docs
      try {
        const { data: ddDocs } = await window.sb
          .from('dd_documents')
          .select('expires_at')
          .not('expires_at', 'is', null)
          .eq('is_current_version', true);

        if (ddDocs) {
          ddDocs.forEach(doc => {
            const expiresAt = new Date(doc.expires_at);
            if (expiresAt < now) {
              expiredCount++;
            } else if (expiresAt <= thirtyDaysFromNow) {
              expiringCount++;
            }
          });
        }
      } catch (e) {
        console.error('Error fetching docs for report:', e);
      }

      const avgScore = practices.length > 0 ? Math.round(totalScore / practices.length) : 0;

      // Sort by score ascending (worst first)
      practiceData.sort((a, b) => a.score - b.score);

      // Generate HTML report
      const reportDate = now.toLocaleDateString('en-US', {
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
      });

      let practiceRows = '';
      practiceData.forEach(p => {
        const scoreClass = p.score >= 80 ? 'score-high' : p.score >= 50 ? 'score-medium' : 'score-low';
        practiceRows += `
          <tr>
            <td>${p.name}</td>
            <td>${p.status}</td>
            <td class="score-cell ${scoreClass}">${p.score}%</td>
            <td>${p.completed}/${p.total}</td>
            <td>${p.total - p.completed}</td>
          </tr>
        `;
      });

      const reportHtml = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>DD Readiness Report - ${reportDate}</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 2rem; }
            h1 { font-size: 1.5rem; color: #1a1a2e; margin-bottom: 0.5rem; }
            .subtitle { color: #6b7280; font-size: 0.9rem; margin-bottom: 2rem; }
            .summary-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 2rem; }
            .summary-stat { text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 8px; }
            .summary-stat .value { font-size: 1.5rem; font-weight: 700; color: #1a1a2e; }
            .summary-stat .label { font-size: 0.75rem; color: #6b7280; text-transform: uppercase; }
            .section { margin-bottom: 2rem; }
            .section h2 { font-size: 1rem; color: #374151; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; margin-bottom: 1rem; }
            table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
            th, td { padding: 0.5rem; text-align: left; border-bottom: 1px solid #e5e7eb; }
            th { background: #f8f9fa; font-weight: 600; color: #374151; }
            .score-cell { font-weight: 600; }
            .score-high { color: #059669; }
            .score-medium { color: #d97706; }
            .score-low { color: #dc2626; }
            @media print { body { padding: 0; } }
          </style>
        </head>
        <body>
          <h1>DD Readiness Report</h1>
          <div class="subtitle">Generated on ${reportDate}</div>

          <div class="summary-stats">
            <div class="summary-stat">
              <div class="value">${practices.length}</div>
              <div class="label">Total Practices</div>
            </div>
            <div class="summary-stat">
              <div class="value">${avgScore}%</div>
              <div class="label">Avg Readiness</div>
            </div>
            <div class="summary-stat">
              <div class="value">${expiredCount}</div>
              <div class="label">Expired Docs</div>
            </div>
            <div class="summary-stat">
              <div class="value">${expiringCount}</div>
              <div class="label">Expiring Soon</div>
            </div>
          </div>

          <div class="section">
            <h2>Practice DD Readiness (Sorted by Score)</h2>
            <table>
              <thead>
                <tr>
                  <th>Practice</th>
                  <th>Status</th>
                  <th>DD Score</th>
                  <th>Checklist</th>
                  <th>Missing</th>
                </tr>
              </thead>
              <tbody>
                ${practiceRows}
              </tbody>
            </table>
          </div>

          <div class="section">
            <h2>Summary</h2>
            <p>This report shows the Due Diligence readiness status for all practices in the Zenyte portfolio.</p>
            <ul>
              <li><strong>${practiceData.filter(p => p.score >= 80).length}</strong> practices are at 80%+ readiness (green)</li>
              <li><strong>${practiceData.filter(p => p.score >= 50 && p.score < 80).length}</strong> practices are at 50-79% readiness (yellow)</li>
              <li><strong>${practiceData.filter(p => p.score < 50).length}</strong> practices are below 50% readiness (red)</li>
            </ul>
          </div>
        </body>
        </html>
      `;

      // Open in new window for printing/saving as PDF
      const printWindow = window.open('', '_blank');
      printWindow.document.write(reportHtml);
      printWindow.document.close();

      // Auto-trigger print dialog after a short delay
      setTimeout(() => {
        printWindow.print();
      }, 500);
    }

    // =============================================
    // DOCUMENT REQUEST WORKFLOW
    // =============================================

    // Document types available for requesting by category
    const requestableDocTypes = {
      'financial': [
        { value: 'bank_statement', label: 'Bank Statements (12+ months)' },
        { value: 'income_statement', label: 'Income Statement / P&L' },
        { value: 'balance_sheet', label: 'Balance Sheet' },
        { value: 'tax_return', label: 'Tax Returns (3 years)' },
        { value: 'ar_aging', label: 'Accounts Receivable Aging' },
        { value: 'ap_aging', label: 'Accounts Payable Aging' }
      ],
      'dd-corporate': [
        { value: 'articles_of_incorporation', label: 'Articles of Incorporation' },
        { value: 'operating_agreement', label: 'Operating Agreement' },
        { value: 'bylaws', label: 'Bylaws' },
        { value: 'org_chart', label: 'Organization Chart' },
        { value: 'ownership_docs', label: 'Ownership Documentation' }
      ],
      'dd-compliance': [
        { value: 'medical_license', label: 'Medical License' },
        { value: 'dea_certificate', label: 'DEA Certificate' },
        { value: 'malpractice_insurance', label: 'Malpractice Insurance' },
        { value: 'hipaa_docs', label: 'HIPAA Documentation' },
        { value: 'osha_compliance', label: 'OSHA Compliance Records' },
        { value: 'accreditation', label: 'Accreditation Certificates' }
      ],
      'dd-contracts': [
        { value: 'lease_agreement', label: 'Lease Agreement' },
        { value: 'vendor_contracts', label: 'Vendor Contracts' },
        { value: 'employment_agreements', label: 'Employment Agreements' },
        { value: 'payor_contracts', label: 'Payor Contracts' },
        { value: 'equipment_leases', label: 'Equipment Leases' }
      ],
      'dd-other': [
        { value: 'equipment_list', label: 'Equipment List' },
        { value: 'employee_roster', label: 'Employee Roster' },
        { value: 'patient_demographics', label: 'Patient Demographics' },
        { value: 'marketing_materials', label: 'Marketing Materials' },
        { value: 'other', label: 'Other Documents' }
      ]
    };

    async function requestMissingDocsEmail() {
      const practiceId = currentPractice?.id || selectedPracticeId;
      if (!practiceId) {
        alert('No practice selected');
        return;
      }

      const practice = getPracticeById(practiceId);
      const practiceName = practice?.name || practice?.dba_name || 'Practice';

      // Get incomplete checklist items
      let missingItems = [];
      try {
        const { data: items } = await window.sb
          .from('dd_checklist_items')
          .select('item_name, category_slug')
          .eq('practice_id', practiceId)
          .eq('is_complete', false)
          .order('category_slug');

        if (items && items.length > 0) {
          missingItems = items;
        }
      } catch (e) {
        console.error('Error fetching checklist items:', e);
      }

      // If no checklist items, check for common missing document types
      if (missingItems.length === 0) {
        // Default list of commonly needed documents
        missingItems = [
          { item_name: 'Bank Statements (12+ months)', category_slug: 'financial' },
          { item_name: 'Income Statement / P&L', category_slug: 'financial' },
          { item_name: 'Tax Returns (3 years)', category_slug: 'financial' },
          { item_name: 'Medical License', category_slug: 'dd-compliance' },
          { item_name: 'Malpractice Insurance', category_slug: 'dd-compliance' },
          { item_name: 'Lease Agreement', category_slug: 'dd-contracts' },
          { item_name: 'Articles of Incorporation', category_slug: 'dd-corporate' }
        ];
      }

      // Group by category
      const byCategory = {};
      missingItems.forEach(item => {
        const cat = item.category_slug || 'other';
        if (!byCategory[cat]) byCategory[cat] = [];
        byCategory[cat].push(item.item_name);
      });

      // Build email body
      const categoryLabels = {
        'financial': 'Financial Documents',
        'dd-corporate': 'Corporate Documents',
        'dd-compliance': 'Compliance Documents',
        'dd-contracts': 'Contracts',
        'dd-other': 'Other Documents'
      };

      let emailBody = `Hello,

We are conducting due diligence on ${practiceName} and need the following documents to complete our review.

DOCUMENTS NEEDED:
==================

`;

      Object.keys(byCategory).forEach(cat => {
        const label = categoryLabels[cat] || cat.replace('dd-', '').replace('-', ' ').toUpperCase();
        emailBody += `${label}:\n`;
        byCategory[cat].forEach(item => {
          emailBody += `   ${item}\n`;
        });
        emailBody += '\n';
      });

      emailBody += `==================

Please upload these documents to our secure portal or reply to this email with the requested files attached.

If you have any questions about what's needed, please don't hesitate to reach out.

Thank you for your prompt attention to this request.

Best regards,
Zenyte Holdings
`;

      const subject = `Document Request: ${practiceName} - DD Materials Needed`;
      const mailtoUrl = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(emailBody)}`;

      // Show preview modal with copy and email options
      showModal('Request Missing Documents', `
        <div class="email-digest-content">
          <p style="margin-bottom: 1rem; color: #6b7280; font-size: 0.85rem;">
            ${missingItems.length} document(s) needed for ${practiceName}
          </p>
          <div class="email-digest-preview">${emailBody}</div>
          <div class="email-digest-actions">
            <button class="btn-copy-email" onclick="copyRequestEmail()">Copy to Clipboard</button>
            <button class="btn-open-mailto" onclick="window.open('${mailtoUrl}'); closeModal();">Open in Email App</button>
          </div>
        </div>
      `);

      // Store for copy function
      window._requestEmailContent = emailBody;
    }

    function copyRequestEmail() {
      if (window._requestEmailContent && navigator.clipboard) {
        navigator.clipboard.writeText(window._requestEmailContent).then(() => {
          const btn = event.target;
          btn.textContent = 'Copied!';
          btn.style.background = '#059669';
          setTimeout(() => {
            btn.textContent = 'Copy to Clipboard';
            btn.style.background = '';
          }, 1500);
        });
      }
    }

    function openRequestDocsModal() {
      const practiceId = currentPractice?.id;
      if (!practiceId) {
        alert('No practice selected');
        return;
      }

      // Build category options
      const categories = [
        { value: 'financial', label: 'Financial' },
        { value: 'dd-corporate', label: 'Corporate' },
        { value: 'dd-compliance', label: 'Compliance' },
        { value: 'dd-contracts', label: 'Contracts' },
        { value: 'dd-other', label: 'Other DD' }
      ];

      const categoryOptions = categories.map(c =>
        `<option value="${c.value}">${c.label}</option>`
      ).join('');

      // Initial doc types for first category
      const initialDocTypes = requestableDocTypes['financial'];
      const docTypeItems = initialDocTypes.map(dt =>
        `<div class="request-doc-type-item" onclick="toggleRequestCheckbox('${dt.value}')">
          <input type="checkbox" id="req-${dt.value}" value="${dt.value}">
          <span class="doc-type-label">${dt.label}</span>
        </div>`
      ).join('');

      showModal('Request Documents', `
        <div class="request-modal-content">
          <div class="request-category-select">
            <label>Category</label>
            <select id="request-category" onchange="updateRequestDocTypes()">
              ${categoryOptions}
            </select>
          </div>

          <div class="request-doc-types">
            <label>Select documents to request:</label>
            <div class="request-doc-type-list" id="request-doc-type-list">
              ${docTypeItems}
            </div>
          </div>

          <div class="request-notes">
            <label>Notes (optional)</label>
            <textarea id="request-notes" placeholder="Add any specific instructions or notes for the practice..."></textarea>
          </div>

          <div class="request-modal-actions">
            <button class="btn-cancel-modal" onclick="closeModal()">Cancel</button>
            <button class="btn-send-requests" onclick="sendDocumentRequests()">Send Requests</button>
          </div>
        </div>
      `);
    }

    function toggleRequestCheckbox(value) {
      const checkbox = document.getElementById(`req-${value}`);
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
      }
    }

    function updateRequestDocTypes() {
      const category = document.getElementById('request-category').value;
      const docTypes = requestableDocTypes[category] || [];
      const listEl = document.getElementById('request-doc-type-list');

      listEl.innerHTML = docTypes.map(dt =>
        `<div class="request-doc-type-item" onclick="toggleRequestCheckbox('${dt.value}')">
          <input type="checkbox" id="req-${dt.value}" value="${dt.value}">
          <span class="doc-type-label">${dt.label}</span>
        </div>`
      ).join('');
    }

    async function sendDocumentRequests() {
      const practiceId = currentPractice?.id;
      if (!practiceId) return;

      const category = document.getElementById('request-category').value;
      const notes = document.getElementById('request-notes').value.trim();

      // Get selected doc types
      const checkboxes = document.querySelectorAll('#request-doc-type-list input[type="checkbox"]:checked');
      const selectedTypes = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTypes.length === 0) {
        alert('Please select at least one document type to request');
        return;
      }

      // Create requests
      const requests = selectedTypes.map(docType => ({
        practice_id: practiceId,
        document_type: docType,
        category_slug: category,
        status: 'requested',
        notes: notes || null,
        requested_by: currentUser?.id,
        requested_at: new Date().toISOString()
      }));

      try {
        const { error } = await window.sb
          .from('document_requests')
          .insert(requests);

        if (error) throw error;

        closeModal();
        await loadPendingRequests(practiceId);
        alert(`${selectedTypes.length} document request(s) created successfully!`);
      } catch (e) {
        console.error('Error creating requests:', e);
        alert('Failed to create requests: ' + e.message);
      }
    }

    async function loadPendingRequests(practiceId) {
      const section = document.getElementById('pending-requests-section');
      const list = document.getElementById('pending-requests-list');
      const countEl = document.getElementById('pending-requests-count');

      if (!section || !list) return;

      try {
        const { data: requests, error } = await window.sb
          .from('document_requests')
          .select('*')
          .eq('practice_id', practiceId)
          .neq('status', 'cancelled')
          .order('requested_at', { ascending: false });

        if (error) throw error;

        if (!requests || requests.length === 0) {
          section.style.display = 'none';
          return;
        }

        section.style.display = 'block';
        const pendingCount = requests.filter(r => r.status !== 'reviewed').length;
        countEl.textContent = pendingCount;

        let html = '';
        requests.forEach(req => {
          const statusIcon = req.status === 'requested' ? '' :
                            req.status === 'received' ? '' : '';
          const requestedDate = new Date(req.requested_at).toLocaleDateString();
          const docTypeLabel = formatDocumentType(req.document_type);

          let actionsHtml = '';
          if (req.status === 'requested') {
            actionsHtml = `
              <button class="btn-mark-received" onclick="updateRequestStatus('${req.id}', 'received')">Mark Received</button>
              <button class="btn-cancel-request" onclick="updateRequestStatus('${req.id}', 'cancelled')">Cancel</button>
            `;
          } else if (req.status === 'received') {
            actionsHtml = `
              <button class="btn-mark-reviewed" onclick="updateRequestStatus('${req.id}', 'reviewed')">Mark Reviewed</button>
            `;
          }

          html += `
            <div class="request-item">
              <div class="request-status-icon status-${req.status}">${statusIcon}</div>
              <div class="request-info">
                <div class="request-doc-type">${docTypeLabel}</div>
                <div class="request-meta">
                  <span class="request-status-badge status-${req.status}">${req.status}</span>
                  <span>Requested ${requestedDate}</span>
                  ${req.notes ? `<span title="${req.notes}"></span>` : ''}
                </div>
              </div>
              <div class="request-actions">
                ${actionsHtml}
              </div>
            </div>
          `;
        });

        list.innerHTML = html;

      } catch (e) {
        console.error('Error loading pending requests:', e);
        section.style.display = 'none';
      }
    }

    async function updateRequestStatus(requestId, newStatus) {
      const practiceId = currentPractice?.id;

      const updates = {
        status: newStatus,
        updated_at: new Date().toISOString()
      };

      if (newStatus === 'received') {
        updates.received_at = new Date().toISOString();
      } else if (newStatus === 'reviewed') {
        updates.reviewed_at = new Date().toISOString();
        updates.reviewed_by = currentUser?.id;
      }

      try {
        const { error } = await window.sb
          .from('document_requests')
          .update(updates)
          .eq('id', requestId);

        if (error) throw error;

        // Reload the requests list
        if (practiceId) {
          await loadPendingRequests(practiceId);
        }
      } catch (e) {
        console.error('Error updating request status:', e);
        alert('Failed to update status: ' + e.message);
      }
    }

    /**
     * toggleCollapsedTasks(groupId)
     * Expands/collapses the hidden tasks for a practice group
     */
    function toggleCollapsedTasks(groupId) {
      const collapsedDiv = document.getElementById(groupId);
      const icon = document.getElementById(groupId + '-icon');
      const text = document.getElementById(groupId + '-text');

      if (collapsedDiv) {
        const isExpanded = collapsedDiv.classList.toggle('expanded');
        if (icon) icon.innerHTML = isExpanded ? '&#9650;' : '&#9660;';
        if (text) {
          const taskCount = collapsedDiv.querySelectorAll('.operator-task-item').length;
          text.textContent = isExpanded
            ? `Hide ${taskCount} task${taskCount > 1 ? 's' : ''}`
            : `+${taskCount} more task${taskCount > 1 ? 's' : ''}`;
        }
      }
    }

    /**
     * copyDDPacketFromTask(practiceId)
     * Generates and copies DD packet for a practice (quick action)
     */
    function copyDDPacketFromTask(practiceId) {
      const practice = getPracticeById(practiceId);
      if (!practice) {
        alert('Practice not found');
        return;
      }

      // Generate DD packet content (reuse existing logic)
      const ddContent = generateDDPacketContent(practiceId);

      // Copy to clipboard
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(ddContent).then(() => {
          // Brief visual feedback
          const btn = event.target;
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          btn.style.background = '#10b981';
          btn.style.borderColor = '#10b981';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
            btn.style.borderColor = '';
          }, 1500);
        }).catch(() => {
          alert('Failed to copy. Please try again.');
        });
      } else {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = ddContent;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('DD Packet copied to clipboard');
      }
    }

    /**
     * generateDDPacketContent(practiceId)
     * Generates DD packet text content for clipboard
     */
    function generateDDPacketContent(practiceId) {
      const practice = getPracticeById(practiceId);
      if (!practice) return '';

      const owners = getOwnersByPractice(practiceId);
      const locations = getLocationsByPractice(practiceId);
      const latestRevenue = getLatestRevenue(practiceId);
      const intel = computePracticeIntelligence(practiceId);

      let content = `DD PACKET: ${practice.dba_name || practice.legal_name || 'Unnamed Practice'}\n`;
      content += `Generated: ${new Date().toLocaleDateString()}\n`;
      content += `${'='.repeat(50)}\n\n`;

      content += `PRACTICE OVERVIEW\n`;
      content += `-`.repeat(30) + `\n`;
      content += `Legal Name: ${practice.legal_name || 'N/A'}\n`;
      content += `DBA Name: ${practice.dba_name || 'N/A'}\n`;
      content += `Specialty: ${practice.specialty || 'N/A'}\n`;
      content += `Status: ${practice.status}\n`;
      content += `Completeness Score: ${intel.completeness_score}%\n`;
      content += `Health: ${intel.health}\n\n`;

      if (owners.length > 0) {
        content += `OWNERSHIP\n`;
        content += `-`.repeat(30) + `\n`;
        owners.forEach(owner => {
          content += `- ${owner.first_name} ${owner.last_name}`;
          if (owner.email) content += ` (${owner.email})`;
          content += `\n`;
        });
        content += `\n`;
      }

      if (locations.length > 0) {
        content += `LOCATIONS\n`;
        content += `-`.repeat(30) + `\n`;
        locations.forEach(loc => {
          content += `- ${loc.name || 'Primary'}: ${loc.city || 'N/A'}, ${loc.state || 'N/A'}\n`;
        });
        content += `\n`;
      }

      content += `FINANCIALS\n`;
      content += `-`.repeat(30) + `\n`;
      content += `Monthly Revenue: ${latestRevenue ? '$' + latestRevenue.toLocaleString() : 'N/A'}\n`;
      content += `Revenue Model: ${practice.revenue_model || 'N/A'}\n`;
      content += `Est. EBITDA Margin: ${practice.est_ebitda_margin || 'N/A'}\n\n`;

      if (intel.risks.length > 0) {
        content += `RISKS\n`;
        content += `-`.repeat(30) + `\n`;
        intel.risks.forEach(risk => {
          content += `- ${risk}\n`;
        });
        content += `\n`;
      }

      content += `${'='.repeat(50)}\n`;
      content += `End of DD Packet\n`;

      return content;
    }

    /**
     * handleOperatorTaskFilterChange(filterName, value)
     * Updates a filter and re-renders the task list
     */
    function handleOperatorTaskFilterChange(filterName, value) {
      operatorTaskFilters[filterName] = value || null;
      renderOperatorTasks();
    }

    /**
     * toggleCapitalOnlyFilter()
     * Toggles the capital-only filter
     */
    function toggleCapitalOnlyFilter() {
      operatorTaskFilters.capital_only = !operatorTaskFilters.capital_only;
      renderOperatorTasks();
    }

    /**
     * handleClearOperatorTaskFilters()
     * Clears all filters and re-renders
     */
    function handleClearOperatorTaskFilters() {
      clearOperatorTaskFilters();
      renderOperatorTasks();
    }

    /**
     * handleOperatorTaskClick(practiceId, taskType)
     * Opens the practice profile when a task is clicked
     */
    function handleOperatorTaskClick(practiceId, taskType) {
      // Open the practice profile
      openProfile(practiceId);

      // Optionally scroll to relevant section based on task type
      setTimeout(() => {
        let targetSection = null;

        // Map task types to profile sections
        const sectionMap = {
          'add_owner': 'owners-section',
          'add_location': 'location-section',
          'add_revenue': 'financial-section',
          'complete_onboarding_item': 'onboarding-section',
          'generate_capital_packet': 'dd-packet-section'
        };

        const sectionId = sectionMap[taskType];
        if (sectionId) {
          targetSection = document.getElementById(sectionId);
          if (targetSection) {
            targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }
      }, 300); // Wait for modal to open
    }

    // =============================================
    // DATA VALIDATION (Dev-Only)
    // =============================================
    // Validates that all records conform to canonical snake_case schema
    // Call from console: validateDb()

    function validateDb() {
      const errors = [];
      const warnings = [];

      // Define canonical field sets for each table
      const CANONICAL_FIELDS = {
        practices: ['id', 'created_at', 'created_by', 'updated_at', 'assigned_to', 'status', 'specialty', 'specialty_key', 'legal_name', 'dba_name', 'ownership_structure', 'primary_location_id', 'years_in_operation', 'num_providers', 'replacement_doctor_required', 'revenue_model', 'est_ebitda_margin', 'growth_rate_est', 'owner_age', 'owner_exit_intent', 'openness_to_rebrand', 'willingness_to_stay_on', 'tags', 'onboarding_state', 'risk_flags', 'data_version'],
        people: ['id', 'first_name', 'last_name', 'email', 'phone', 'created_at', 'updated_at'],
        locations: ['id', 'practice_id', 'name', 'address1', 'address2', 'city', 'state', 'zip', 'phone', 'fax', 'is_primary', 'services', 'created_at', 'updated_at'],
        metrics: ['id', 'practice_id', 'location_id', 'period', 'metric_type', 'value', 'source', 'created_at'],
        notes: ['id', 'practice_id', 'author_id', 'content', 'is_pinned', 'created_at', 'updated_at'],
        documents: ['id', 'practice_id', 'category', 'name', 'description', 'url', 'file_type', 'uploaded_by_id', 'expires_at', 'status', 'created_at', 'updated_at'],
        events: ['id', 'practice_id', 'event_type', 'actor_id', 'timestamp', 'payload'],
        practice_people: ['id', 'practice_id', 'person_id', 'role', 'is_primary', 'ownership_pct', 'created_at']
      };

      // Legacy fields that should NOT exist in canonical records
      const LEGACY_FIELDS = [
        'createdAt', 'updatedAt', 'practiceId', 'locationId', 'personId',
        'firstName', 'lastName', 'isPrimary', 'ownershipPct', 'reportsToId',
        'authorId', 'fileType', 'uploadedById', 'expiresAt', 'actorId',
        'entityType', 'entityId', 'legalName', 'name', 'action', 'changes', 'type'
      ];

      // Validate each table
      Object.keys(CANONICAL_FIELDS).forEach(tableName => {
        const table = db[tableName] || [];
        const canonicalFields = CANONICAL_FIELDS[tableName];

        table.forEach((record, idx) => {
          // Check for legacy fields
          LEGACY_FIELDS.forEach(legacyField => {
            if (legacyField in record) {
              errors.push(`${tableName}[${idx}] (id=${record.id}): has legacy field "${legacyField}"`);
            }
          });

          // Check for required fields
          if (!record.id) {
            errors.push(`${tableName}[${idx}]: missing required field "id"`);
          }

          // Check for foreign key integrity
          if (tableName !== 'practices' && record.practice_id) {
            const practice = db.practices.find(p => p.id === record.practice_id);
            if (!practice) {
              errors.push(`${tableName}[${idx}] (id=${record.id}): orphan record, practice_id "${record.practice_id}" not found`);
            }
          }

          // Check practice_people foreign keys
          if (tableName === 'practice_people') {
            if (record.person_id && !db.people.find(p => p.id === record.person_id)) {
              errors.push(`practice_people[${idx}] (id=${record.id}): person_id "${record.person_id}" not found in people`);
            }
          }
        });
      });

      // Summary
      const summary = {
        tables: {
          practices: db.practices.length,
          people: db.people.length,
          locations: db.locations.length,
          metrics: db.metrics.length,
          notes: db.notes.length,
          documents: db.documents.length,
          events: db.events.length,
          practice_people: db.practice_people.length
        },
        errors: errors.length,
        warnings: warnings.length,
        valid: errors.length === 0
      };

      console.log('========================================');
      console.log('DATABASE VALIDATION REPORT');
      console.log('========================================');
      console.log('Table counts:', summary.tables);
      console.log('');

      if (errors.length > 0) {
        console.log('ERRORS (' + errors.length + '):');
        errors.forEach(e => console.log('  - ' + e));
        console.log('');
      }

      if (warnings.length > 0) {
        console.log('WARNINGS (' + warnings.length + '):');
        warnings.forEach(w => console.log('  - ' + w));
        console.log('');
      }

      if (errors.length === 0) {
        console.log('All records conform to canonical snake_case schema.');
      }

      console.log('========================================');

      return { ...summary, errors, warnings };
    }

    // Expose validateDb to global scope for console access
    window.validateDb = validateDb;

    // =============================================
    // CAMELCASE SCANNING & REPAIR
    // =============================================

    // Known legacy keys that must be eliminated from storage
    // Note: 'name' is valid on locations, 'role' is valid on practice_people
    // These are specifically camelCase or deprecated snake_case keys
    const LEGACY_KEY_SET = new Set([
      // camelCase keys
      'createdAt', 'updatedAt', 'practiceId', 'personId', 'locationId',
      'authorId', 'actorId', 'firstName', 'lastName', 'isPrimary',
      'ownershipPct', 'reportsToId', 'entityType', 'entityId', 'fileType',
      'uploadedById', 'expiresAt', 'legalName'
      // Note: 'type' on metrics is now 'metric_type', but we handle it in migration
      // Note: 'changes', 'action', 'details' on events are legacy, use 'event_type', 'payload'
    ]);

    // Scan object for any keys containing uppercase letters (camelCase detection)
    function scanForCamelCaseKeys(obj, path = '', results = []) {
      if (obj === null || typeof obj !== 'object') return results;

      if (Array.isArray(obj)) {
        obj.forEach((item, idx) => {
          scanForCamelCaseKeys(item, `${path}[${idx}]`, results);
        });
      } else {
        Object.keys(obj).forEach(key => {
          const currentPath = path ? `${path}.${key}` : key;
          // Check if key contains any uppercase letter (camelCase indicator)
          if (/[A-Z]/.test(key)) {
            results.push({ path: currentPath, key: key });
          }
          // Recurse into nested objects (but skip certain known nested objects like onboarding_state, risk_flags)
          if (obj[key] !== null && typeof obj[key] === 'object' &&
              !['onboarding_state', 'risk_flags', 'payload'].includes(key)) {
            scanForCamelCaseKeys(obj[key], currentPath, results);
          }
        });
      }
      return results;
    }

    // Scan for known legacy keys specifically
    function scanForLegacyKeySet(obj, path = '', results = []) {
      if (obj === null || typeof obj !== 'object') return results;

      if (Array.isArray(obj)) {
        obj.forEach((item, idx) => {
          scanForLegacyKeySet(item, `${path}[${idx}]`, results);
        });
      } else {
        Object.keys(obj).forEach(key => {
          const currentPath = path ? `${path}.${key}` : key;
          if (LEGACY_KEY_SET.has(key)) {
            results.push({ path: currentPath, key: key, value: obj[key] });
          }
          // Recurse into nested objects
          if (obj[key] !== null && typeof obj[key] === 'object' &&
              !['onboarding_state', 'risk_flags', 'payload'].includes(key)) {
            scanForLegacyKeySet(obj[key], currentPath, results);
          }
        });
      }
      return results;
    }

    // Mapping from legacy keys to canonical keys
    const LEGACY_TO_CANONICAL = {
      'createdAt': 'created_at',
      'updatedAt': 'updated_at',
      'practiceId': 'practice_id',
      'personId': 'person_id',
      'locationId': 'location_id',
      'authorId': 'author_id',
      'actorId': 'actor_id',
      'firstName': 'first_name',
      'lastName': 'last_name',
      'isPrimary': 'is_primary',
      'ownershipPct': 'ownership_pct',
      'reportsToId': 'reports_to_id',
      'entityType': null,  // Delete, not converted
      'entityId': null,    // Delete, not converted
      'fileType': 'file_type',
      'uploadedById': 'uploaded_by_id',
      'expiresAt': 'expires_at',
      'legalName': 'legal_name',
      'changes': null,     // Delete (use payload)
      'action': null,      // Delete (use event_type)
      'details': null      // Delete
    };

    // Repair a single record by removing legacy keys
    function repairRecord(record) {
      if (!record || typeof record !== 'object') return record;

      const repaired = { ...record };
      let modified = false;

      LEGACY_KEY_SET.forEach(legacyKey => {
        if (legacyKey in repaired) {
          const canonicalKey = LEGACY_TO_CANONICAL[legacyKey];
          // If there's a canonical equivalent and it's not already set, copy the value
          if (canonicalKey && !(canonicalKey in repaired)) {
            repaired[canonicalKey] = repaired[legacyKey];
          }
          // Delete the legacy key
          delete repaired[legacyKey];
          modified = true;
        }
      });

      return repaired;
    }

    // Repair entire database to canonical format
    function repairDbToCanonical() {
      console.log('========================================');
      console.log('REPAIRING DATABASE TO CANONICAL FORMAT');
      console.log('========================================');

      let totalRepaired = 0;

      // Repair each table
      const tables = ['practices', 'people', 'locations', 'metrics', 'notes', 'documents', 'events', 'practice_people'];

      tables.forEach(tableName => {
        const table = db[tableName] || [];
        let tableRepairs = 0;

        db[tableName] = table.map(record => {
          const before = JSON.stringify(record);
          const repaired = repairRecord(record);
          const after = JSON.stringify(repaired);

          if (before !== after) {
            tableRepairs++;
            totalRepaired++;
          }
          return repaired;
        });

        if (tableRepairs > 0) {
          console.log(`  Repaired ${tableRepairs} records in ${tableName}`);
        }
      });

      if (totalRepaired > 0) {
        saveDb();
        console.log(`\nTotal: ${totalRepaired} records repaired and saved.`);
      } else {
        console.log('No repairs needed - database is already canonical.');
      }

      console.log('========================================');
      return totalRepaired;
    }

    // Check for orphan foreign keys
    function countOrphanFKs() {
      let orphans = 0;
      const practiceIds = new Set(db.practices.map(p => p.id));
      const personIds = new Set(db.people.map(p => p.id));

      // Check practice_id references
      ['locations', 'metrics', 'notes', 'documents', 'events', 'practice_people'].forEach(table => {
        (db[table] || []).forEach(record => {
          if (record.practice_id && !practiceIds.has(record.practice_id)) {
            orphans++;
          }
        });
      });

      // Check person_id references in practice_people
      (db.practice_people || []).forEach(pp => {
        if (pp.person_id && !personIds.has(pp.person_id)) {
          orphans++;
        }
      });

      return orphans;
    }

    // Full diagnostics function
    function diagnostics() {
      console.log('');
      console.log('');
      console.log('              ZENYTE DATABASE DIAGNOSTICS                     ');
      console.log('');
      console.log('');

      // Schema version
      console.log('SCHEMA VERSION:', DATA_VERSION);
      console.log('');

      // Record counts
      console.log('RECORD COUNTS:');
      const tables = ['practices', 'people', 'locations', 'metrics', 'notes', 'documents', 'events', 'practice_people'];
      tables.forEach(t => {
        console.log(`  ${t}: ${(db[t] || []).length}`);
      });
      console.log('');

      // Scan for camelCase keys
      const camelCaseViolations = scanForCamelCaseKeys(db);
      console.log('CAMELCASE KEY VIOLATIONS:', camelCaseViolations.length);
      if (camelCaseViolations.length > 0) {
        camelCaseViolations.slice(0, 10).forEach(v => {
          console.log(`  - ${v.path}`);
        });
        if (camelCaseViolations.length > 10) {
          console.log(`  ... and ${camelCaseViolations.length - 10} more`);
        }
      }
      console.log('');

      // Scan for legacy keys specifically
      const legacyKeyViolations = scanForLegacyKeySet(db);
      console.log('LEGACY KEY VIOLATIONS:', legacyKeyViolations.length);
      if (legacyKeyViolations.length > 0) {
        legacyKeyViolations.slice(0, 10).forEach(v => {
          console.log(`  - ${v.path}: "${v.key}"`);
        });
        if (legacyKeyViolations.length > 10) {
          console.log(`  ... and ${legacyKeyViolations.length - 10} more`);
        }
      }
      console.log('');

      // Orphan FK count
      const orphanCount = countOrphanFKs();
      console.log('ORPHAN FOREIGN KEYS:', orphanCount);
      console.log('');

      // Validation summary
      const validation = validateDb();
      console.log('');

      // Overall status
      const isClean = camelCaseViolations.length === 0 &&
                      legacyKeyViolations.length === 0 &&
                      validation.errors === 0;

      console.log('');
      if (isClean) {
        console.log('   DATABASE IS CANONICAL AND VALID                          ');
      } else {
        console.log('   DATABASE HAS ISSUES - RUN repairDbToCanonical()          ');
      }
      console.log('');
      console.log('');

      return {
        schemaVersion: DATA_VERSION,
        recordCounts: Object.fromEntries(tables.map(t => [t, (db[t] || []).length])),
        camelCaseViolations: camelCaseViolations.length,
        legacyKeyViolations: legacyKeyViolations.length,
        orphanFKs: orphanCount,
        validationErrors: validation.errors,
        isClean: isClean
      };
    }

    // Show validation banner if needed
    function showValidationBanner(message) {
      // Remove existing banner if any
      const existing = document.getElementById('validation-banner');
      if (existing) existing.remove();

      const banner = document.createElement('div');
      banner.id = 'validation-banner';
      banner.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: #c62828;
        color: white;
        padding: 12px 20px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      `;
      banner.innerHTML = `
        <span> ${message}</span>
        <button onclick="this.parentElement.remove()" style="background:none;border:none;color:white;font-size:18px;cursor:pointer;"></button>
      `;
      document.body.prepend(banner);
    }

    // Boot-time validation and auto-repair
    // Ensure all practices have specialty_key derived from specialty
    function ensureSpecialtyKeys() {
      let updated = false;
      db.practices.forEach(practice => {
        if (!practice.specialty_key && practice.specialty) {
          practice.specialty_key = deriveSpecialtyKey(practice.specialty);
          updated = true;
        } else if (!practice.specialty_key) {
          practice.specialty_key = null;
        }
      });
      if (updated) {
        console.log('[Boot] Populated missing specialty_key fields');
        saveDb();
      }
    }

    function runBootValidation() {
      console.log('[Boot] Running database validation...');

      // First, run upgrade if needed
      upgradeToV1Schema();

      // Ensure specialty_key is populated for all practices
      ensureSpecialtyKeys();

      // Scan for issues
      const camelCaseIssues = scanForCamelCaseKeys(db);
      const legacyIssues = scanForLegacyKeySet(db);

      if (camelCaseIssues.length > 0 || legacyIssues.length > 0) {
        console.log(`[Boot] Found ${camelCaseIssues.length} camelCase violations, ${legacyIssues.length} legacy key violations`);
        console.log('[Boot] Running auto-repair...');

        // Run repair
        repairDbToCanonical();

        // Re-scan after repair
        const postRepairCamelCase = scanForCamelCaseKeys(db);
        const postRepairLegacy = scanForLegacyKeySet(db);

        if (postRepairCamelCase.length > 0 || postRepairLegacy.length > 0) {
          console.error('[Boot] Repair incomplete! Remaining violations:',
            postRepairCamelCase.length + postRepairLegacy.length);
          showValidationBanner('Database schema validation failed. Open console and run diagnostics().');
        } else {
          console.log('[Boot]  Database repaired successfully');
        }
      } else {
        console.log('[Boot]  Database is canonical');
      }

      // Run full validation
      const validation = validateDb();
      if (validation.errors > 0) {
        console.warn(`[Boot] Validation found ${validation.errors} errors`);
      }
    }

    // Expose functions to global scope
    window.scanForCamelCaseKeys = scanForCamelCaseKeys;
    window.scanForLegacyKeySet = scanForLegacyKeySet;
    window.repairDbToCanonical = repairDbToCanonical;
    window.diagnostics = diagnostics;

    // =============================================
    // DATA MIGRATION (Legacy  Canonical v1)
    // =============================================

    // Create a canonical Practice v1 record (snake_case only, no legacy fields)
    function createCanonicalPractice(data, now) {
      return {
        // Immutable
        id: data.id || generatePracticeId(),
        created_at: data.createdAt || data.created_at || now,
        created_by: data.created_by || null,

        // Mutable - Core
        updated_at: data.updatedAt || data.updated_at || now,
        assigned_to: data.assigned_to || null,
        status: data.status || 'Lead',
        specialty: data.specialty || null,
        specialty_key: data.specialty_key || deriveSpecialtyKey(data.specialty || ''),
        legal_name: data.legal_name || data.legalName || data.name || '',
        dba_name: data.dba_name || data.name || '',
        ownership_structure: data.ownership_structure || 'Unknown',
        primary_location_id: data.primary_location_id || null,

        // Operations
        years_in_operation: data.years_in_operation ?? null,
        num_providers: data.num_providers ?? null,
        replacement_doctor_required: data.replacement_doctor_required || 'Unknown',

        // Financial Indicators
        revenue_model: data.revenue_model || null,
        est_ebitda_margin: data.est_ebitda_margin ?? null,
        growth_rate_est: data.growth_rate_est || 'Unknown',

        // Ownership / Exit Context
        owner_age: data.owner_age ?? null,
        owner_exit_intent: data.owner_exit_intent || 'Unknown',
        openness_to_rebrand: data.openness_to_rebrand || 'Unknown',
        willingness_to_stay_on: data.willingness_to_stay_on || 'Unknown',

        // Internal Tags
        tags: data.tags || [],

        // Onboarding state
        onboarding_state: data.onboarding_state || {
          checklist_version: 'v1',
          items: JSON.parse(JSON.stringify(DEFAULT_ONBOARDING_CHECKLIST)),
          last_reviewed_at: null
        },

        // Risk flags (computed)
        risk_flags: data.risk_flags || {
          missing_fields: [],
          aging_flags: [],
          computed_at: now
        },

        // Version
        data_version: DATA_VERSION,
        // NO legacy fields (name, createdAt, updatedAt) - use helpers for display

        // Multi-tenancy
        org_id: data.org_id || window.currentOrgId
      };
    }

    // Create canonical person record (snake_case only)
    function createCanonicalPerson(data, now) {
      return {
        id: data.id || generatePersonId(),
        first_name: data.first_name || data.firstName || '',
        last_name: data.last_name || data.lastName || '',
        email: data.email || '',
        phone: data.phone || '',
        created_at: data.created_at || data.createdAt || now,
        updated_at: data.updated_at || data.updatedAt || now,
        org_id: data.org_id || window.currentOrgId
      };
    }

    // Create canonical location record (snake_case only)
    function createCanonicalLocation(data, now) {
      return {
        id: data.id || generateLocationId(),
        practice_id: data.practice_id || data.practiceId,
        name: data.name || '',
        address1: data.address1 || '',
        address2: data.address2 || '',
        city: data.city || '',
        state: data.state || '',
        zip: data.zip || '',
        phone: data.phone || '',
        fax: data.fax || '',
        is_primary: data.is_primary || data.isPrimary || false,
        services: data.services || [],
        created_at: data.created_at || data.createdAt || now,
        updated_at: data.updated_at || data.updatedAt || now,
        org_id: data.org_id || window.currentOrgId
      };
    }

    // Create canonical metric record (snake_case only)
    function createCanonicalMetric(data, now) {
      return {
        id: data.id || generateMetricId(),
        practice_id: data.practice_id || data.practiceId,
        location_id: data.location_id || data.locationId || null,
        period: data.period,
        metric_type: data.metric_type || data.type || 'monthly_revenue',
        value: data.value,
        source: data.source || 'manual',
        created_at: data.created_at || data.createdAt || now,
        org_id: data.org_id || window.currentOrgId
      };
    }

    // Create canonical note record (snake_case only)
    function createCanonicalNote(data, now) {
      return {
        id: data.id || generateNoteId(),
        practice_id: data.practice_id || data.practiceId,
        author_id: data.author_id || data.authorId || 'system',
        content: data.content || '',
        is_pinned: data.is_pinned || data.isPinned || false,
        created_at: data.created_at || data.createdAt || now,
        updated_at: data.updated_at || data.updatedAt || now,
        org_id: data.org_id || window.currentOrgId
      };
    }

    // Create canonical document record (snake_case only)
    function createCanonicalDocument(data, now) {
      return {
        id: data.id || generateDocumentId(),
        practice_id: data.practice_id || data.practiceId,
        category: data.category || 'other',
        name: data.name || '',
        description: data.description || '',
        url: data.url || '',
        file_type: data.file_type || data.fileType || '',
        uploaded_by_id: data.uploaded_by_id || data.uploadedById || null,
        expires_at: data.expires_at || data.expiresAt || null,
        status: data.status || 'pending',
        created_at: data.created_at || data.createdAt || now,
        updated_at: data.updated_at || data.updatedAt || now,
        org_id: data.org_id || window.currentOrgId
      };
    }

    // Create canonical event record (snake_case only)
    function createCanonicalEvent(data, now) {
      return {
        id: data.id || generateEventId(),
        practice_id: data.practice_id || data.practiceId,
        event_type: data.event_type || data.action || 'unknown',
        actor_id: data.actor_id || data.actorId || null,
        timestamp: data.timestamp || now,
        payload: data.payload || data.changes || null,
        org_id: data.org_id || window.currentOrgId
      };
    }

    // Create canonical practice_people link (snake_case only)
    function createCanonicalPracticePersonLink(data, now) {
      return {
        id: data.id || generatePracticePersonId(),
        practice_id: data.practice_id,
        person_id: data.person_id,
        role: data.role || 'owner',
        is_primary: data.is_primary || false,
        ownership_pct: data.ownership_pct || null,
        created_at: data.created_at || now
      };
    }

    function migrateFromLegacyFormat() {
      const legacyData = localStorage.getItem(LEGACY_STORAGE_KEY);
      if (!legacyData) return false;

      const legacyPractices = JSON.parse(legacyData);
      if (!Array.isArray(legacyPractices) || legacyPractices.length === 0) return false;

      console.log('Migrating', legacyPractices.length, 'practices from legacy format to canonical v1...');

      legacyPractices.forEach(legacy => {
        const now = new Date().toISOString();
        const practiceId = legacy.id || generatePracticeId();

        // Create canonical Practice v1 record (NO legacy fields)
        const practice = createCanonicalPractice({
          id: practiceId,
          name: legacy.name || '',
          legal_name: legacy.name || '',
          dba_name: legacy.name || '',
          specialty: legacy.specialty || null,
          status: legacy.status || 'Lead',
          ownership_structure: 'Unknown',
          created_at: legacy.createdAt || now,
          updated_at: legacy.updatedAt || now
        }, now);

        db.practices.push(practice);

        // Create person record and join table entry for owner
        if (legacy.owner) {
          const nameParts = legacy.owner.trim().split(' ');
          const personId = generatePersonId();

          // Use canonical person creator (NO legacy fields)
          const person = createCanonicalPerson({
            id: personId,
            first_name: nameParts[0] || '',
            last_name: nameParts.slice(1).join(' ') || '',
            created_at: legacy.createdAt || now,
            updated_at: legacy.updatedAt || now
          }, now);
          db.people.push(person);

          // Use canonical link creator (NO legacy fields)
          const link = createCanonicalPracticePersonLink({
            practice_id: practiceId,
            person_id: personId,
            role: 'owner',
            is_primary: true,
            ownership_pct: 100
          }, now);
          db.practice_people.push(link);
        }

        // Create metric record for revenue (NO legacy fields)
        if (legacy.revenue && Number(legacy.revenue) > 0) {
          const metric = createCanonicalMetric({
            practice_id: practiceId,
            period: getCurrentPeriod(),
            metric_type: 'monthly_revenue',
            value: Number(legacy.revenue),
            source: 'migrated',
            created_at: legacy.updatedAt || now
          }, now);
          db.metrics.push(metric);
        }

        // Create note record (NO legacy fields)
        if (legacy.notes && legacy.notes.trim()) {
          const note = createCanonicalNote({
            practice_id: practiceId,
            author_id: 'system',
            content: legacy.notes.trim(),
            is_pinned: false,
            created_at: legacy.createdAt || now,
            updated_at: legacy.updatedAt || now
          }, now);
          db.notes.push(note);
        }

        // Convert activity log to events (NO legacy fields)
        let hasCreatedEvent = false;
        if (legacy.activityLog && Array.isArray(legacy.activityLog)) {
          legacy.activityLog.forEach(entry => {
            const eventTypeMap = {
              'Created': 'practice_created',
              'Edited': 'practice_edited',
              'Status Changed': 'status_changed',
              'Deleted': 'practice_deleted'
            };
            const eventType = eventTypeMap[entry.action] || 'practice_edited';
            if (eventType === 'practice_created') hasCreatedEvent = true;

            const event = createCanonicalEvent({
              practice_id: practiceId,
              event_type: eventType,
              actor_id: null,
              timestamp: entry.timestamp || now,
              payload: { details: entry.details }
            }, now);
            db.events.push(event);
          });
        }

        // Generate practice_created event if missing (NO legacy fields)
        if (!hasCreatedEvent) {
          const createdEvent = createCanonicalEvent({
            practice_id: practiceId,
            event_type: 'practice_created',
            actor_id: null,
            timestamp: legacy.createdAt || now,
            payload: { source: 'migration' }
          }, now);
          db.events.push(createdEvent);
        }
      });

      saveDb();

      // Compute risk flags for all migrated practices
      db.practices.forEach(p => updatePracticeRiskFlags(p.id));

      console.log('Migration to canonical v1 complete. DB:', db);
      return true;
    }

    // Strip legacy camelCase keys from an object
    function stripLegacyKeys(obj) {
      const legacyKeys = [
        'createdAt', 'updatedAt', 'practiceId', 'locationId', 'personId',
        'firstName', 'lastName', 'isPrimary', 'ownershipPct', 'reportsToId',
        'authorId', 'fileType', 'uploadedById', 'expiresAt', 'actorId',
        'entityType', 'entityId', 'legalName', 'name'
      ];
      legacyKeys.forEach(key => {
        if (key in obj) delete obj[key];
      });
      return obj;
    }

    // Upgrade existing normalized data to canonical v1 schema
    function upgradeToV1Schema() {
      let upgraded = false;
      const now = new Date().toISOString();

      // Upgrade practices
      db.practices = db.practices.map(practice => {
        if (practice.data_version === DATA_VERSION && !practice.createdAt) {
          return practice; // Already canonical
        }

        console.log('Upgrading practice', practice.id, 'to canonical v1...');

        const canonical = createCanonicalPractice({
          id: practice.id,
          created_at: practice.created_at || practice.createdAt,
          updated_at: practice.updated_at || practice.updatedAt,
          created_by: practice.created_by,
          assigned_to: practice.assigned_to,
          status: practice.status,
          specialty: practice.specialty,
          legal_name: practice.legal_name || practice.legalName || practice.name,
          dba_name: practice.dba_name || practice.name,
          ownership_structure: practice.ownership_structure,
          primary_location_id: practice.primary_location_id,
          onboarding_state: practice.onboarding_state,
          risk_flags: practice.risk_flags
        }, now);

        upgraded = true;
        return canonical;
      });

      // Upgrade people and create join entries
      db.people = db.people.map(person => {
        if (!person.firstName && !person.practiceId) {
          return person; // Already canonical
        }

        // Create join entry for legacy people with practiceId
        if (person.practiceId && person.role === 'owner') {
          const existingLink = db.practice_people.find(pp =>
            pp.practice_id === person.practiceId && pp.person_id === person.id
          );
          if (!existingLink) {
            db.practice_people.push(createCanonicalPracticePersonLink({
              practice_id: person.practiceId,
              person_id: person.id,
              role: 'owner',
              is_primary: person.isPrimary || false,
              ownership_pct: person.ownershipPct || null
            }, now));
          }
        }

        const canonical = createCanonicalPerson({
          id: person.id,
          first_name: person.first_name || person.firstName,
          last_name: person.last_name || person.lastName,
          email: person.email,
          phone: person.phone,
          created_at: person.created_at || person.createdAt,
          updated_at: person.updated_at || person.updatedAt
        }, now);

        upgraded = true;
        return canonical;
      });

      // Upgrade locations
      db.locations = db.locations.map(location => {
        if (!location.practiceId && location.practice_id) {
          return location; // Already canonical
        }

        const canonical = createCanonicalLocation({
          id: location.id,
          practice_id: location.practice_id || location.practiceId,
          name: location.name,
          address1: location.address1,
          address2: location.address2,
          city: location.city,
          state: location.state,
          zip: location.zip,
          phone: location.phone,
          fax: location.fax,
          is_primary: location.is_primary || location.isPrimary,
          services: location.services,
          created_at: location.created_at || location.createdAt,
          updated_at: location.updated_at || location.updatedAt
        }, now);

        upgraded = true;
        return canonical;
      });

      // Upgrade metrics
      db.metrics = db.metrics.map(metric => {
        if (!metric.practiceId && metric.practice_id && metric.metric_type) {
          return metric; // Already canonical
        }

        const canonical = createCanonicalMetric({
          id: metric.id,
          practice_id: metric.practice_id || metric.practiceId,
          location_id: metric.location_id || metric.locationId,
          period: metric.period,
          metric_type: metric.metric_type || metric.type,
          value: metric.value,
          source: metric.source || 'manual',
          created_at: metric.created_at || metric.createdAt
        }, now);

        upgraded = true;
        return canonical;
      });

      // Upgrade notes
      db.notes = db.notes.map(note => {
        if (!note.practiceId && note.practice_id) {
          return note; // Already canonical
        }

        const canonical = createCanonicalNote({
          id: note.id,
          practice_id: note.practice_id || note.practiceId,
          author_id: note.author_id || note.authorId,
          content: note.content,
          is_pinned: note.is_pinned || note.isPinned,
          created_at: note.created_at || note.createdAt,
          updated_at: note.updated_at || note.updatedAt
        }, now);

        upgraded = true;
        return canonical;
      });

      // Upgrade events
      db.events = db.events.map(event => {
        if (!event.practiceId && event.practice_id && !event.entityType) {
          return event; // Already canonical
        }

        const canonical = createCanonicalEvent({
          id: event.id,
          practice_id: event.practice_id || event.practiceId,
          event_type: event.event_type || event.action,
          actor_id: event.actor_id || event.actorId,
          timestamp: event.timestamp,
          payload: event.payload || event.changes
        }, now);

        upgraded = true;
        return canonical;
      });

      // Upgrade documents
      db.documents = db.documents.map(doc => {
        if (!doc.practiceId && doc.practice_id) {
          return doc; // Already canonical
        }

        const canonical = createCanonicalDocument({
          id: doc.id,
          practice_id: doc.practice_id || doc.practiceId,
          category: doc.category,
          name: doc.name,
          description: doc.description,
          url: doc.url,
          file_type: doc.file_type || doc.fileType,
          uploaded_by_id: doc.uploaded_by_id || doc.uploadedById,
          expires_at: doc.expires_at || doc.expiresAt,
          status: doc.status,
          created_at: doc.created_at || doc.createdAt,
          updated_at: doc.updated_at || doc.updatedAt
        }, now);

        upgraded = true;
        return canonical;
      });

      // Compute risk flags for upgraded practices
      if (upgraded) {
        db.practices.forEach(p => {
          if (!p.risk_flags || !p.risk_flags.computed_at) {
            p.risk_flags = computePracticeRiskFlags(p.id);
          }
        });
        saveDb();
        console.log('Schema upgrade to canonical v1 complete');
      }
      return upgraded;
    }

    // =============================================
    // INITIALIZATION
    // =============================================
    async function initializeDatabase() {
      // Check if we should load from Supabase
      if (DATA_SOURCE === 'supabase') {
        try {
          console.log('[Supabase] starting loadDbFromSupabase');
          const supabaseDb = await loadDbFromSupabase();
          db = supabaseDb;
          console.log('[Supabase] Loaded database with', db.practices.length, 'practices');
          updateDataSourceBanner('supabase');
          return;
        } catch (err) {
          console.error('[Supabase] load failed:', err);
          if (err.message) {
            console.error('[Supabase] error message:', err.message);
          }
          updateDataSourceBanner('local', err.message || 'Unknown error');
          // Fall through to localStorage loading
        }
      }

      // Load from localStorage
      updateDataSourceBanner('local');

      // Try to load existing normalized DB
      if (loadDb() && db.practices.length > 0) {
        console.log('Loaded normalized database with', db.practices.length, 'practices');
        // Run boot validation (includes upgrade + repair + validation)
        runBootValidation();
        return;
      }

      // Try to migrate from legacy format
      if (migrateFromLegacyFormat()) {
        console.log('Migrated from legacy format to Practice v1');
        // Run boot validation after migration
        runBootValidation();
        return;
      }

      // Fresh start
      console.log('Starting with empty database');
      saveDb();
    }

    // =============================================
    // FORMATTING HELPERS
    // =============================================
    function formatCurrency(num) {
      return '$' + Number(num).toLocaleString();
    }

    function formatYesNoUnknown(value) {
      const map = { 'yes': 'Yes', 'no': 'No', 'unknown': 'Unknown', 'Yes': 'Yes', 'No': 'No', 'Unknown': 'Unknown', 'Maybe': 'Maybe' };
      return map[value] || 'Not set';
    }

    function formatRevenueModel(value) {
      const map = { 'cash': 'Cash-Pay', 'insurance': 'Insurance', 'hybrid': 'Hybrid' };
      return map[value] || 'Not set';
    }

    function formatGrowthRate(value) {
      const map = { 'declining': 'Declining', 'flat': 'Flat', 'growing': 'Growing', 'unknown': 'Unknown', 'Declining': 'Declining', 'Flat': 'Flat', 'Growing': 'Growing', 'Unknown': 'Unknown' };
      return map[value] || 'Not set';
    }

    function formatExitIntent(value) {
      const map = { '1-2yrs': '1-2 Years', '3-5yrs': '3-5 Years', '5+yrs': '5+ Years', 'unknown': 'Unknown', 'Unknown': 'Unknown' };
      return map[value] || 'Not set';
    }

    function formatStayOn(value) {
      const map = { 'full': 'Full-Time', 'part-time': 'Part-Time', 'no': 'No', 'unknown': 'Unknown', 'Full-Time': 'Full-Time', 'Part-Time': 'Part-Time', 'No': 'No', 'Unknown': 'Unknown' };
      return map[value] || 'Not set';
    }

    function formatYesNoMaybe(value) {
      const map = { 'yes': 'Yes', 'no': 'No', 'maybe': 'Maybe', 'Yes': 'Yes', 'No': 'No', 'Maybe': 'Maybe' };
      return map[value] || 'Not set';
    }

    function formatRealEstateStatus(value) {
      const map = { 'owned': 'Owned', 'leased': 'Leased', 'mixed': 'Mixed', 'unknown': 'Unknown' };
      return map[value] || 'Not set';
    }

    function formatFacilityCondition(value) {
      const map = { 'excellent': 'Excellent', 'good': 'Good', 'fair': 'Fair', 'poor': 'Poor', 'unknown': 'Unknown' };
      return map[value] || 'Not set';
    }

    function formatDealStructure(value) {
      const map = { 'asset': 'Asset Sale', 'stock': 'Stock Sale', 'merger': 'Merger', 'flexible': 'Flexible', 'unknown': 'Unknown' };
      return map[value] || 'Not set';
    }

    function formatExclusivityStatus(value) {
      const map = { 'none': 'None', 'active': 'Active', 'expired': 'Expired', 'pending': 'Pending' };
      return map[value] || 'Not set';
    }

    function formatMarketPosition(value) {
      const map = { 'leader': 'Market Leader', 'strong': 'Strong', 'average': 'Average', 'weak': 'Weak', 'new_entrant': 'New Entrant' };
      return map[value] || 'Not set';
    }

    function formatCompetitionDensity(value) {
      const map = { 'low': 'Low', 'moderate': 'Moderate', 'high': 'High', 'saturated': 'Saturated' };
      return map[value] || 'Not set';
    }

    function formatPercent(value) {
      if (value === null || value === undefined) return 'Not set';
      return value + '%';
    }

    function updateMetrics() {
      const practices = getPractices();
      const total = practices.length;
      const leads = practices.filter(p => p.status === 'Lead').length;
      const onboarding = practices.filter(p => p.status === 'Onboarding').length;
      const active = practices.filter(p => p.status === 'Active').length;
      const revenue = practices.reduce((sum, p) => sum + Number(p.revenue), 0);

      document.getElementById('metric-total').textContent = total;
      document.getElementById('metric-leads').textContent = leads;
      document.getElementById('metric-onboarding').textContent = onboarding;
      document.getElementById('metric-active').textContent = active;
      document.getElementById('metric-revenue').textContent = formatCurrency(revenue);
    }

    function createConfetti(x, y) {
      const colors = ['#4a6cf7', '#2e7d32', '#e65100', '#c62828', '#7b1fa2'];
      const container = document.createElement('div');
      container.className = 'confetti';
      container.style.left = x + 'px';
      container.style.top = y + 'px';

      for (let i = 0; i < 30; i++) {
        const piece = document.createElement('div');
        piece.className = 'confetti-piece';
        piece.style.background = colors[Math.floor(Math.random() * colors.length)];
        piece.style.left = (Math.random() * 200 - 100) + 'px';
        piece.style.animationDelay = (Math.random() * 0.3) + 's';
        piece.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
        container.appendChild(piece);
      }

      document.body.appendChild(container);
      setTimeout(() => container.remove(), 2000);
    }

    // =============================================
    // VIEW TOGGLE
    // =============================================
    function setView(view) {
      currentView = view;
      const tableContainer = document.getElementById('table-container');
      const pipelineContainer = document.getElementById('pipeline-container');
      const portfolioContainer = document.getElementById('portfolio-container');
      const operatorTasksContainer = document.getElementById('operator-tasks-container');
      const dashboardContainer = document.getElementById('dashboard-container');
      const btnTable = document.getElementById('btn-table-view');
      const btnPipeline = document.getElementById('btn-pipeline-view');
      const btnPortfolio = document.getElementById('btn-portfolio-view');
      const btnOperatorTasks = document.getElementById('btn-operator-tasks-view');
      const btnDashboard = document.getElementById('btn-dashboard-view');

      // Reset all views
      tableContainer.classList.add('hidden');
      pipelineContainer.classList.remove('visible');
      portfolioContainer.classList.remove('visible');
      if (operatorTasksContainer) operatorTasksContainer.style.display = 'none';
      if (dashboardContainer) dashboardContainer.classList.remove('visible');
      btnTable.classList.remove('active');
      btnPipeline.classList.remove('active');
      btnPortfolio.classList.remove('active');
      if (btnOperatorTasks) btnOperatorTasks.classList.remove('active');
      if (btnDashboard) btnDashboard.classList.remove('active');

      if (view === 'table') {
        tableContainer.classList.remove('hidden');
        btnTable.classList.add('active');
      } else if (view === 'pipeline') {
        pipelineContainer.classList.add('visible');
        btnPipeline.classList.add('active');
        renderPipeline();
      } else if (view === 'portfolio') {
        portfolioContainer.classList.add('visible');
        btnPortfolio.classList.add('active');
        renderPortfolioIntelligence();
      } else if (view === 'operator-tasks') {
        if (operatorTasksContainer) {
          operatorTasksContainer.style.display = 'block';
          btnOperatorTasks.classList.add('active');
          renderOperatorTasks();
        }
      } else if (view === 'dashboard') {
        if (dashboardContainer) {
          dashboardContainer.classList.add('visible');
          btnDashboard.classList.add('active');
          renderDashboard();
        }
      }
    }

    // =============================================
    // TABLE VIEW RENDERING
    // =============================================
    function renderTable() {
      const tbody = document.getElementById('practices-table');
      const practices = hasActiveFilters() ? getFilteredPractices() : getPractices();

      tbody.innerHTML = '';

      if (practices.length === 0) {
        const message = hasActiveFilters()
          ? 'No practices match the current filters.'
          : 'No practices yet. Add one above.';
        tbody.innerHTML = `<tr class="empty-state"><td colspan="6">${message}</td></tr>`;
        return;
      }

      practices.forEach((practice) => {
        const row = document.createElement('tr');
        const statusClass = 'status-' + practice.status.toLowerCase();
        const isActive = practice.status === 'Active';

        row.innerHTML = `
          <td><span class="practice-name-link" onclick="openProfile('${practice.id}')">${practice.name}</span></td>
          <td>${practice.specialty}</td>
          <td>${practice.owner}</td>
          <td>${formatCurrency(practice.revenue)}</td>
          <td><span class="status-badge ${statusClass}">${practice.status}</span></td>
          <td class="actions">
            <button class="btn btn-small btn-advance" onclick="advanceStatus('${practice.id}', event)" ${isActive ? 'disabled' : ''}>
              ${isActive ? 'Active' : 'Advance'}
            </button>
            <button class="btn btn-small btn-delete" onclick="deletePractice('${practice.id}')">Delete</button>
          </td>
        `;
        tbody.appendChild(row);
      });
    }

    // =============================================
    // PIPELINE VIEW RENDERING
    // =============================================
    function renderPipeline() {
      const leadContainer = document.getElementById('pipeline-lead');
      const onboardingContainer = document.getElementById('pipeline-onboarding');
      const activeContainer = document.getElementById('pipeline-active');
      const practices = hasActiveFilters() ? getFilteredPractices() : getPractices();

      // Clear existing cards
      leadContainer.innerHTML = '';
      onboardingContainer.innerHTML = '';
      activeContainer.innerHTML = '';

      // Filter practices by status
      const leads = practices.filter(p => p.status === 'Lead');
      const onboarding = practices.filter(p => p.status === 'Onboarding');
      const active = practices.filter(p => p.status === 'Active');

      // Update column counts
      document.getElementById('pipeline-lead-count').textContent = leads.length;
      document.getElementById('pipeline-onboarding-count').textContent = onboarding.length;
      document.getElementById('pipeline-active-count').textContent = active.length;

      // Render cards for each column
      leads.forEach((practice) => {
        leadContainer.appendChild(createPipelineCard(practice));
      });

      onboarding.forEach((practice) => {
        onboardingContainer.appendChild(createPipelineCard(practice));
      });

      active.forEach((practice) => {
        activeContainer.appendChild(createPipelineCard(practice));
      });

      // Show empty state if no cards in column
      if (leads.length === 0) {
        leadContainer.innerHTML = '<div class="pipeline-empty">No leads</div>';
      }
      if (onboarding.length === 0) {
        onboardingContainer.innerHTML = '<div class="pipeline-empty">No practices onboarding</div>';
      }
      if (active.length === 0) {
        activeContainer.innerHTML = '<div class="pipeline-empty">No active practices</div>';
      }
    }

    function createPipelineCard(practice) {
      const card = document.createElement('div');
      card.className = 'pipeline-card';

      const isLead = practice.status === 'Lead';
      const isActive = practice.status === 'Active';

      card.innerHTML = `
        <div class="pipeline-card-name">${practice.name}</div>
        <div class="pipeline-card-details">
          <span>${practice.specialty}</span>
          <span>${practice.owner}</span>
          <span class="pipeline-card-revenue">${formatCurrency(practice.revenue)}</span>
        </div>
        <div class="pipeline-card-actions">
          <button class="btn btn-small btn-back" onclick="event.stopPropagation(); regressStatus('${practice.id}')" ${isLead ? 'disabled' : ''}>Back</button>
          <button class="btn btn-small btn-advance" onclick="event.stopPropagation(); advanceStatus('${practice.id}', event)" ${isActive ? 'disabled' : ''}>Advance</button>
          <button class="btn btn-small btn-delete" onclick="event.stopPropagation(); deletePractice('${practice.id}')">Delete</button>
        </div>
      `;

      // Make entire card clickable to open profile
      card.onclick = function() {
        openProfile(practice.id);
      };

      return card;
    }

    // =============================================
    // PROFILE VIEW
    // =============================================
    function openProfile(practiceId) {
      selectedPracticeId = practiceId;
      const practice = getPracticeById(practiceId);
      const displayData = getPracticeDisplayData(practiceId);

      if (!practice || !displayData) {
        console.error('Practice not found:', practiceId);
        return;
      }

      // Get display name from canonical fields
      const displayName = practice.dba_name || practice.legal_name || '';

      // Populate form fields using canonical and computed values
      document.getElementById('profile-title').textContent = displayName;
      document.getElementById('profile-name').value = displayName;
      document.getElementById('profile-specialty').value = practice.specialty || '';
      document.getElementById('profile-owner').value = displayData.owner || '';
      document.getElementById('profile-revenue').value = displayData.revenue || '';
      document.getElementById('profile-notes').value = displayData.notes || '';

      // Status display
      const statusClass = 'status-' + practice.status.toLowerCase();
      document.getElementById('profile-status-display').innerHTML =
        `<span class="status-badge ${statusClass}">${practice.status}</span>`;

      // Dates (use canonical snake_case fields)
      document.getElementById('profile-created').textContent =
        'Created: ' + formatDateShort(practice.created_at);
      document.getElementById('profile-updated').textContent =
        'Updated: ' + formatDateShort(practice.updated_at);

      // Practice Details - Operations
      document.getElementById('profile-years-operation').value = practice.years_in_operation ?? '';
      document.getElementById('profile-num-providers').value = practice.num_providers ?? '';
      document.getElementById('profile-num-locations').value = practice.num_locations ?? '';
      document.getElementById('profile-num-exam-rooms').value = practice.num_exam_rooms ?? '';
      document.getElementById('profile-num-staff-clinical').value = practice.num_staff_clinical ?? '';
      document.getElementById('profile-num-staff-admin').value = practice.num_staff_admin ?? '';
      document.getElementById('profile-hours-per-week').value = practice.hours_per_week ?? '';
      document.getElementById('profile-monthly-patient-volume').value = practice.monthly_patient_volume_claimed ?? '';
      document.getElementById('profile-new-patients-monthly').value = practice.new_patients_monthly_claimed ?? '';
      document.getElementById('profile-replacement-doctor').value = practice.replacement_doctor_required || 'Unknown';
      document.getElementById('profile-has-telehealth').value = practice.has_telehealth || 'Unknown';
      document.getElementById('profile-accepts-new-patients').value = practice.accepts_new_patients === true ? 'true' : practice.accepts_new_patients === false ? 'false' : '';

      // Practice Details - Financial Indicators
      document.getElementById('profile-revenue-model').value = practice.revenue_model || '';
      document.getElementById('profile-ebitda-margin').value = practice.est_ebitda_margin ?? '';
      document.getElementById('profile-growth-rate').value = practice.growth_rate_est || 'Unknown';

      // Practice Details - Ownership / Exit Context
      document.getElementById('profile-owner-age').value = practice.owner_age ?? '';
      document.getElementById('profile-exit-intent').value = practice.owner_exit_intent || 'Unknown';
      document.getElementById('profile-rebrand').value = practice.openness_to_rebrand || 'Unknown';
      document.getElementById('profile-stay-on').value = practice.willingness_to_stay_on || 'Unknown';

      // Payer Mix
      document.getElementById('profile-payer-commercial').value = practice.payer_mix_commercial ?? '';
      document.getElementById('profile-payer-medicare').value = practice.payer_mix_medicare ?? '';
      document.getElementById('profile-payer-medicaid').value = practice.payer_mix_medicaid ?? '';
      document.getElementById('profile-payer-cash').value = practice.payer_mix_cash ?? '';
      document.getElementById('profile-payer-other').value = practice.payer_mix_other ?? '';

      // Technology
      document.getElementById('profile-emr-system').value = practice.emr_system || '';
      document.getElementById('profile-practice-mgmt').value = practice.practice_mgmt_system || '';
      document.getElementById('profile-billing-system').value = practice.billing_system || '';
      document.getElementById('profile-emr-exportable').value = practice.emr_data_exportable || 'Unknown';

      // Real Estate
      document.getElementById('profile-real-estate-status').value = practice.real_estate_status || 'Unknown';
      document.getElementById('profile-lease-expiration').value = practice.lease_expiration || '';
      document.getElementById('profile-monthly-rent').value = practice.lease_monthly_rent_claimed ?? '';
      document.getElementById('profile-square-footage').value = practice.square_footage ?? '';
      document.getElementById('profile-facility-condition').value = practice.facility_condition || 'Unknown';
      document.getElementById('profile-expansion-possible').value = practice.expansion_possible || 'Unknown';

      // Legal & Corporate
      document.getElementById('profile-entity-type').value = practice.entity_type || '';
      document.getElementById('profile-state-incorporation').value = practice.state_of_incorporation || '';
      document.getElementById('profile-tax-id-last4').value = practice.tax_id_last4 || '';
      document.getElementById('profile-outstanding-litigation').value = practice.outstanding_litigation || 'Unknown';
      document.getElementById('profile-malpractice-claims').value = practice.malpractice_claims_5yr ?? '';
      document.getElementById('profile-contracts-assignable').value = practice.contracts_assignable || 'Unknown';

      // Deal Terms
      document.getElementById('profile-asking-price').value = practice.asking_price ?? '';
      document.getElementById('profile-deal-structure').value = practice.deal_structure_pref || 'Unknown';
      document.getElementById('profile-seller-financing').value = practice.seller_financing_available || 'Unknown';
      document.getElementById('profile-transition-months').value = practice.transition_support_months ?? '';
      document.getElementById('profile-earnout-acceptable').value = practice.earnout_acceptable || 'Unknown';
      document.getElementById('profile-exclusivity-status').value = practice.exclusivity_status || 'Unknown';
      document.getElementById('profile-exclusivity-expires').value = practice.exclusivity_expires || '';

      // Quality & Market
      document.getElementById('profile-google-rating').value = practice.google_rating_claimed ?? '';
      document.getElementById('profile-google-reviews').value = practice.google_review_count_claimed ?? '';
      document.getElementById('profile-quality-score').value = practice.quality_score_internal ?? '';
      document.getElementById('profile-market-position').value = practice.market_position || 'Unknown';
      document.getElementById('profile-competition-density').value = practice.competition_density || 'Unknown';

      // Tags
      renderProfileTags(practice.tags || []);

      // Quick action buttons state
      const isLead = practice.status === 'Lead';
      const isActive = practice.status === 'Active';
      document.getElementById('profile-advance-btn').disabled = isActive;
      document.getElementById('profile-advance-btn').textContent =
        isActive ? 'Already Active' : 'Advance Status';
      document.getElementById('profile-back-btn').disabled = isLead;

      // Render activity log
      renderActivityLog(practice);

      // Render practice intelligence panel
      renderPracticeIntelligence(practiceId);

      // Render locations
      renderProfileLocations(practiceId);

      // Load financial documents
      loadFinancialDocuments(practiceId);
      setupFinDocDragDrop();

      // Load DD documents
      loadDDDocuments(practiceId);
      initDDDocDropzones();
      checkDDChecklistStatus(practiceId);
      loadDDChecklist(practiceId);

      // Load pending document requests
      loadPendingRequests(practiceId);

      // Store current practice for request workflow
      currentPractice = practice;

      // Show modal
      document.getElementById('profile-modal').classList.add('visible');
    }

    // Alias for openProfile used in dashboard/search
    function openPracticeDetail(practiceId) {
      openProfile(practiceId);
    }

    function closeProfile() {
      selectedPracticeId = null;
      document.getElementById('profile-modal').classList.remove('visible');
    }

    // =============================================
    // PROFILE LOCATIONS MANAGEMENT
    // =============================================

    // Track locations being edited in the profile
    let profileLocationsState = [];

    function renderProfileLocations(practiceId) {
      const container = document.getElementById('profile-locations-list');
      const locations = getLocationsByPractice(practiceId);

      // Copy to state for editing
      profileLocationsState = JSON.parse(JSON.stringify(locations));

      if (locations.length === 0) {
        container.innerHTML = '<div class="locations-empty">No locations added yet.</div>';
        return;
      }

      container.innerHTML = locations.map((loc, index) => renderLocationCard(loc, index)).join('');
    }

    function renderLocationCard(location, index) {
      const isPrimary = location.is_primary;
      const addressParts = [
        location.address1,
        location.address2,
        [location.city, location.state, location.zip].filter(Boolean).join(', ')
      ].filter(Boolean);

      const addressDisplay = addressParts.join('<br>') || 'No address';
      const phoneDisplay = location.phone ? `Phone: ${location.phone}` : '';

      return `
        <div class="location-card ${isPrimary ? 'is-primary' : ''}" data-location-index="${index}">
          <div class="location-card-header">
            <div>
              <span class="location-name">${location.name || 'Unnamed Location'}</span>
              ${isPrimary ? '<span class="primary-badge">Primary</span>' : ''}
            </div>
            <div class="location-card-actions">
              <button type="button" onclick="editProfileLocation(${index})">Edit</button>
              ${!isPrimary ? `<button type="button" onclick="setLocationPrimary(${index})">Set Primary</button>` : ''}
              <button type="button" class="btn-delete-location" onclick="removeProfileLocation(${index})">Delete</button>
            </div>
          </div>
          <div class="location-card-body">
            ${addressDisplay}
            ${phoneDisplay ? `<br>${phoneDisplay}` : ''}
          </div>
        </div>
      `;
    }

    function renderLocationEditForm(location, index) {
      const isNew = index === -1;
      return `
        <div class="location-card ${location.is_primary ? 'is-primary' : ''}" data-location-index="${index}">
          <div class="location-edit-form">
            <div class="location-form-item full-width">
              <label>Location Name</label>
              <input type="text" id="loc-name-${index}" value="${location.name || ''}" placeholder="Main Office">
            </div>
            <div class="location-form-item full-width">
              <label>Address Line 1</label>
              <input type="text" id="loc-address1-${index}" value="${location.address1 || ''}" placeholder="123 Main St">
            </div>
            <div class="location-form-item full-width">
              <label>Address Line 2</label>
              <input type="text" id="loc-address2-${index}" value="${location.address2 || ''}" placeholder="Suite 100">
            </div>
            <div class="location-form-item">
              <label>City</label>
              <input type="text" id="loc-city-${index}" value="${location.city || ''}" placeholder="New York">
            </div>
            <div class="location-form-item">
              <label>State</label>
              <input type="text" id="loc-state-${index}" value="${location.state || ''}" placeholder="NY" maxlength="2">
            </div>
            <div class="location-form-item">
              <label>ZIP Code</label>
              <input type="text" id="loc-zip-${index}" value="${location.zip || ''}" placeholder="10001">
            </div>
            <div class="location-form-item">
              <label>Phone</label>
              <input type="text" id="loc-phone-${index}" value="${location.phone || ''}" placeholder="(555) 123-4567">
            </div>
            <div class="location-form-item">
              <label>Primary Location</label>
              <select id="loc-primary-${index}">
                <option value="false" ${!location.is_primary ? 'selected' : ''}>No</option>
                <option value="true" ${location.is_primary ? 'selected' : ''}>Yes</option>
              </select>
            </div>
            <div class="location-form-actions">
              <button type="button" class="btn btn-save" onclick="saveProfileLocationEdit(${index})">
                ${isNew ? 'Add Location' : 'Save'}
              </button>
              <button type="button" class="btn btn-cancel" onclick="cancelProfileLocationEdit(${index})">Cancel</button>
            </div>
          </div>
        </div>
      `;
    }

    function addProfileLocation() {
      const container = document.getElementById('profile-locations-list');
      const now = new Date().toISOString();

      // Create a new location object
      const newLocation = {
        id: generateLocationId(),
        practice_id: selectedPracticeId,
        name: '',
        address1: '',
        address2: '',
        city: '',
        state: '',
        zip: '',
        phone: '',
        fax: '',
        is_primary: profileLocationsState.length === 0, // First location is primary by default
        services: [],
        created_at: now,
        updated_at: now
      };

      profileLocationsState.push(newLocation);
      const index = profileLocationsState.length - 1;

      // Clear empty message if present
      const emptyMsg = container.querySelector('.locations-empty');
      if (emptyMsg) {
        emptyMsg.remove();
      }

      // Add edit form for new location
      container.insertAdjacentHTML('beforeend', renderLocationEditForm(newLocation, index));
    }

    function editProfileLocation(index) {
      const container = document.getElementById('profile-locations-list');
      const location = profileLocationsState[index];
      const card = container.querySelector(`[data-location-index="${index}"]`);

      if (card) {
        card.outerHTML = renderLocationEditForm(location, index);
      }
    }

    function saveProfileLocationEdit(index) {
      const location = profileLocationsState[index];

      // Read form values
      location.name = document.getElementById(`loc-name-${index}`).value.trim();
      location.address1 = document.getElementById(`loc-address1-${index}`).value.trim();
      location.address2 = document.getElementById(`loc-address2-${index}`).value.trim();
      location.city = document.getElementById(`loc-city-${index}`).value.trim();
      location.state = document.getElementById(`loc-state-${index}`).value.trim().toUpperCase();
      location.zip = document.getElementById(`loc-zip-${index}`).value.trim();
      location.phone = document.getElementById(`loc-phone-${index}`).value.trim();
      const isPrimary = document.getElementById(`loc-primary-${index}`).value === 'true';

      // If this becomes primary, clear others
      if (isPrimary) {
        profileLocationsState.forEach((loc, i) => {
          loc.is_primary = i === index;
        });
      } else {
        location.is_primary = false;
        // If no primary, set first one
        const hasPrimary = profileLocationsState.some(loc => loc.is_primary);
        if (!hasPrimary && profileLocationsState.length > 0) {
          profileLocationsState[0].is_primary = true;
        }
      }

      location.updated_at = new Date().toISOString();

      // Re-render all locations
      const container = document.getElementById('profile-locations-list');
      container.innerHTML = profileLocationsState.map((loc, i) => renderLocationCard(loc, i)).join('');
    }

    function cancelProfileLocationEdit(index) {
      // If it's a new unsaved location with no data, remove it
      const location = profileLocationsState[index];
      const isNew = !location.name && !location.address1 && !location.city;

      if (isNew) {
        profileLocationsState.splice(index, 1);
      }

      // Re-render all locations
      const container = document.getElementById('profile-locations-list');
      if (profileLocationsState.length === 0) {
        container.innerHTML = '<div class="locations-empty">No locations added yet.</div>';
      } else {
        container.innerHTML = profileLocationsState.map((loc, i) => renderLocationCard(loc, i)).join('');
      }
    }

    function setLocationPrimary(index) {
      profileLocationsState.forEach((loc, i) => {
        loc.is_primary = i === index;
      });

      // Re-render
      const container = document.getElementById('profile-locations-list');
      container.innerHTML = profileLocationsState.map((loc, i) => renderLocationCard(loc, i)).join('');
    }

    function removeProfileLocation(index) {
      const location = profileLocationsState[index];
      const wasPrimary = location.is_primary;

      profileLocationsState.splice(index, 1);

      // If removed primary, set first as primary
      if (wasPrimary && profileLocationsState.length > 0) {
        profileLocationsState[0].is_primary = true;
      }

      // Re-render
      const container = document.getElementById('profile-locations-list');
      if (profileLocationsState.length === 0) {
        container.innerHTML = '<div class="locations-empty">No locations added yet.</div>';
      } else {
        container.innerHTML = profileLocationsState.map((loc, i) => renderLocationCard(loc, i)).join('');
      }
    }

    function generateLocationId() {
      return 'loc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function renderActivityLog(practice) {
      const container = document.getElementById('activity-log');
      const log = practice.activityLog || [];

      if (log.length === 0) {
        container.innerHTML = '<div class="activity-log-empty">No activity recorded yet.</div>';
        return;
      }

      // Show most recent first
      const sortedLog = [...log].reverse();
      container.innerHTML = sortedLog.map(entry => `
        <div class="activity-log-item">
          <div class="timestamp">${formatTimestamp(entry.timestamp)}</div>
          <div class="action"><strong>${entry.action}:</strong> ${entry.details}</div>
        </div>
      `).join('');
    }

    // Profile form submission (save changes)
    document.getElementById('profile-form').addEventListener('submit', async function(e) {
      e.preventDefault();

      // Permission check - viewers cannot edit
      if (isReadOnly()) {
        showPermissionDenied('edit practice data');
        return;
      }

      if (!selectedPracticeId) return;

      const practice = getPracticeById(selectedPracticeId);
      if (!practice) return;

      // Get current display data for comparison
      const displayData = getPracticeDisplayData(selectedPracticeId);

      // Track changes for activity log
      const changes = {};
      const newName = document.getElementById('profile-name').value.trim();
      const newSpecialty = document.getElementById('profile-specialty').value;
      const newOwner = document.getElementById('profile-owner').value.trim();
      const newRevenue = document.getElementById('profile-revenue').value;
      const newNotes = document.getElementById('profile-notes').value.trim();

      const changeDescriptions = [];

      // Check for practice field changes (use canonical snake_case fields)
      const currentName = practice.dba_name || practice.legal_name || '';
      if (currentName !== newName) {
        changes.dba_name = { old: currentName, new: newName };
        changeDescriptions.push(`Name: "${currentName}"  "${newName}"`);
      }
      if (practice.specialty !== newSpecialty) {
        changes.specialty = { old: practice.specialty, new: newSpecialty };
        changeDescriptions.push(`Specialty: "${practice.specialty}"  "${newSpecialty}"`);
      }

      // Check for owner changes (computed from people table)
      const currentOwner = displayData.owner || '';
      if (currentOwner !== newOwner) {
        changes.owner = { old: currentOwner, new: newOwner };
        changeDescriptions.push(`Owner: "${currentOwner}"  "${newOwner}"`);
      }

      // Check for revenue changes (computed from metrics table)
      const currentRevenue = displayData.revenue || 0;
      if (Number(currentRevenue) !== Number(newRevenue)) {
        changes.revenue = { old: currentRevenue, new: Number(newRevenue) };
        changeDescriptions.push(`Revenue: ${formatCurrency(currentRevenue)}  ${formatCurrency(newRevenue)}`);
      }

      // Check for notes changes (computed from notes table)
      const currentNotes = displayData.notes || '';
      if (currentNotes !== newNotes) {
        changes.notes = { old: currentNotes, new: newNotes };
        changeDescriptions.push('Notes updated');
      }

      // Build practice details updates - collect all field values
      const detailsUpdates = {};
      let detailsChanged = false;

      // Helper to check and add numeric field update
      const checkNumeric = (elementId, dbField, currentVal) => {
        const el = document.getElementById(elementId);
        if (!el) return;
        const newVal = el.value ? Number(el.value) : null;
        if (newVal !== currentVal) {
          detailsUpdates[dbField] = newVal;
          detailsChanged = true;
        }
      };

      // Helper to check and add select/text field update
      const checkSelect = (elementId, dbField, currentVal, defaultVal = 'Unknown') => {
        const el = document.getElementById(elementId);
        if (!el) return;
        const newVal = el.value || null;
        if (newVal !== (currentVal || defaultVal)) {
          detailsUpdates[dbField] = newVal === defaultVal ? null : newVal;
          detailsChanged = true;
        }
      };

      // Helper for text fields
      const checkText = (elementId, dbField, currentVal) => {
        const el = document.getElementById(elementId);
        if (!el) return;
        const newVal = el.value.trim() || null;
        if (newVal !== (currentVal || null)) {
          detailsUpdates[dbField] = newVal;
          detailsChanged = true;
        }
      };

      // Helper for boolean select fields
      const checkBoolSelect = (elementId, dbField, currentVal) => {
        const el = document.getElementById(elementId);
        if (!el) return;
        const newVal = el.value === 'true' ? true : el.value === 'false' ? false : null;
        if (newVal !== currentVal) {
          detailsUpdates[dbField] = newVal;
          detailsChanged = true;
        }
      };

      // Helper for date fields
      const checkDate = (elementId, dbField, currentVal) => {
        const el = document.getElementById(elementId);
        if (!el) return;
        const newVal = el.value || null;
        if (newVal !== (currentVal || null)) {
          detailsUpdates[dbField] = newVal;
          detailsChanged = true;
        }
      };

      // Operations
      checkNumeric('profile-years-operation', 'years_in_operation', practice.years_in_operation);
      checkNumeric('profile-num-providers', 'num_providers', practice.num_providers);
      checkNumeric('profile-num-locations', 'num_locations', practice.num_locations);
      checkNumeric('profile-num-exam-rooms', 'num_exam_rooms', practice.num_exam_rooms);
      checkNumeric('profile-num-staff-clinical', 'num_staff_clinical', practice.num_staff_clinical);
      checkNumeric('profile-num-staff-admin', 'num_staff_admin', practice.num_staff_admin);
      checkNumeric('profile-hours-per-week', 'hours_per_week', practice.hours_per_week);
      checkNumeric('profile-monthly-patient-volume', 'monthly_patient_volume_claimed', practice.monthly_patient_volume_claimed);
      checkNumeric('profile-new-patients-monthly', 'new_patients_monthly_claimed', practice.new_patients_monthly_claimed);
      checkSelect('profile-replacement-doctor', 'replacement_doctor_required', practice.replacement_doctor_required);
      checkSelect('profile-has-telehealth', 'has_telehealth', practice.has_telehealth);
      checkBoolSelect('profile-accepts-new-patients', 'accepts_new_patients', practice.accepts_new_patients);

      // Financial Indicators
      checkText('profile-revenue-model', 'revenue_model', practice.revenue_model);
      checkNumeric('profile-ebitda-margin', 'est_ebitda_margin', practice.est_ebitda_margin);
      checkSelect('profile-growth-rate', 'growth_rate_est', practice.growth_rate_est);

      // Ownership / Exit Context
      checkNumeric('profile-owner-age', 'owner_age', practice.owner_age);
      checkSelect('profile-exit-intent', 'owner_exit_intent', practice.owner_exit_intent);
      checkSelect('profile-rebrand', 'openness_to_rebrand', practice.openness_to_rebrand);
      checkSelect('profile-stay-on', 'willingness_to_stay_on', practice.willingness_to_stay_on);

      // Payer Mix
      checkNumeric('profile-payer-commercial', 'payer_mix_commercial', practice.payer_mix_commercial);
      checkNumeric('profile-payer-medicare', 'payer_mix_medicare', practice.payer_mix_medicare);
      checkNumeric('profile-payer-medicaid', 'payer_mix_medicaid', practice.payer_mix_medicaid);
      checkNumeric('profile-payer-cash', 'payer_mix_cash', practice.payer_mix_cash);
      checkNumeric('profile-payer-other', 'payer_mix_other', practice.payer_mix_other);

      // Technology
      checkText('profile-emr-system', 'emr_system', practice.emr_system);
      checkText('profile-practice-mgmt', 'practice_mgmt_system', practice.practice_mgmt_system);
      checkText('profile-billing-system', 'billing_system', practice.billing_system);
      checkSelect('profile-emr-exportable', 'emr_data_exportable', practice.emr_data_exportable);

      // Real Estate
      checkSelect('profile-real-estate-status', 'real_estate_status', practice.real_estate_status);
      checkDate('profile-lease-expiration', 'lease_expiration', practice.lease_expiration);
      checkNumeric('profile-monthly-rent', 'lease_monthly_rent_claimed', practice.lease_monthly_rent_claimed);
      checkNumeric('profile-square-footage', 'square_footage', practice.square_footage);
      checkSelect('profile-facility-condition', 'facility_condition', practice.facility_condition);
      checkSelect('profile-expansion-possible', 'expansion_possible', practice.expansion_possible);

      // Legal & Corporate
      checkText('profile-entity-type', 'entity_type', practice.entity_type);
      checkText('profile-state-incorporation', 'state_of_incorporation', practice.state_of_incorporation);
      checkText('profile-tax-id-last4', 'tax_id_last4', practice.tax_id_last4);
      checkSelect('profile-outstanding-litigation', 'outstanding_litigation', practice.outstanding_litigation);
      checkNumeric('profile-malpractice-claims', 'malpractice_claims_5yr', practice.malpractice_claims_5yr);
      checkSelect('profile-contracts-assignable', 'contracts_assignable', practice.contracts_assignable);

      // Deal Terms
      checkNumeric('profile-asking-price', 'asking_price', practice.asking_price);
      checkSelect('profile-deal-structure', 'deal_structure_pref', practice.deal_structure_pref);
      checkSelect('profile-seller-financing', 'seller_financing_available', practice.seller_financing_available);
      checkNumeric('profile-transition-months', 'transition_support_months', practice.transition_support_months);
      checkSelect('profile-earnout-acceptable', 'earnout_acceptable', practice.earnout_acceptable);
      checkSelect('profile-exclusivity-status', 'exclusivity_status', practice.exclusivity_status);
      checkDate('profile-exclusivity-expires', 'exclusivity_expires', practice.exclusivity_expires);

      // Quality & Market
      checkNumeric('profile-google-rating', 'google_rating_claimed', practice.google_rating_claimed);
      checkNumeric('profile-google-reviews', 'google_review_count_claimed', practice.google_review_count_claimed);
      checkNumeric('profile-quality-score', 'quality_score_internal', practice.quality_score_internal);
      checkSelect('profile-market-position', 'market_position', practice.market_position);
      checkSelect('profile-competition-density', 'competition_density', practice.competition_density);

      if (detailsChanged) {
        changeDescriptions.push('Practice details updated');
      }

      // Check for location changes
      const originalLocations = getLocationsByPractice(selectedPracticeId);
      const locationsChanged = JSON.stringify(profileLocationsState) !== JSON.stringify(originalLocations);
      if (locationsChanged) {
        changeDescriptions.push('Locations updated');
      }

      if (changeDescriptions.length > 0) {
        const now = new Date().toISOString();

        // Supabase write path (practices + people + practice_people)
        if (DATA_SOURCE === 'supabase') {
          try {
            let hasChanges = false;

            // 1. Update practice fields if changed
            const supabaseUpdates = {};
            if (changes.dba_name) {
              supabaseUpdates.dba_name = newName;
              supabaseUpdates.legal_name = newName;
            }
            if (changes.specialty) {
              supabaseUpdates.specialty = newSpecialty;
              supabaseUpdates.specialty_key = deriveSpecialtyKey(newSpecialty);
            }
            if (detailsChanged) {
              Object.assign(supabaseUpdates, detailsUpdates);
            }

            if (Object.keys(supabaseUpdates).length > 0) {
              await supabaseUpdatePractice(selectedPracticeId, supabaseUpdates);
              console.log('Practice updated in Supabase:', selectedPracticeId);
              hasChanges = true;
            }

            // 2. Update owner (person + link) if changed
            if (changes.owner) {
              const primaryOwner = getPrimaryOwner(selectedPracticeId);
              const nameParts = newOwner.split(' ');

              if (primaryOwner && newOwner) {
                // Update existing person
                await supabaseUpdatePerson(primaryOwner.id, {
                  first_name: nameParts[0] || '',
                  last_name: nameParts.slice(1).join(' ') || ''
                });
                console.log('Person updated in Supabase:', primaryOwner.id);
                hasChanges = true;
              } else if (!primaryOwner && newOwner) {
                // Create new person + link
                const personId = generatePersonId();

                const person = {
                  id: personId,
                  first_name: nameParts[0] || '',
                  last_name: nameParts.slice(1).join(' ') || '',
                  email: '',
                  phone: '',
                  created_at: now,
                  updated_at: now
                };

                await supabaseUpsertPerson(person);
                console.log('Person created in Supabase:', personId);

                const link = {
                  id: generatePracticePersonId(),
                  practice_id: selectedPracticeId,
                  person_id: personId,
                  role: 'owner',
                  is_primary: true,
                  ownership_pct: 100,
                  created_at: now
                };

                await supabaseUpsertPracticePersonLink(link);
                console.log('Practice-person link created in Supabase');
                hasChanges = true;
              }
              // Note: Clearing owner name (primaryOwner exists but newOwner empty)
              // is not handled here - owner remains in DB
            }

            // 3. Update notes if changed
            if (changes.notes) {
              const latestNote = getLatestNote(selectedPracticeId);

              if (latestNote && newNotes) {
                // Update existing note
                await supabaseUpdateNote(latestNote.id, { content: newNotes });
                console.log('Note updated in Supabase:', latestNote.id);
                hasChanges = true;
              } else if (!latestNote && newNotes) {
                // Create new note
                const note = {
                  id: generateNoteId(),
                  practice_id: selectedPracticeId,
                  author_id: 'system',
                  content: newNotes,
                  is_pinned: false,
                  created_at: now,
                  updated_at: now
                };

                await supabaseInsertNote(note);
                console.log('Note created in Supabase');
                hasChanges = true;
              } else if (latestNote && !newNotes) {
                // Delete note if cleared
                await supabaseDeleteNote(latestNote.id);
                console.log('Note deleted from Supabase:', latestNote.id);
                hasChanges = true;
              }
            }

            // 4. Update revenue (metric) if changed
            if (changes.revenue) {
              const revenueVal = parseFloat(newRevenue) || 0;

              if (revenueVal > 0) {
                const metric = {
                  practice_id: selectedPracticeId,
                  type: 'monthly_revenue',
                  period: getCurrentPeriodYYYYMM(),
                  value: revenueVal,
                  source: 'user',
                  created_at: now
                };

                await supabaseUpsertMetric(metric);
                console.log('Metric upserted in Supabase:', revenueVal);
                hasChanges = true;
              }
            }

            // 5. Update locations (if changed)
            if (locationsChanged) {
              const originalLocationIds = new Set(originalLocations.map(l => l.id));
              const currentLocationIds = new Set(profileLocationsState.map(l => l.id));

              // Find deleted locations
              for (const origLoc of originalLocations) {
                if (!currentLocationIds.has(origLoc.id)) {
                  await supabaseDeleteLocation(origLoc.id);
                  console.log('Location deleted from Supabase:', origLoc.id);
                  hasChanges = true;
                }
              }

              // Upsert current locations
              for (const loc of profileLocationsState) {
                // Check if location has meaningful data
                if (loc.name || loc.address1 || loc.city) {
                  await supabaseUpsertLocation(loc);
                  console.log('Location upserted in Supabase:', loc.id);
                  hasChanges = true;
                }
              }

              // Update practice.primary_location_id
              const primaryLoc = profileLocationsState.find(l => l.is_primary);
              if (primaryLoc) {
                await supabaseUpdatePractice(selectedPracticeId, {
                  primary_location_id: primaryLoc.id
                });
                console.log('Practice primary_location_id updated:', primaryLoc.id);
              } else if (profileLocationsState.length > 0) {
                // If no explicit primary, use first location
                await supabaseUpdatePractice(selectedPracticeId, {
                  primary_location_id: profileLocationsState[0].id
                });
                console.log('Practice primary_location_id set to first location:', profileLocationsState[0].id);
              }
            }

            if (hasChanges) {
              await refreshFromSupabase();
              updateDataSourceBanner('supabase');
              openProfile(selectedPracticeId);
            }
            return;
          } catch (error) {
            console.error('Supabase update failed:', error);
            showSupabaseWriteError(error.message);
            return;
          }
        }

        // Local storage path (unchanged)
        // Update practice core fields (canonical snake_case)
        if (changes.dba_name || changes.specialty) {
          const practiceUpdates = { updated_at: now };
          if (changes.dba_name) {
            practiceUpdates.dba_name = newName;
            practiceUpdates.legal_name = newName; // Keep in sync
          }
          if (changes.specialty) {
            practiceUpdates.specialty = newSpecialty;
            practiceUpdates.specialty_key = deriveSpecialtyKey(newSpecialty);
          }
          updateRecord('practices', selectedPracticeId, practiceUpdates);
        }

        // Update practice details fields
        if (detailsChanged) {
          detailsUpdates.updated_at = now;
          updateRecord('practices', selectedPracticeId, detailsUpdates);
        }

        // Update owner (person record - canonical snake_case)
        if (changes.owner) {
          const primaryOwner = getPrimaryOwner(selectedPracticeId);
          if (primaryOwner) {
            // Parse the new owner name and update with canonical fields
            const nameParts = newOwner.split(' ');
            updateRecord('people', primaryOwner.id, {
              first_name: nameParts[0] || '',
              last_name: nameParts.slice(1).join(' ') || '',
              updated_at: now
            });
          } else if (newOwner) {
            // Create new primary owner using canonical creator
            const nameParts = newOwner.split(' ');
            const personId = generatePersonId();

            const person = createCanonicalPerson({
              id: personId,
              first_name: nameParts[0] || '',
              last_name: nameParts.slice(1).join(' ') || '',
              email: '',
              phone: '',
              created_at: now,
              updated_at: now
            }, now);
            insertRecord('people', person);

            // Create join table entry
            const link = createCanonicalPracticePersonLink({
              practice_id: selectedPracticeId,
              person_id: personId,
              role: 'owner',
              is_primary: true,
              ownership_pct: 100,
              created_at: now
            }, now);
            db.practice_people.push(link);
          }
        }

        // Update revenue (metric record - canonical snake_case)
        if (changes.revenue) {
          const currentPeriod = getCurrentPeriod();
          // Find existing revenue metric for current period using canonical fields
          const existingMetric = db.metrics.find(m =>
            m.practice_id === selectedPracticeId &&
            m.metric_type === 'monthly_revenue' &&
            m.period === currentPeriod
          );
          if (existingMetric) {
            updateRecord('metrics', existingMetric.id, { value: Number(newRevenue) });
          } else {
            // Create new metric using canonical creator
            const metric = createCanonicalMetric({
              practice_id: selectedPracticeId,
              location_id: null,
              period: currentPeriod,
              metric_type: 'monthly_revenue',
              value: Number(newRevenue),
              source: 'manual',
              created_at: now
            }, now);
            insertRecord('metrics', metric);
          }
        }

        // Update notes (canonical snake_case)
        if (changes.notes) {
          const latestNote = getLatestNote(selectedPracticeId);
          if (latestNote && newNotes) {
            updateRecord('notes', latestNote.id, { content: newNotes, updated_at: now });
          } else if (newNotes) {
            // Create new note using canonical creator
            const note = createCanonicalNote({
              practice_id: selectedPracticeId,
              author_id: 'system',
              content: newNotes,
              is_pinned: false,
              created_at: now,
              updated_at: now
            }, now);
            insertRecord('notes', note);
          } else if (latestNote && !newNotes) {
            // Delete note if cleared
            deleteRecord('notes', latestNote.id);
          }
        }

        // Log the edit event (canonical format)
        logEvent(selectedPracticeId, 'practice_edited', changes);

        // Recompute risk flags after edit
        recomputeRiskFlagsAfterChange(selectedPracticeId);

        renderAll();

        // Update profile display (use canonical snake_case fields)
        const updatedPractice = getPracticeById(selectedPracticeId);
        document.getElementById('profile-title').textContent = updatedPractice.dba_name || updatedPractice.legal_name || '';
        document.getElementById('profile-updated').textContent =
          'Updated: ' + formatDateShort(updatedPractice.updated_at);

        // Refresh activity log with new display data
        const refreshedDisplayData = getPracticeDisplayData(selectedPracticeId);
        renderActivityLog(refreshedDisplayData);

        // Refresh intelligence panel after save
        renderPracticeIntelligence(selectedPracticeId);
      }
    });

    // =============================================
    // PROFILE QUICK ACTIONS
    // =============================================
    async function profileAdvanceStatus() {
      if (!selectedPracticeId) return;

      const practice = getPracticeById(selectedPracticeId);
      if (!practice) return;

      const currentIndex = STATUS_ORDER.indexOf(practice.status);
      if (currentIndex < STATUS_ORDER.length - 1) {
        const oldStatus = practice.status;
        const newStatus = STATUS_ORDER[currentIndex + 1];

        // Supabase write path
        if (DATA_SOURCE === 'supabase') {
          try {
            await supabaseUpdatePractice(selectedPracticeId, { status: newStatus });
            console.log('Profile status advanced in Supabase:', selectedPracticeId, newStatus);
            await refreshFromSupabase();
            updateDataSourceBanner('supabase');
            openProfile(selectedPracticeId);

            // Trigger confetti only when advancing to Active
            if (newStatus === 'Active') {
              const btn = document.getElementById('profile-advance-btn');
              const rect = btn.getBoundingClientRect();
              createConfetti(rect.left + rect.width / 2, rect.top);
            }
            return;
          } catch (error) {
            console.error('Supabase status update failed:', error);
            showSupabaseWriteError(error.message);
            return;
          }
        }

        // Local storage path (unchanged)
        updateRecord('practices', selectedPracticeId, { status: newStatus });

        // Log status change event (canonical format)
        logEvent(selectedPracticeId, 'status_changed', { old: oldStatus, new: newStatus });

        // Recompute risk flags after status change
        recomputeRiskFlagsAfterChange(selectedPracticeId);

        renderAll();

        // Refresh profile view
        openProfile(selectedPracticeId);

        // Trigger confetti only when advancing to Active
        if (newStatus === 'Active') {
          const btn = document.getElementById('profile-advance-btn');
          const rect = btn.getBoundingClientRect();
          createConfetti(rect.left + rect.width / 2, rect.top);
        }
      }
    }

    async function profileRegressStatus() {
      if (!selectedPracticeId) return;

      const practice = getPracticeById(selectedPracticeId);
      if (!practice) return;

      const currentIndex = STATUS_ORDER.indexOf(practice.status);
      if (currentIndex > 0) {
        const oldStatus = practice.status;
        const newStatus = STATUS_ORDER[currentIndex - 1];

        // Supabase write path
        if (DATA_SOURCE === 'supabase') {
          try {
            await supabaseUpdatePractice(selectedPracticeId, { status: newStatus });
            console.log('Profile status regressed in Supabase:', selectedPracticeId, newStatus);
            await refreshFromSupabase();
            updateDataSourceBanner('supabase');
            openProfile(selectedPracticeId);
            return;
          } catch (error) {
            console.error('Supabase status update failed:', error);
            showSupabaseWriteError(error.message);
            return;
          }
        }

        // Local storage path (unchanged)
        updateRecord('practices', selectedPracticeId, { status: newStatus });

        // Log status change event (canonical format)
        logEvent(selectedPracticeId, 'status_changed', { old: oldStatus, new: newStatus });

        // Recompute risk flags after status change
        recomputeRiskFlagsAfterChange(selectedPracticeId);

        renderAll();

        // Refresh profile view
        openProfile(selectedPracticeId);
      }
    }

    async function profileDelete() {
      // Permission check - admin only
      if (!hasPermission('DELETE_PRACTICE')) {
        showPermissionDenied('delete practices');
        return;
      }

      if (!selectedPracticeId) return;

      const practice = getPracticeById(selectedPracticeId);
      if (!practice) return;

      if (confirm(`Are you sure you want to delete "${practice.dba_name || practice.legal_name}"?`)) {
        // Supabase write path
        if (DATA_SOURCE === 'supabase') {
          try {
            await supabaseDeletePractice(selectedPracticeId);
            console.log('Practice deleted from Supabase via profile:', selectedPracticeId);
            await refreshFromSupabase();
            updateDataSourceBanner('supabase');
            closeProfile();
            return;
          } catch (error) {
            console.error('Supabase delete failed:', error);
            showSupabaseWriteError(error.message);
            return;
          }
        }

        // Local storage path (unchanged)
        // Log deletion event first (canonical format)
        logEvent(selectedPracticeId, 'practice_deleted', { name: practice.dba_name || practice.legal_name });

        // Delete related records using canonical practice_id field
        // Also check legacy practiceId for backward compat during migration period
        const practicePersonLinks = db.practice_people.filter(pp => pp.practice_id === selectedPracticeId);
        const linkedPersonIds = practicePersonLinks.map(pp => pp.person_id);

        db.practice_people = db.practice_people.filter(pp => pp.practice_id !== selectedPracticeId);
        db.people = db.people.filter(p => !linkedPersonIds.includes(p.id));
        db.locations = db.locations.filter(l => l.practice_id !== selectedPracticeId);
        db.metrics = db.metrics.filter(m => m.practice_id !== selectedPracticeId);
        db.notes = db.notes.filter(n => n.practice_id !== selectedPracticeId);
        db.documents = db.documents.filter(d => d.practice_id !== selectedPracticeId);
        db.events = db.events.filter(e => e.practice_id !== selectedPracticeId);
        db.practices = db.practices.filter(p => p.id !== selectedPracticeId);

        saveDb();
        renderAll();
        closeProfile();
      }
    }

    function exportPractice() {
      if (!selectedPracticeId) return;

      // Get full practice data including related records
      const practice = getPracticeById(selectedPracticeId);
      if (!practice) return;

      const exportData = {
        exportedAt: new Date().toISOString(),
        dataVersion: DATA_VERSION,
        practice: practice,
        practice_people: getPracticePersonLinks(selectedPracticeId),
        people: getPeopleByPractice(selectedPracticeId),
        locations: getLocationsByPractice(selectedPracticeId),
        metrics: getMetricsByPractice(selectedPracticeId),
        notes: getNotesByPractice(selectedPracticeId),
        documents: getDocumentsByPractice(selectedPracticeId),
        events: getEventsByPractice(selectedPracticeId)
      };

      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `practice-${(practice.dba_name || practice.legal_name || 'export').replace(/[^a-z0-9]/gi, '_').toLowerCase()}-${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // =============================================
    // DATABASE EXPORT/IMPORT
    // =============================================

    // Export entire database as JSON
    function exportDatabaseJSON() {
      const exportData = {
        exportedAt: new Date().toISOString(),
        dataVersion: DATA_VERSION,
        appName: 'zenyte-intake-mini',
        ...db
      };

      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const date = new Date().toISOString().split('T')[0];
      const a = document.createElement('a');
      a.href = url;
      a.download = `zenyte_db_export_${date}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      // Log export event
      logEvent(null, 'db_exported', {
        record_counts: {
          practices: db.practices.length,
          people: db.people.length,
          locations: db.locations.length,
          metrics: db.metrics.length,
          notes: db.notes.length,
          documents: db.documents.length,
          events: db.events.length
        },
        exported_at: new Date().toISOString()
      });

      console.log('Database exported successfully');
    }

    // Import database from JSON file
    function importDatabaseJSON(event) {
      const file = event.target.files[0];
      if (!file) return;

      const statusContainer = document.querySelector('.data-section:first-child');
      let statusDiv = statusContainer.querySelector('.import-status');
      if (!statusDiv) {
        statusDiv = document.createElement('div');
        statusDiv.className = 'import-status';
        statusContainer.appendChild(statusDiv);
      }

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const importedData = JSON.parse(e.target.result);

          // Validate structure
          if (!importedData.practices || !Array.isArray(importedData.practices)) {
            throw new Error('Invalid database format: missing practices array');
          }

          // Create a test database object
          const testDb = {
            practices: importedData.practices || [],
            people: importedData.people || [],
            locations: importedData.locations || [],
            metrics: importedData.metrics || [],
            notes: importedData.notes || [],
            documents: importedData.documents || [],
            events: importedData.events || [],
            practice_people: importedData.practice_people || []
          };

          // Scan for legacy keys in the imported data
          const camelCaseIssues = scanForCamelCaseKeys(testDb);
          const legacyIssues = scanForLegacyKeySet(testDb);

          console.log(`[Import] Found ${camelCaseIssues.length} camelCase issues, ${legacyIssues.length} legacy issues`);

          // Repair if needed
          if (camelCaseIssues.length > 0 || legacyIssues.length > 0) {
            console.log('[Import] Repairing imported data...');
            const tables = ['practices', 'people', 'locations', 'metrics', 'notes', 'documents', 'events', 'practice_people'];
            tables.forEach(tableName => {
              testDb[tableName] = testDb[tableName].map(record => repairRecord(record));
            });
          }

          // Validate repaired data
          const postRepairCamelCase = scanForCamelCaseKeys(testDb);
          const postRepairLegacy = scanForLegacyKeySet(testDb);

          if (postRepairCamelCase.length > 0 || postRepairLegacy.length > 0) {
            throw new Error(`Import failed: ${postRepairCamelCase.length + postRepairLegacy.length} schema violations could not be repaired`);
          }

          // Run validation on the test database
          const oldDb = db;
          db = testDb;
          const validation = validateDb();

          if (validation.errors > 0) {
            db = oldDb; // Restore original
            throw new Error(`Import failed: ${validation.errors} validation errors found`);
          }

          // Save the imported database
          saveDb();

          // Log import event
          logEvent(null, 'db_imported', {
            source_file: file.name,
            source_version: importedData.dataVersion || 'unknown',
            record_counts: {
              practices: testDb.practices.length,
              people: testDb.people.length,
              locations: testDb.locations.length,
              metrics: testDb.metrics.length
            },
            imported_at: new Date().toISOString()
          });

          // Update UI
          renderAll();

          statusDiv.className = 'import-status success';
          statusDiv.innerHTML = `<strong>Import successful!</strong><br>Imported ${testDb.practices.length} practices, ${testDb.people.length} people, ${testDb.metrics.length} metrics.`;

          console.log('[Import] Database imported successfully');

        } catch (error) {
          console.error('[Import] Error:', error);
          statusDiv.className = 'import-status error';
          statusDiv.innerHTML = `<strong>Import failed:</strong> ${error.message}`;
        }

        // Reset file input
        event.target.value = '';
      };

      reader.onerror = function() {
        statusDiv.className = 'import-status error';
        statusDiv.innerHTML = '<strong>Import failed:</strong> Could not read file';
        event.target.value = '';
      };

      reader.readAsText(file);
    }

    // Export portfolio summary as CSV
    function exportPortfolioCSV() {
      const practices = db.practices;

      if (practices.length === 0) {
        alert('No practices to export');
        return;
      }

      // CSV header
      const headers = [
        'practice_id',
        'display_name',
        'specialty',
        'status',
        'primary_owner_name',
        'primary_location_state',
        'latest_monthly_revenue',
        'created_at',
        'updated_at',
        'risk_flag_count'
      ];

      // Build rows
      const rows = practices.map(practice => {
        const primaryOwner = getPrimaryOwner(practice.id);
        const primaryLocation = getPrimaryLocation(practice.id);
        const latestRevenue = getLatestRevenue(practice.id);
        const riskFlags = practice.risk_flags || computePracticeRiskFlags(practice.id);
        const riskFlagCount = (riskFlags.missing_fields?.length || 0) + (riskFlags.aging_flags?.length || 0);

        const ownerName = primaryOwner
          ? `${primaryOwner.first_name || ''} ${primaryOwner.last_name || ''}`.trim()
          : '';

        return [
          practice.id,
          practice.dba_name || practice.legal_name || '',
          practice.specialty || '',
          practice.status || '',
          ownerName,
          primaryLocation?.state || '',
          latestRevenue || 0,
          practice.created_at || '',
          practice.updated_at || '',
          riskFlagCount
        ];
      });

      // Escape CSV values
      const escapeCSV = (val) => {
        const str = String(val ?? '');
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
          return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
      };

      // Build CSV content
      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.map(escapeCSV).join(','))
      ].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);

      const date = new Date().toISOString().split('T')[0];
      const a = document.createElement('a');
      a.href = url;
      a.download = `zenyte_portfolio_${date}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      // Log export event
      logEvent(null, 'portfolio_exported', {
        format: 'csv',
        practice_count: practices.length,
        exported_at: new Date().toISOString()
      });

      console.log('Portfolio CSV exported successfully');
    }

    // Run diagnostics and show in UI
    function runDiagnosticsUI() {
      const outputDiv = document.getElementById('diagnostics-output');
      outputDiv.style.display = 'block';

      const result = diagnostics();

      let output = '';
      output += `Schema Version: ${result.schemaVersion}\n`;
      output += `\nRecord Counts:\n`;
      Object.entries(result.recordCounts).forEach(([table, count]) => {
        output += `  ${table}: ${count}\n`;
      });
      output += `\nCamelCase Violations: ${result.camelCaseViolations}`;
      output += `\nLegacy Key Violations: ${result.legacyKeyViolations}`;
      output += `\nOrphan Foreign Keys: ${result.orphanFKs}`;
      output += `\nValidation Errors: ${result.validationErrors}`;
      output += `\n\n${result.isClean ? ' DATABASE IS CANONICAL AND VALID' : ' DATABASE HAS ISSUES'}`;

      outputDiv.textContent = output;
      outputDiv.className = 'diagnostics-output ' + (result.isClean ? 'success' : 'error');
    }

    // =============================================
    // DUE DILIGENCE PACKET GENERATOR (Canonical v1)
    // =============================================
    function generatePacketHTML(practice) {
      const now = new Date();
      const generatedDate = formatDateFull(now.toISOString());
      const practiceId = practice.id;

      // Get canonical data from normalized tables
      const corePractice = getPracticeById(practiceId) || practice;
      const owners = getOwnersByPractice(practiceId);
      const locations = getLocationsByPractice(practiceId);
      const revenueHistory = getRevenueHistory(practiceId, 6);
      const events = getEventsByPractice(practiceId);

      // Calculate portfolio totals
      const allPractices = getPractices();
      const portfolioRevenue = allPractices.reduce((sum, p) => sum + Number(p.revenue || 0), 0);
      const portfolioCount = allPractices.length;

      // Get risk flags from canonical model or compute fresh
      const riskFlags = corePractice.risk_flags || computePracticeRiskFlags(practiceId);
      const flags = generateRiskFlagsForPacket(practice, riskFlags);

      // Get pipeline recommendation based on status
      const pipelineRec = getPipelineRecommendation(practice.status);

      // Status class for badge
      const statusClass = 'dd-status-' + practice.status.toLowerCase();

      // Build owners list HTML (use canonical snake_case fields)
      const ownersHtml = owners.length > 0
        ? owners.map(o => `${o.first_name || ''} ${o.last_name || ''} ${o.ownership_pct ? `(${o.ownership_pct}%)` : ''}`).join(', ')
        : '<em>Not specified</em>';

      // Build ownership structure
      const ownershipStructure = corePractice.ownership_structure || 'Unknown';

      // Build locations list HTML (use canonical snake_case fields)
      const primaryLocation = locations.find(l => l.is_primary) || locations[0];
      const locationCount = locations.length;

      // Build detailed primary location display
      let primaryLocationHtml = '<em>No primary location on file</em>';
      if (primaryLocation) {
        const addrParts = [
          primaryLocation.address1,
          primaryLocation.address2,
          [primaryLocation.city, primaryLocation.state, primaryLocation.zip].filter(Boolean).join(', ')
        ].filter(Boolean);
        const phoneStr = primaryLocation.phone ? `<br>Phone: ${primaryLocation.phone}` : '';
        primaryLocationHtml = `<strong>${primaryLocation.name || 'Primary Location'}</strong><br>${addrParts.join('<br>') || 'Address not provided'}${phoneStr}`;
      }

      // Build full locations summary
      const locationsHtml = locationCount > 0
        ? `<div style="margin-bottom: 8px;"><em>${locationCount} location${locationCount > 1 ? 's' : ''} on file</em></div>` +
          locations.map(l => {
            const cityState = [l.city, l.state].filter(Boolean).join(', ');
            return `${l.name || 'Location'}: ${cityState || l.address1 || 'Address not provided'}${l.is_primary ? ' <strong>(Primary)</strong>' : ''}`;
          }).join('<br>')
        : '<em>No locations on file</em>';

      // Build financial history table
      const financialHistoryHtml = revenueHistory.length > 0
        ? `<table class="dd-table" style="font-size: 9pt;">
            <tr><th>Period</th><th>Revenue</th><th>Source</th></tr>
            ${revenueHistory.map(m => `<tr><td>${m.period}</td><td>${formatCurrency(m.value)}</td><td>${m.source || 'manual'}</td></tr>`).join('')}
          </table>`
        : '<p style="color: #888; font-style: italic;">No financial history available</p>';

      // Activity timeline from events table (use canonical event_type)
      const timeline = events.slice(0, 15).map(e => ({
        timestamp: e.timestamp,
        action: (e.event_type || 'action').replace(/_/g, ' '),
        details: formatEventDetailsForPacket(e)
      }));

      // Log packet_generated event
      logEvent(practiceId, 'packet_generated', { generated_at: now.toISOString() });

      return `
        <div class="dd-packet">
          <!-- Cover Page -->
          <div class="dd-cover">
            <div class="dd-cover-logo">Zenyte Holdings</div>
            <div class="dd-cover-title">Practice Due Diligence Packet</div>
            <div class="dd-cover-subtitle">Acquisition Analysis & Summary</div>
            <div class="dd-cover-practice">${escapeHtml(corePractice.dba_name || practice.name)}</div>
            <div class="dd-cover-date">Generated: ${generatedDate}</div>
            <div class="dd-cover-confidential">Confidential  Internal Use Only</div>
          </div>

          <!-- Page 2: Practice Snapshot & Pipeline -->
          <div class="dd-page page-break">
            <div class="dd-page-header">
              <div class="dd-page-header-logo">ZENYTE HOLDINGS</div>
              <div class="dd-page-header-title">Due Diligence Packet  ${escapeHtml(corePractice.dba_name || practice.name)}</div>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Practice Snapshot</div>
              <table class="dd-table">
                <tr>
                  <th>DBA Name</th>
                  <td>${escapeHtml(corePractice.dba_name || practice.name)}</td>
                </tr>
                <tr>
                  <th>Legal Name</th>
                  <td>${escapeHtml(corePractice.legal_name || corePractice.dba_name)}</td>
                </tr>
                <tr>
                  <th>Specialty</th>
                  <td>${escapeHtml(practice.specialty)}</td>
                </tr>
                <tr>
                  <th>Ownership Structure</th>
                  <td>${escapeHtml(ownershipStructure)}</td>
                </tr>
                <tr>
                  <th>Owner(s)</th>
                  <td>${ownersHtml}</td>
                </tr>
                <tr>
                  <th>Primary Location</th>
                  <td>${primaryLocationHtml}</td>
                </tr>
                <tr>
                  <th>Current Status</th>
                  <td><span class="dd-status-badge ${statusClass}">${practice.status}</span></td>
                </tr>
                <tr>
                  <th>Latest Monthly Revenue</th>
                  <td>${formatCurrency(practice.revenue)}</td>
                </tr>
                <tr>
                  <th>Created Date</th>
                  <td>${formatDateShort(corePractice.created_at)}</td>
                </tr>
                <tr>
                  <th>Last Updated</th>
                  <td>${formatDateShort(corePractice.updated_at)}</td>
                </tr>
                <tr>
                  <th>Data Version</th>
                  <td>${corePractice.data_version || 'legacy'}</td>
                </tr>
              </table>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Locations</div>
              <div style="font-size: 10pt;">${locationsHtml}</div>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Pipeline Summary</div>
              <div class="dd-pipeline-box">
                <div class="dd-pipeline-stage">
                  <strong>Current Stage:</strong> ${practice.status}
                </div>
                <div class="dd-pipeline-recommendation">
                  <strong>Recommended Next Step:</strong> ${pipelineRec}
                </div>
              </div>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Practice Details & Operations</div>
              <table class="dd-table">
                <tr>
                  <th>Years in Operation</th>
                  <td>${corePractice.years_in_operation ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Number of Providers</th>
                  <td>${corePractice.num_providers ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Number of Locations</th>
                  <td>${corePractice.num_locations ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Number of Exam Rooms</th>
                  <td>${corePractice.num_exam_rooms ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Clinical Staff</th>
                  <td>${corePractice.num_staff_clinical ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Admin Staff</th>
                  <td>${corePractice.num_staff_admin ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Monthly Patient Volume</th>
                  <td>${corePractice.monthly_patient_volume_claimed ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>New Patients/Month</th>
                  <td>${corePractice.new_patients_monthly_claimed ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Hours/Week</th>
                  <td>${corePractice.hours_per_week ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Accepts New Patients</th>
                  <td>${formatYesNoMaybe(corePractice.accepts_new_patients)}</td>
                </tr>
                <tr>
                  <th>Has Telehealth</th>
                  <td>${formatYesNoMaybe(corePractice.has_telehealth)}</td>
                </tr>
                <tr>
                  <th>Replacement Doctor Required</th>
                  <td>${formatYesNoUnknown(corePractice.replacement_doctor_required)}</td>
                </tr>
                <tr>
                  <th>Revenue Model</th>
                  <td>${formatRevenueModel(corePractice.revenue_model)}</td>
                </tr>
                <tr>
                  <th>Est. EBITDA Margin</th>
                  <td>${corePractice.est_ebitda_margin ? corePractice.est_ebitda_margin + '%' : 'Not set'}</td>
                </tr>
                <tr>
                  <th>Growth Rate Est.</th>
                  <td>${formatGrowthRate(corePractice.growth_rate_est)}</td>
                </tr>
              </table>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Ownership / Exit Context</div>
              <table class="dd-table">
                <tr>
                  <th>Owner Age</th>
                  <td>${corePractice.owner_age ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Exit Intent</th>
                  <td>${formatExitIntent(corePractice.owner_exit_intent)}</td>
                </tr>
                <tr>
                  <th>Open to Rebrand</th>
                  <td>${formatYesNoUnknown(corePractice.openness_to_rebrand)}</td>
                </tr>
                <tr>
                  <th>Willingness to Stay On</th>
                  <td>${formatStayOn(corePractice.willingness_to_stay_on)}</td>
                </tr>
                <tr>
                  <th>Tags</th>
                  <td>${(corePractice.tags || []).length > 0 ? corePractice.tags.join(', ') : 'None'}</td>
                </tr>
              </table>
            </div>

            <div class="dd-page-footer">
              <span>Zenyte Holdings  Confidential</span>
              <span>Page 2</span>
            </div>
          </div>

          <!-- Page 3: Payer Mix, Technology & Real Estate -->
          <div class="dd-page page-break">
            <div class="dd-page-header">
              <div class="dd-page-header-logo">ZENYTE HOLDINGS</div>
              <div class="dd-page-header-title">Due Diligence Packet  ${escapeHtml(corePractice.dba_name || practice.name)}</div>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Payer Mix</div>
              <table class="dd-table">
                <tr>
                  <th>Commercial</th>
                  <td>${formatPercent(corePractice.payer_mix_commercial)}</td>
                </tr>
                <tr>
                  <th>Medicare</th>
                  <td>${formatPercent(corePractice.payer_mix_medicare)}</td>
                </tr>
                <tr>
                  <th>Medicaid</th>
                  <td>${formatPercent(corePractice.payer_mix_medicaid)}</td>
                </tr>
                <tr>
                  <th>Cash/Self-Pay</th>
                  <td>${formatPercent(corePractice.payer_mix_cash)}</td>
                </tr>
                <tr>
                  <th>Other</th>
                  <td>${formatPercent(corePractice.payer_mix_other)}</td>
                </tr>
                <tr>
                  <th>Top Payers</th>
                  <td>${corePractice.top_payers || 'Not set'}</td>
                </tr>
              </table>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Technology</div>
              <table class="dd-table">
                <tr>
                  <th>EMR System</th>
                  <td>${corePractice.emr_system || 'Not set'}</td>
                </tr>
                <tr>
                  <th>Practice Mgmt System</th>
                  <td>${corePractice.practice_mgmt_system || 'Not set'}</td>
                </tr>
                <tr>
                  <th>Billing System</th>
                  <td>${corePractice.billing_system || 'Not set'}</td>
                </tr>
                <tr>
                  <th>EMR Data Exportable</th>
                  <td>${formatYesNoMaybe(corePractice.emr_data_exportable)}</td>
                </tr>
              </table>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Real Estate</div>
              <table class="dd-table">
                <tr>
                  <th>Status</th>
                  <td>${formatRealEstateStatus(corePractice.real_estate_status)}</td>
                </tr>
                <tr>
                  <th>Lease Expiration</th>
                  <td>${corePractice.lease_expiration ? formatDateShort(corePractice.lease_expiration) : 'Not set'}</td>
                </tr>
                <tr>
                  <th>Monthly Rent (Claimed)</th>
                  <td>${corePractice.lease_monthly_rent_claimed ? formatCurrency(corePractice.lease_monthly_rent_claimed) : 'Not set'}</td>
                </tr>
                <tr>
                  <th>Square Footage</th>
                  <td>${corePractice.square_footage ? corePractice.square_footage.toLocaleString() + ' sq ft' : 'Not set'}</td>
                </tr>
                <tr>
                  <th>Facility Condition</th>
                  <td>${formatFacilityCondition(corePractice.facility_condition)}</td>
                </tr>
                <tr>
                  <th>Expansion Possible</th>
                  <td>${formatYesNoMaybe(corePractice.expansion_possible)}</td>
                </tr>
              </table>
            </div>

            <div class="dd-page-footer">
              <span>Zenyte Holdings  Confidential</span>
              <span>Page 3</span>
            </div>
          </div>

          <!-- Page 4: Legal, Deal Terms & Quality -->
          <div class="dd-page page-break">
            <div class="dd-page-header">
              <div class="dd-page-header-logo">ZENYTE HOLDINGS</div>
              <div class="dd-page-header-title">Due Diligence Packet  ${escapeHtml(corePractice.dba_name || practice.name)}</div>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Legal & Corporate</div>
              <table class="dd-table">
                <tr>
                  <th>Entity Type</th>
                  <td>${corePractice.entity_type || 'Not set'}</td>
                </tr>
                <tr>
                  <th>State of Incorporation</th>
                  <td>${corePractice.state_of_incorporation || 'Not set'}</td>
                </tr>
                <tr>
                  <th>Tax ID (last 4)</th>
                  <td>${corePractice.tax_id_last4 || 'Not set'}</td>
                </tr>
                <tr>
                  <th>Outstanding Litigation</th>
                  <td>${formatYesNoMaybe(corePractice.outstanding_litigation)}</td>
                </tr>
                <tr>
                  <th>Malpractice Claims (5yr)</th>
                  <td>${corePractice.malpractice_claims_5yr ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Contracts Assignable</th>
                  <td>${formatYesNoMaybe(corePractice.contracts_assignable)}</td>
                </tr>
              </table>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Deal Terms</div>
              <table class="dd-table">
                <tr>
                  <th>Asking Price</th>
                  <td>${corePractice.asking_price ? formatCurrency(corePractice.asking_price) : 'Not set'}</td>
                </tr>
                <tr>
                  <th>Deal Structure Preference</th>
                  <td>${formatDealStructure(corePractice.deal_structure_pref)}</td>
                </tr>
                <tr>
                  <th>Seller Financing Available</th>
                  <td>${formatYesNoMaybe(corePractice.seller_financing_available)}</td>
                </tr>
                <tr>
                  <th>Transition Support (months)</th>
                  <td>${corePractice.transition_support_months ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Earnout Acceptable</th>
                  <td>${formatYesNoMaybe(corePractice.earnout_acceptable)}</td>
                </tr>
                <tr>
                  <th>Exclusivity Status</th>
                  <td>${formatExclusivityStatus(corePractice.exclusivity_status)}</td>
                </tr>
                <tr>
                  <th>Exclusivity Expires</th>
                  <td>${corePractice.exclusivity_expires ? formatDateShort(corePractice.exclusivity_expires) : 'N/A'}</td>
                </tr>
              </table>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Quality & Market Position</div>
              <table class="dd-table">
                <tr>
                  <th>Google Rating (Claimed)</th>
                  <td>${corePractice.google_rating_claimed ? corePractice.google_rating_claimed + ' / 5.0' : 'Not set'}</td>
                </tr>
                <tr>
                  <th>Google Reviews (Claimed)</th>
                  <td>${corePractice.google_review_count_claimed ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Accreditations</th>
                  <td>${corePractice.accreditations || 'Not set'}</td>
                </tr>
                <tr>
                  <th>Internal Quality Score</th>
                  <td>${corePractice.quality_score_internal ?? 'Not set'}</td>
                </tr>
                <tr>
                  <th>Market Position</th>
                  <td>${formatMarketPosition(corePractice.market_position)}</td>
                </tr>
                <tr>
                  <th>Competition Density</th>
                  <td>${formatCompetitionDensity(corePractice.competition_density)}</td>
                </tr>
                <tr>
                  <th>Referral Sources</th>
                  <td>${corePractice.referral_sources || 'Not set'}</td>
                </tr>
              </table>
            </div>

            <div class="dd-page-footer">
              <span>Zenyte Holdings  Confidential</span>
              <span>Page 4</span>
            </div>
          </div>

          <!-- Page 5: Financials & Risk Flags -->
          <div class="dd-page page-break">
            <div class="dd-page-header">
              <div class="dd-page-header-logo">ZENYTE HOLDINGS</div>
              <div class="dd-page-header-title">Due Diligence Packet  ${escapeHtml(corePractice.dba_name || practice.name)}</div>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Financial History (Last 6 Months)</div>
              ${financialHistoryHtml}
              <div class="dd-metrics-grid" style="margin-top: 0.15in;">
                <div class="dd-metric-card">
                  <div class="dd-metric-label">Practice Monthly Revenue</div>
                  <div class="dd-metric-value">${formatCurrency(practice.revenue)}</div>
                </div>
                <div class="dd-metric-card">
                  <div class="dd-metric-label">Portfolio Total Revenue</div>
                  <div class="dd-metric-value">${formatCurrency(portfolioRevenue)}</div>
                </div>
              </div>
              <p style="font-size: 9pt; color: #888; margin-top: 0.1in; text-align: center;">
                Portfolio includes ${portfolioCount} practice${portfolioCount !== 1 ? 's' : ''}
              </p>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Risk Flags</div>
              <div class="dd-flags">
                ${flags.length > 0 ? flags.map(f => `
                  <div class="dd-flag ${f.type === 'warning' ? 'dd-flag-warning' : 'dd-flag-success'}">
                    <span class="dd-flag-icon">${f.type === 'warning' ? '' : ''}</span>
                    <span>${escapeHtml(f.message)}</span>
                  </div>
                `).join('') : `
                  <div class="dd-flag dd-flag-success">
                    <span class="dd-flag-icon"></span>
                    <span>No risk flags identified</span>
                  </div>
                `}
              </div>
              ${riskFlags.computed_at ? `<p style="font-size: 8pt; color: #888;">Last computed: ${formatTimestamp(riskFlags.computed_at)}</p>` : ''}
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Notes</div>
              <div style="font-size: 10pt; padding: 8px; background: #f9f9f9; border-radius: 4px;">
                ${practice.notes ? escapeHtml(practice.notes) : '<em>No notes provided</em>'}
              </div>
            </div>

            <div class="dd-page-footer">
              <span>Zenyte Holdings  Confidential</span>
              <span>Page 5</span>
            </div>
          </div>

          <!-- Page 6: Timeline & Checklist -->
          <div class="dd-page page-break">
            <div class="dd-page-header">
              <div class="dd-page-header-logo">ZENYTE HOLDINGS</div>
              <div class="dd-page-header-title">Due Diligence Packet  ${escapeHtml(corePractice.dba_name || practice.name)}</div>
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Activity Timeline</div>
              ${timeline.length > 0 ? `
                <div class="dd-timeline">
                  ${timeline.map(entry => `
                    <div class="dd-timeline-item">
                      <div class="dd-timeline-date">${formatTimestamp(entry.timestamp)}</div>
                      <div class="dd-timeline-action"><strong>${escapeHtml(entry.action)}:</strong> ${escapeHtml(entry.details || '')}</div>
                    </div>
                  `).join('')}
                </div>
              ` : '<p style="color: #888; font-style: italic;">No activity recorded</p>'}
            </div>

            <div class="dd-section">
              <div class="dd-section-title">Next Actions Checklist</div>
              <ul class="dd-checklist">
                <li>
                  <div class="dd-checkbox"></div>
                  <span>Confirm ownership structure and primary contact information</span>
                </li>
                <li>
                  <div class="dd-checkbox"></div>
                  <span>Collect and review financial statements (P&L, Balance Sheet)</span>
                </li>
                <li>
                  <div class="dd-checkbox"></div>
                  <span>Confirm payer mix and reimbursement rates</span>
                </li>
                <li>
                  <div class="dd-checkbox"></div>
                  <span>Schedule onboarding/discovery call with practice owner</span>
                </li>
                <li>
                  <div class="dd-checkbox"></div>
                  <span>Review existing contracts and vendor agreements</span>
                </li>
                <li>
                  <div class="dd-checkbox"></div>
                  <span>Assess technology stack and EHR/EMR systems</span>
                </li>
                <li>
                  <div class="dd-checkbox"></div>
                  <span>Complete compliance and regulatory review</span>
                </li>
              </ul>
            </div>

            <div class="dd-page-footer">
              <span>Zenyte Holdings  Confidential</span>
              <span>Page 6</span>
            </div>
          </div>
        </div>
      `;
    }

    function formatEventDetailsForPacket(event) {
      const payload = event.payload || {};
      if (event.event_type === 'status_changed') {
        return `${payload.old || ''}  ${payload.new || ''}`;
      }
      if (payload.details) return payload.details;
      if (payload.name) return `Name: ${payload.name}`;
      if (payload.type && payload.value !== undefined) return `${payload.type}: ${formatCurrency(payload.value)}`;
      return event.event_type || 'Action recorded';
    }

    function generateRiskFlagsForPacket(practice, riskFlags) {
      const flags = [];

      // Use computed risk flags from canonical model
      if (riskFlags.missing_fields && riskFlags.missing_fields.length > 0) {
        riskFlags.missing_fields.forEach(field => {
          const fieldLabels = {
            'legal_name': 'Missing legal name',
            'dba_name': 'Missing DBA name',
            'specialty': 'Missing specialty',
            'owner': 'No owner on file',
            'location': 'No locations on file',
            'monthly_revenue': 'Missing revenue data'
          };
          flags.push({
            type: 'warning',
            message: fieldLabels[field] || `Missing: ${field}`
          });
        });
      }

      if (riskFlags.aging_flags && riskFlags.aging_flags.length > 0) {
        riskFlags.aging_flags.forEach(flag => {
          const flagLabels = {
            'stale_lead_14d': 'Stale lead  in Lead status for >14 days',
            'stale_onboarding_30d': 'Stale onboarding  in Onboarding for >30 days'
          };
          flags.push({
            type: 'warning',
            message: flagLabels[flag] || flag
          });
        });
      }

      // Legacy flag checks for backward compat
      if (!practice.notes || practice.notes.trim() === '') {
        // Only add if not already in missing_fields
        if (!riskFlags.missing_fields || !riskFlags.missing_fields.includes('notes')) {
          flags.push({
            type: 'warning',
            message: 'Missing notes  no additional context recorded'
          });
        }
      }

      return flags;
    }

    // Legacy function for backward compat
    function generateRiskFlags(practice) {
      const riskFlags = computePracticeRiskFlags(practice.id);
      return generateRiskFlagsForPacket(practice, riskFlags);
    }

    function getPipelineRecommendation(status) {
      switch (status) {
        case 'Lead':
          return 'Schedule initial discovery call to qualify the opportunity and gather preliminary financials.';
        case 'Onboarding':
          return 'Complete due diligence documentation, finalize terms, and prepare for integration planning.';
        case 'Active':
          return 'Monitor performance metrics, ensure smooth operations, and identify optimization opportunities.';
        default:
          return 'Review practice status and determine appropriate next steps.';
      }
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function openPacketPreview() {
      if (!selectedPracticeId) return;

      // Use display data to get computed fields (owner, revenue, notes, activityLog)
      const practiceData = getPracticeDisplayData(selectedPracticeId);
      if (!practiceData) return;

      // Generate packet HTML
      const packetHTML = generatePacketHTML(practiceData);

      // Render into preview container
      document.getElementById('packet-preview').innerHTML = packetHTML;

      // Show packet modal
      document.getElementById('packet-modal').classList.add('visible');
      document.getElementById('packet-modal').classList.add('packet-visible');
    }

    function closePacketPreview() {
      document.getElementById('packet-modal').classList.remove('visible');
      document.getElementById('packet-modal').classList.remove('packet-visible');
    }

    function printPacket() {
      window.print();
    }

    function downloadPacketHTML() {
      if (!selectedPracticeId) return;

      // Use display data to get computed fields (owner, revenue, notes, activityLog)
      const practiceData = getPracticeDisplayData(selectedPracticeId);
      if (!practiceData) return;

      // Generate standalone HTML document
      const packetContent = generatePacketHTML(practiceData);
      const standaloneHTML = generateStandalonePacketHTML(practiceData, packetContent);

      const blob = new Blob([standaloneHTML], { type: 'text/html' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `dd-packet-${practiceData.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}-${Date.now()}.html`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function generateStandalonePacketHTML(practice, packetContent) {
      return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Due Diligence Packet  ${escapeHtml(practice.name)}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Georgia', 'Times New Roman', serif;
      color: #333;
      line-height: 1.5;
      font-size: 11pt;
      background: #f5f5f5;
    }
    .dd-packet { max-width: 8.5in; margin: 0 auto; background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    .dd-cover { padding: 2in 1in 1in 1in; text-align: center; min-height: 11in; display: flex; flex-direction: column; justify-content: center; border-bottom: 3px solid #1a1a2e; }
    .dd-cover-logo { font-size: 14pt; font-weight: 600; letter-spacing: 2px; color: #1a1a2e; margin-bottom: 0.5in; text-transform: uppercase; }
    .dd-cover-title { font-size: 28pt; font-weight: 700; color: #1a1a2e; margin-bottom: 0.3in; line-height: 1.2; }
    .dd-cover-subtitle { font-size: 18pt; color: #4a6cf7; margin-bottom: 0.5in; font-style: italic; }
    .dd-cover-practice { font-size: 24pt; font-weight: 600; color: #333; margin-bottom: 1in; padding: 0.3in 0; border-top: 1px solid #ddd; border-bottom: 1px solid #ddd; }
    .dd-cover-date { font-size: 12pt; color: #666; }
    .dd-cover-confidential { margin-top: 1in; font-size: 10pt; color: #888; text-transform: uppercase; letter-spacing: 1px; }
    .dd-page { padding: 0.75in 1in; min-height: 11in; }
    .dd-page-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 0.2in; border-bottom: 2px solid #1a1a2e; margin-bottom: 0.4in; }
    .dd-page-header-logo { font-size: 10pt; font-weight: 600; color: #1a1a2e; letter-spacing: 1px; }
    .dd-page-header-title { font-size: 10pt; color: #666; }
    .dd-section { margin-bottom: 0.4in; }
    .dd-section-title { font-size: 14pt; font-weight: 700; color: #1a1a2e; margin-bottom: 0.15in; padding-bottom: 0.08in; border-bottom: 1px solid #ddd; }
    .dd-table { width: 100%; border-collapse: collapse; margin-bottom: 0.2in; }
    .dd-table th, .dd-table td { padding: 0.12in 0.15in; text-align: left; border: 1px solid #ddd; font-size: 10pt; }
    .dd-table th { background: #f5f7fa; font-weight: 600; color: #1a1a2e; width: 35%; }
    .dd-status-badge { display: inline-block; padding: 0.04in 0.15in; border-radius: 3px; font-size: 9pt; font-weight: 600; }
    .dd-status-lead { background: #fff3e0; color: #e65100; }
    .dd-status-onboarding { background: #e3f2fd; color: #1565c0; }
    .dd-status-active { background: #e8f5e9; color: #2e7d32; }
    .dd-pipeline-box { background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 0.2in; margin-bottom: 0.15in; }
    .dd-pipeline-stage { font-size: 11pt; margin-bottom: 0.1in; }
    .dd-pipeline-stage strong { color: #1a1a2e; }
    .dd-pipeline-recommendation { font-size: 10pt; color: #666; font-style: italic; }
    .dd-metrics-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.15in; }
    .dd-metric-card { background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 0.15in; text-align: center; }
    .dd-metric-label { font-size: 9pt; color: #666; text-transform: uppercase; letter-spacing: 0.5px; }
    .dd-metric-value { font-size: 18pt; font-weight: 700; color: #2e7d32; }
    .dd-timeline { border-left: 2px solid #4a6cf7; padding-left: 0.25in; margin-left: 0.1in; }
    .dd-timeline-item { margin-bottom: 0.15in; position: relative; }
    .dd-timeline-item::before { content: ''; position: absolute; left: -0.31in; top: 0.06in; width: 0.1in; height: 0.1in; background: #4a6cf7; border-radius: 50%; }
    .dd-timeline-date { font-size: 9pt; color: #888; }
    .dd-timeline-action { font-size: 10pt; color: #333; }
    .dd-flags { margin-bottom: 0.2in; }
    .dd-flag { display: flex; align-items: flex-start; gap: 0.1in; padding: 0.1in 0.15in; margin-bottom: 0.08in; border-radius: 4px; font-size: 10pt; }
    .dd-flag-warning { background: #fff3e0; border-left: 3px solid #e65100; color: #bf360c; }
    .dd-flag-success { background: #e8f5e9; border-left: 3px solid #2e7d32; color: #1b5e20; }
    .dd-flag-icon { font-weight: bold; }
    .dd-checklist { list-style: none; padding: 0; margin: 0; }
    .dd-checklist li { display: flex; align-items: flex-start; gap: 0.1in; padding: 0.08in 0; font-size: 10pt; border-bottom: 1px solid #eee; }
    .dd-checklist li:last-child { border-bottom: none; }
    .dd-checkbox { width: 0.15in; height: 0.15in; border: 1px solid #999; border-radius: 2px; flex-shrink: 0; margin-top: 0.02in; }
    .dd-page-footer { margin-top: 0.5in; padding-top: 0.15in; border-top: 1px solid #ddd; display: flex; justify-content: space-between; font-size: 9pt; color: #888; }
    .page-break { page-break-before: always; }
    @media print {
      body { background: white; }
      .dd-packet { box-shadow: none; max-width: none; }
      .dd-cover { min-height: auto; height: 100vh; }
      .dd-page { min-height: auto; }
      @page { margin: 0.5in; size: letter; }
    }
  </style>
</head>
<body>
  ${packetContent}
</body>
</html>`;
    }

    // =============================================
    // STATUS CHANGE FUNCTIONS (Table/Pipeline)
    // =============================================
    async function advanceStatus(practiceId, event) {
      // Permission check - admin and editor only
      if (!hasPermission('ADVANCE_STATUS')) {
        showPermissionDenied('change practice status');
        return;
      }

      const practice = getPracticeById(practiceId);
      if (!practice) return;

      const currentIndex = STATUS_ORDER.indexOf(practice.status);

      if (currentIndex < STATUS_ORDER.length - 1) {
        const oldStatus = practice.status;
        const newStatus = STATUS_ORDER[currentIndex + 1];

        // Supabase write path
        if (DATA_SOURCE === 'supabase') {
          try {
            await supabaseUpdatePractice(practiceId, { status: newStatus });
            console.log('Status advanced in Supabase:', practiceId, newStatus);
            await refreshFromSupabase();
            updateDataSourceBanner('supabase');

            // Trigger confetti only when advancing to Active
            if (newStatus === 'Active' && event) {
              const rect = event.target.getBoundingClientRect();
              createConfetti(rect.left + rect.width / 2, rect.top);
            }
            return;
          } catch (error) {
            console.error('Supabase status update failed:', error);
            showSupabaseWriteError(error.message);
            return;
          }
        }

        // Local storage path (unchanged)
        updateRecord('practices', practiceId, { status: newStatus });

        // Log status change event (canonical format)
        logEvent(practiceId, 'status_changed', { old: oldStatus, new: newStatus });

        // Recompute risk flags after status change
        recomputeRiskFlagsAfterChange(practiceId);

        renderAll();

        // Trigger confetti only when advancing to Active
        if (newStatus === 'Active' && event) {
          const rect = event.target.getBoundingClientRect();
          createConfetti(rect.left + rect.width / 2, rect.top);
        }
      }
    }

    async function regressStatus(practiceId) {
      // Permission check - admin and editor only
      if (!hasPermission('REGRESS_STATUS')) {
        showPermissionDenied('change practice status');
        return;
      }

      const practice = getPracticeById(practiceId);
      if (!practice) return;

      const currentIndex = STATUS_ORDER.indexOf(practice.status);

      if (currentIndex > 0) {
        const oldStatus = practice.status;
        const newStatus = STATUS_ORDER[currentIndex - 1];

        // Supabase write path
        if (DATA_SOURCE === 'supabase') {
          try {
            await supabaseUpdatePractice(practiceId, { status: newStatus });
            console.log('Status regressed in Supabase:', practiceId, newStatus);
            await refreshFromSupabase();
            updateDataSourceBanner('supabase');
            return;
          } catch (error) {
            console.error('Supabase status update failed:', error);
            showSupabaseWriteError(error.message);
            return;
          }
        }

        // Local storage path (unchanged)
        updateRecord('practices', practiceId, { status: newStatus });

        // Log status change event (canonical format)
        logEvent(practiceId, 'status_changed', { old: oldStatus, new: newStatus });

        // Recompute risk flags after status change
        recomputeRiskFlagsAfterChange(practiceId);

        renderAll();
      }
    }

    async function deletePractice(practiceId) {
      // Permission check - admin only
      if (!hasPermission('DELETE_PRACTICE')) {
        showPermissionDenied('delete practices');
        return;
      }

      const practice = getPracticeById(practiceId);
      if (!practice) return;

      if (confirm(`Are you sure you want to delete "${practice.dba_name || practice.legal_name}"?`)) {
        // Supabase write path
        if (DATA_SOURCE === 'supabase') {
          try {
            await supabaseDeletePractice(practiceId);
            console.log('Practice deleted from Supabase:', practiceId);
            await refreshFromSupabase();
            updateDataSourceBanner('supabase');
            return;
          } catch (error) {
            console.error('Supabase delete failed:', error);
            showSupabaseWriteError(error.message);
            return;
          }
        }

        // Local storage path (unchanged)
        // Log deletion event first (canonical format)
        logEvent(practiceId, 'practice_deleted', { name: practice.dba_name || practice.legal_name });

        // Delete related records using canonical practice_id field
        const practicePersonLinks = db.practice_people.filter(pp => pp.practice_id === practiceId);
        const linkedPersonIds = practicePersonLinks.map(pp => pp.person_id);

        db.practice_people = db.practice_people.filter(pp => pp.practice_id !== practiceId);
        db.people = db.people.filter(p => !linkedPersonIds.includes(p.id));
        db.locations = db.locations.filter(l => l.practice_id !== practiceId);
        db.metrics = db.metrics.filter(m => m.practice_id !== practiceId);
        db.notes = db.notes.filter(n => n.practice_id !== practiceId);
        db.documents = db.documents.filter(d => d.practice_id !== practiceId);
        // Keep events for audit trail, just delete the practice
        db.practices = db.practices.filter(p => p.id !== practiceId);

        saveDb();
        renderAll();
      }
    }

    // =============================================
    // SEARCH & FILTER SYSTEM
    // =============================================

    // Global filter state
    let filterState = {
      search: '',
      status: '',
      specialty: '',
      health: '',
      capitalReady: '',
      tag: ''
    };

    // Initialize specialty dropdowns with optgroups
    function initializeSpecialtyDropdowns() {
      const dropdowns = [
        document.getElementById('profile-specialty'),
        document.getElementById('filter-specialty'),
        document.getElementById('specialty') // intake form
      ];

      dropdowns.forEach(select => {
        if (!select) return;

        // Preserve current value
        const currentValue = select.value;

        // Clear and rebuild
        select.innerHTML = '<option value="">Select specialty...</option>';

        Object.entries(SPECIALTY_GROUPS).forEach(([groupName, specialties]) => {
          const optgroup = document.createElement('optgroup');
          optgroup.label = groupName;
          specialties.forEach(spec => {
            const option = document.createElement('option');
            option.value = spec.value;
            option.textContent = spec.label;
            optgroup.appendChild(option);
          });
          select.appendChild(optgroup);
        });

        // Restore value
        if (currentValue) select.value = currentValue;
      });

      // Filter specialty dropdown gets "All" option
      const filterSpecialty = document.getElementById('filter-specialty');
      if (filterSpecialty) {
        filterSpecialty.innerHTML = '<option value="">All Specialties</option>' + filterSpecialty.innerHTML.replace('<option value="">Select specialty...</option>', '');
      }
    }

    // Initialize tag dropdown with all unique tags
    function initializeTagDropdown() {
      const select = document.getElementById('filter-tag');
      if (!select) return;

      const allTags = new Set();
      db.practices.forEach(p => {
        (p.tags || []).forEach(tag => allTags.add(tag));
      });

      select.innerHTML = '<option value="">All Tags</option>';
      Array.from(allTags).sort().forEach(tag => {
        const option = document.createElement('option');
        option.value = tag;
        option.textContent = tag;
        select.appendChild(option);
      });
    }

    // Initialize document type dropdowns from registry
    async function initializeDocumentTypeDropdowns() {
      try {
        const { data: docTypes, error } = await window.sb
          .from('document_types')
          .select('slug, label, category, is_financial')
          .order('sort_order', { ascending: true });

        if (error) {
          console.error('Failed to load document types:', error);
          return;
        }

        // Build registry cache
        documentTypeRegistry = {};
        documentTypesByCategory = {};

        docTypes.forEach(dt => {
          documentTypeRegistry[dt.slug] = {
            label: dt.label,
            category: dt.category,
            is_financial: dt.is_financial
          };

          if (!documentTypesByCategory[dt.category]) {
            documentTypesByCategory[dt.category] = [];
          }
          documentTypesByCategory[dt.category].push({
            slug: dt.slug,
            label: dt.label,
            is_financial: dt.is_financial
          });
        });

        console.log('[Registry] Loaded', docTypes.length, 'document types');

        // Populate Financial Document Type dropdown
        const finDocType = document.getElementById('fin-doc-type');
        if (finDocType) {
          const financialTypes = docTypes.filter(dt => dt.is_financial);
          finDocType.innerHTML = financialTypes.map(dt =>
            `<option value="${dt.slug}">${dt.label}</option>`
          ).join('');
        }

        // Populate "Other DD" category dropdown
        const otherCategory = document.getElementById('dd-other-category');
        if (otherCategory) {
          const ddCategories = [
            { slug: 'dd_real_estate', label: 'Real Estate & Lease' },
            { slug: 'dd_insurance', label: 'Insurance' },
            { slug: 'dd_hr', label: 'HR & Staff' },
            { slug: 'dd_it', label: 'IT & Systems' },
            { slug: 'dd_equipment', label: 'Equipment & Assets' },
            { slug: 'practice_overview', label: 'Practice Overview' }
          ];
          otherCategory.innerHTML = ddCategories.map(cat =>
            `<option value="${cat.slug}">${cat.label}</option>`
          ).join('');
        }

      } catch (err) {
        console.error('Error initializing document type dropdowns:', err);
      }
    }

    // Helper to get document type label from registry
    function getDocTypeLabel(slug) {
      return documentTypeRegistry[slug]?.label || slug;
    }

    // Get filtered practices based on current filter state
    function getFilteredPractices() {
      const practices = getPractices(); // Uses getPracticeDisplayData

      return practices.filter(p => {
        // Search filter (name, specialty, owner, tags)
        if (filterState.search) {
          const searchLower = filterState.search.toLowerCase();
          const nameMatch = (p.name || '').toLowerCase().includes(searchLower);
          const specialtyMatch = (p.specialty || '').toLowerCase().includes(searchLower);
          const ownerMatch = (p.owner || '').toLowerCase().includes(searchLower);
          const tagsMatch = (p.tags || []).some(t => t.toLowerCase().includes(searchLower));
          const legalNameMatch = (p.legal_name || '').toLowerCase().includes(searchLower);
          const dbaNameMatch = (p.dba_name || '').toLowerCase().includes(searchLower);

          if (!nameMatch && !specialtyMatch && !ownerMatch && !tagsMatch && !legalNameMatch && !dbaNameMatch) {
            return false;
          }
        }

        // Status filter
        if (filterState.status && p.status !== filterState.status) {
          return false;
        }

        // Specialty filter
        if (filterState.specialty && p.specialty !== filterState.specialty) {
          return false;
        }

        // Health filter
        if (filterState.health) {
          const intel = computePracticeIntelligence(p.id);
          if (intel.health !== filterState.health) {
            return false;
          }
        }

        // Capital Ready filter
        if (filterState.capitalReady) {
          const intel = computePracticeIntelligence(p.id);
          const debug = intel._debug || {};
          const aging = debug.aging || [];
          const isCapitalReady = p.status === 'Active' &&
                                 intel.completeness_score >= 80 &&
                                 aging.length === 0;
          if (filterState.capitalReady === 'yes' && !isCapitalReady) return false;
          if (filterState.capitalReady === 'no' && isCapitalReady) return false;
        }

        // Tag filter
        if (filterState.tag) {
          const tags = p.tags || [];
          if (!tags.includes(filterState.tag)) {
            return false;
          }
        }

        return true;
      });
    }

    // Apply filters and re-render
    function applyFilters() {
      filterState.search = document.getElementById('global-search').value.trim();
      filterState.status = document.getElementById('filter-status').value;
      filterState.specialty = document.getElementById('filter-specialty').value;
      filterState.health = document.getElementById('filter-health').value;
      filterState.capitalReady = document.getElementById('filter-capital-ready').value;
      filterState.tag = document.getElementById('filter-tag').value;

      renderAll();
    }

    // Clear all filters
    function clearFilters() {
      document.getElementById('global-search').value = '';
      document.getElementById('filter-status').value = '';
      document.getElementById('filter-specialty').value = '';
      document.getElementById('filter-health').value = '';
      document.getElementById('filter-capital-ready').value = '';
      document.getElementById('filter-tag').value = '';

      filterState = {
        search: '',
        status: '',
        specialty: '',
        health: '',
        capitalReady: '',
        tag: ''
      };

      renderAll();
    }

    // Check if any filters are active
    function hasActiveFilters() {
      return filterState.search || filterState.status || filterState.specialty ||
             filterState.health || filterState.capitalReady || filterState.tag;
    }

    // =============================================
    // TAG MANAGEMENT
    // =============================================

    // Render tags in profile
    function renderProfileTags(tags) {
      const container = document.getElementById('profile-tags');
      if (!container) return;

      // Get the input wrapper (preserve it)
      const inputWrapper = container.querySelector('.tag-input-wrapper');

      // Clear existing tags (but not input)
      const existingTags = container.querySelectorAll('.tag');
      existingTags.forEach(t => t.remove());

      // Add tags before the input
      (tags || []).forEach(tag => {
        const tagEl = document.createElement('span');
        tagEl.className = 'tag';
        tagEl.innerHTML = `${tag}<span class="tag-remove" onclick="removeTag('${tag}')">&times;</span>`;
        container.insertBefore(tagEl, inputWrapper);
      });
    }

    // Handle tag input (Enter key)
    function handleTagInput(event) {
      if (event.key !== 'Enter') return;
      event.preventDefault();

      const input = document.getElementById('profile-tag-input');
      const tag = input.value.trim().toLowerCase().replace(/[^a-z0-9-]/g, '-');

      if (!tag || !selectedPracticeId) return;

      const practice = getPracticeById(selectedPracticeId);
      if (!practice) return;

      // Add tag if not exists
      const tags = practice.tags || [];
      if (!tags.includes(tag)) {
        tags.push(tag);
        updateRecord('practices', selectedPracticeId, { tags });
        logEvent(selectedPracticeId, 'tag_added', { tag });
        renderProfileTags(tags);
        initializeTagDropdown(); // Refresh dropdown
      }

      input.value = '';
    }

    // Remove tag from practice
    function removeTag(tag) {
      if (!selectedPracticeId) return;

      const practice = getPracticeById(selectedPracticeId);
      if (!practice) return;

      const tags = (practice.tags || []).filter(t => t !== tag);
      updateRecord('practices', selectedPracticeId, { tags });
      logEvent(selectedPracticeId, 'tag_removed', { tag });
      renderProfileTags(tags);
      initializeTagDropdown(); // Refresh dropdown
    }

    // =============================================
    // RENDER HELPER
    // =============================================
    function renderAll() {
      renderTable();
      if (currentView === 'pipeline') {
        renderPipeline();
      } else if (currentView === 'portfolio') {
        renderPortfolioIntelligence();
      }
      updateMetrics();
    }

    // =============================================
    // FORM SUBMISSION
    // =============================================
    document.getElementById('intake-form').addEventListener('submit', async function(e) {
      e.preventDefault();
      const form = this;

      const now = new Date().toISOString();
      const practiceId = generatePracticeId();
      const practiceName = document.getElementById('practiceName').value.trim();
      const ownerName = document.getElementById('ownerName').value.trim();
      const revenueValue = document.getElementById('monthlyRevenue').value;
      const notesValue = document.getElementById('notes').value.trim();
      const specialty = document.getElementById('specialty').value;

      // Create canonical Practice v1 record
      const practice = createCanonicalPractice({
        id: practiceId,
        name: practiceName,
        legal_name: practiceName,
        dba_name: practiceName,
        specialty: specialty,
        status: 'Lead',
        ownership_structure: 'Unknown',
        created_at: now,
        updated_at: now
      }, now);

      // Supabase write path (practices + people + practice_people)
      if (DATA_SOURCE === 'supabase') {
        try {
          // 1. Insert practice
          await supabaseInsertPractice(practice);
          console.log('Practice inserted to Supabase:', practiceId);

          // 2. If owner name provided, create person + link
          if (ownerName) {
            const nameParts = ownerName.split(' ');
            const personId = generatePersonId();

            const person = {
              id: personId,
              first_name: nameParts[0] || '',
              last_name: nameParts.slice(1).join(' ') || '',
              email: '',
              phone: '',
              created_at: now,
              updated_at: now
            };

            await supabaseUpsertPerson(person);
            console.log('Person inserted to Supabase:', personId);

            const link = {
              id: generatePracticePersonId(),
              practice_id: practiceId,
              person_id: personId,
              role: 'owner',
              is_primary: true,
              ownership_pct: 100,
              created_at: now
            };

            await supabaseUpsertPracticePersonLink(link);
            console.log('Practice-person link inserted to Supabase');
          }

          // 3. If notes provided, create note
          if (notesValue) {
            const note = {
              id: generateNoteId(),
              practice_id: practiceId,
              author_id: 'system',
              content: notesValue,
              is_pinned: false,
              created_at: now,
              updated_at: now
            };

            await supabaseInsertNote(note);
            console.log('Note inserted to Supabase');
          }

          // 4. If monthly revenue provided, create metric
          if (revenueValue && Number(revenueValue) > 0) {
            const metric = {
              id: generateMetricId(),
              practice_id: practiceId,
              type: 'monthly_revenue',
              period: getCurrentPeriodYYYYMM(),
              value: parseFloat(revenueValue),
              source: 'user',
              created_at: now
            };

            await supabaseUpsertMetric(metric);
            console.log('Metric inserted to Supabase:', metric.value);
          }

          // 5. Log practice_created event
          const event = {
            id: generateEventId(),
            practice_id: practiceId,
            event_type: 'practice_created',
            actor_id: null,
            timestamp: now,
            payload: { name: practiceName, specialty: specialty }
          };
          await supabaseInsertEvent(event);
          console.log('Event logged to Supabase: practice_created');

          // Refresh from Supabase and re-render
          await refreshFromSupabase();
          updateDataSourceBanner('supabase');
          form.reset();
          return;
        } catch (error) {
          console.error('Supabase insert failed:', error);
          showSupabaseWriteError(error.message);
          return; // Do NOT fall back to local writes
        }
      }

      // Local storage path (unchanged)
      db.practices.push(practice);

      // Create person record and join table entry for owner (canonical only)
      if (ownerName) {
        const nameParts = ownerName.split(' ');
        const personId = generatePersonId();

        // Use canonical creator - NO legacy fields
        const person = createCanonicalPerson({
          id: personId,
          first_name: nameParts[0] || '',
          last_name: nameParts.slice(1).join(' ') || '',
          email: '',
          phone: '',
          created_at: now,
          updated_at: now
        }, now);
        db.people.push(person);

        // Create practice_people join entry (canonical only)
        const link = createCanonicalPracticePersonLink({
          practice_id: practiceId,
          person_id: personId,
          role: 'owner',
          is_primary: true,
          ownership_pct: 100,
          created_at: now
        }, now);
        db.practice_people.push(link);

        // Log owner_added event
        logEvent(practiceId, 'owner_added', { person_id: personId, name: ownerName });
      }

      // Create metric record for revenue (canonical only)
      if (revenueValue && Number(revenueValue) > 0) {
        const metric = createCanonicalMetric({
          practice_id: practiceId,
          location_id: null,
          period: getCurrentPeriod(),
          metric_type: 'monthly_revenue',
          value: Number(revenueValue),
          source: 'manual',
          created_at: now
        }, now);
        db.metrics.push(metric);

        // Log metric_added event
        logEvent(practiceId, 'metric_added', { type: 'monthly_revenue', value: Number(revenueValue), period: getCurrentPeriod() });
      }

      // Create note record (canonical only)
      if (notesValue) {
        const note = createCanonicalNote({
          practice_id: practiceId,
          author_id: 'system',
          content: notesValue,
          is_pinned: false,
          created_at: now,
          updated_at: now
        }, now);
        db.notes.push(note);

        // Log note_added event
        logEvent(practiceId, 'note_added', { content_preview: notesValue.substring(0, 50) });
      }

      // Log practice_created event
      logEvent(practiceId, 'practice_created', { name: practiceName, specialty: specialty });

      saveDb();

      // Compute initial risk flags
      recomputeRiskFlagsAfterChange(practiceId);

      renderAll();

      form.reset();
    });

    // =============================================
    // KEYBOARD & CLICK HANDLERS
    // =============================================
    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        if (document.getElementById('packet-modal').classList.contains('visible')) {
          closePacketPreview();
        } else if (selectedPracticeId) {
          closeProfile();
        }
      }
    });

    // Close modal when clicking outside
    document.getElementById('profile-modal').addEventListener('click', function(e) {
      if (e.target === this) {
        closeProfile();
      }
    });

    document.getElementById('packet-modal').addEventListener('click', function(e) {
      if (e.target === this) {
        closePacketPreview();
      }
    });

    // =============================================
    // AUTHENTICATION
    // =============================================
    let isSignUpMode = false;
    let currentUser = null;

    function toggleAuthMode() {
      isSignUpMode = !isSignUpMode;
      const btn = document.getElementById('login-btn');
      const toggle = document.getElementById('login-toggle');

      if (isSignUpMode) {
        btn.textContent = 'Sign Up';
        toggle.innerHTML = 'Already have an account? <a onclick="toggleAuthMode()">Sign In</a>';
      } else {
        btn.textContent = 'Sign In';
        toggle.innerHTML = 'Don\'t have an account? <a onclick="toggleAuthMode()">Sign Up</a>';
      }
      hideLoginError();
    }

    function showLoginError(message) {
      const errorDiv = document.getElementById('login-error');
      errorDiv.textContent = message;
      errorDiv.classList.add('visible');
    }

    function hideLoginError() {
      const errorDiv = document.getElementById('login-error');
      errorDiv.textContent = '';
      errorDiv.classList.remove('visible');
    }

    function resetLoginButton() {
      const btn = document.getElementById('login-btn');
      if (!btn) return;
      btn.disabled = false;
      btn.textContent = isSignUpMode ? 'Sign Up' : 'Sign In';
    }

    function showApp(user) {
      currentUser = user;
      document.getElementById('auth-loading-screen').style.display = 'none';
      document.getElementById('login-screen').style.display = 'none';
      document.getElementById('app-container').classList.add('authenticated');
      document.getElementById('user-email').textContent = user.email;
    }

    /**
     * Update UI elements based on user's role
     * Called after auth to hide/disable elements for restricted roles
     */
    function updateUIForRole() {
      const role = window.currentUserOrgRole;
      console.log('[Permissions] Updating UI for role:', role);

      // Get UI elements
      const addPracticeBtn = document.getElementById('add-practice-btn');
      const profileDeleteBtn = document.querySelector('.quick-actions .btn-delete');
      const profileAdvanceBtn = document.querySelector('.quick-actions .btn-advance');
      const profileBackBtn = document.querySelector('.quick-actions .btn-back');
      const profileSaveBtn = document.querySelector('.profile-actions .btn-primary');

      // Viewers: Hide all action buttons, disable form fields
      if (isReadOnly()) {
        // Hide action buttons
        if (addPracticeBtn) addPracticeBtn.style.display = 'none';
        if (profileDeleteBtn) profileDeleteBtn.style.display = 'none';
        if (profileAdvanceBtn) profileAdvanceBtn.style.display = 'none';
        if (profileBackBtn) profileBackBtn.style.display = 'none';
        if (profileSaveBtn) profileSaveBtn.style.display = 'none';

        // Disable all form inputs
        document.querySelectorAll('#profile-form input, #profile-form select, #profile-form textarea').forEach(el => {
          el.disabled = true;
        });

        // Show role indicator
        const roleIndicator = document.createElement('div');
        roleIndicator.id = 'role-indicator';
        roleIndicator.className = 'role-indicator viewer';
        roleIndicator.textContent = 'View Only';
        roleIndicator.style.cssText = 'position:fixed;top:10px;right:10px;background:#6b7280;color:white;padding:4px 12px;border-radius:4px;font-size:12px;z-index:1000;';
        if (!document.getElementById('role-indicator')) {
          document.body.appendChild(roleIndicator);
        }
      }

      // Editors: Hide delete buttons (they can still see advance/back)
      if (isOrgEditor()) {
        if (profileDeleteBtn) profileDeleteBtn.style.display = 'none';

        // Show role indicator
        const roleIndicator = document.createElement('div');
        roleIndicator.id = 'role-indicator';
        roleIndicator.className = 'role-indicator editor';
        roleIndicator.textContent = 'Editor';
        roleIndicator.style.cssText = 'position:fixed;top:10px;right:10px;background:#3b82f6;color:white;padding:4px 12px;border-radius:4px;font-size:12px;z-index:1000;';
        if (!document.getElementById('role-indicator')) {
          document.body.appendChild(roleIndicator);
        }
      }

      // Admins: Show everything (default state), add indicator
      if (isOrgAdmin()) {
        const roleIndicator = document.createElement('div');
        roleIndicator.id = 'role-indicator';
        roleIndicator.className = 'role-indicator admin';
        roleIndicator.textContent = 'Admin';
        roleIndicator.style.cssText = 'position:fixed;top:10px;right:10px;background:#10b981;color:white;padding:4px 12px;border-radius:4px;font-size:12px;z-index:1000;';
        if (!document.getElementById('role-indicator')) {
          document.body.appendChild(roleIndicator);
        }
      }
    }

    function hideApp() {
      currentUser = null;
      document.getElementById('auth-loading-screen').style.display = 'none';
      document.getElementById('login-screen').style.display = 'flex';
      document.getElementById('app-container').classList.remove('authenticated');
      document.getElementById('user-email').textContent = '';
    }

    async function handleLogin(email, password) {
      console.log('[Login] Starting login for:', email);
      const btn = document.getElementById('login-btn');
      btn.disabled = true;
      btn.textContent = isSignUpMode ? 'Signing up...' : 'Signing in...';
      hideLoginError();

      try {
        let result;

        if (isSignUpMode) {
          console.log('[Login] Calling signUp...');
          result = await window.sb.auth.signUp({
            email: email,
            password: password
          });
        } else {
          console.log('[Login] Calling signInWithPassword...');
          result = await window.sb.auth.signInWithPassword({
            email: email,
            password: password
          });
        }

        console.log('[Login] Auth result:', { error: result.error, user: result.data?.user?.email, session: !!result.data?.session });

        if (result.error) {
          throw result.error;
        }

        if (isSignUpMode && !result.data.session) {
          // Email confirmation required
          showLoginError('Check your email for a confirmation link.');
          return;
        }

        // Success - handle authenticated user directly (don't rely solely on auth state listener)
        console.log('[Login] Auth successful:', result.data.user?.email);
        if (result.data.user) {
          console.log('[Login] Calling handleAuthenticatedUser...');
          await handleAuthenticatedUser(result.data.user);
          console.log('[Login] handleAuthenticatedUser completed');
        }
      } catch (error) {
        console.error('[Login] Auth error:', error);
        showLoginError(error.message || 'Authentication failed. Please try again.');
      } finally {
        resetLoginButton();
      }
    }

    // =============================================
    // SETTINGS & AUDIT LOG FUNCTIONS
    // =============================================

    // Audit log state
    let auditLogData = [];
    let auditCurrentPage = 1;
    const auditPageSize = 25;
    let auditTotalCount = 0;
    let auditSearchTimeout = null;

    // Open settings panel (admin only)
    async function openSettings() {
      // Admin check
      if (window.currentUserRole !== 'admin') {
        alert('Access denied. Admin privileges required.');
        return;
      }

      document.getElementById('settings-overlay').style.display = 'flex';
      document.body.style.overflow = 'hidden';

      // Populate practice filter dropdown
      await populateAuditPracticeFilter();

      // Load audit log
      await loadAuditLog();
    }

    // Close settings panel
    function closeSettings() {
      document.getElementById('settings-overlay').style.display = 'none';
      document.body.style.overflow = '';
    }

    // Close on overlay click
    document.addEventListener('click', (e) => {
      if (e.target.id === 'settings-overlay') {
        closeSettings();
      }
    });

    // Close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.getElementById('settings-overlay').style.display === 'flex') {
        closeSettings();
      }
    });

    // Switch settings tabs
    function switchSettingsTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.settings-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === tabName);
      });

      // Update tab content
      document.querySelectorAll('.settings-content').forEach(content => {
        content.classList.toggle('active', content.id === `settings-${tabName}`);
      });

      // Load templates when switching to templates tab
      if (tabName === 'templates') {
        loadTemplates();
      }
    }

    // ========== Document Templates Functions ==========

    let documentTypesCache = [];

    // Load document types from database
    async function loadDocumentTypes() {
      if (documentTypesCache.length > 0) return documentTypesCache;
      try {
        const { data, error } = await window.sb
          .from('document_types')
          .select('code, label, category')
          .order('label');
        if (error) throw error;
        documentTypesCache = data || [];
        return documentTypesCache;
      } catch (err) {
        console.error('[Templates] Failed to load document types:', err);
        return [];
      }
    }

    // Load templates from database
    async function loadTemplates() {
      const container = document.getElementById('templates-list');
      if (!container) return;

      container.innerHTML = '<div class="templates-loading">Loading templates...</div>';

      try {
        const { data, error } = await window.sb
          .from('document_templates')
          .select('*')
          .eq('org_id', window.currentOrgId)
          .order('created_at', { ascending: false });

        if (error) throw error;

        if (!data || data.length === 0) {
          container.innerHTML = `
            <div class="templates-empty">
              <p>No templates yet. Create your first template to streamline document requests.</p>
            </div>
          `;
          return;
        }

        container.innerHTML = data.map(template => renderTemplateCard(template)).join('');
      } catch (err) {
        console.error('[Templates] Load error:', err);
        container.innerHTML = '<div class="templates-empty">Failed to load templates.</div>';
      }
    }

    // Render a template card
    function renderTemplateCard(template) {
      const items = template.items || [];
      const itemTags = items.slice(0, 5).map(item =>
        `<span class="template-item-tag">${escapeHtml(item.item_name)}</span>`
      ).join('');
      const moreItems = items.length > 5 ? `<span class="template-item-tag">+${items.length - 5} more</span>` : '';

      const categoryLabels = {
        intake: 'Intake',
        credentialing: 'Credentialing',
        financial: 'Financial',
        compliance: 'Compliance',
        real_estate: 'Real Estate',
        other: 'Other'
      };

      return `
        <div class="template-card" data-template-id="${template.id}">
          <div class="template-card-header">
            <h4 class="template-card-title">${escapeHtml(template.name)}</h4>
            <span class="template-card-category">${categoryLabels[template.category] || template.category || 'Other'}</span>
          </div>
          ${template.description ? `<p class="template-card-description">${escapeHtml(template.description)}</p>` : ''}
          <div class="template-card-items">
            ${itemTags}${moreItems}
          </div>
          <div class="template-card-footer">
            <span class="template-card-meta">${items.length} item${items.length !== 1 ? 's' : ''}  Used ${template.usage_count || 0} times</span>
            <div class="template-card-actions">
              <button class="btn-edit-template" onclick="editTemplate('${template.id}')">Edit</button>
              <button class="btn-delete-template" onclick="deleteTemplate('${template.id}')">Delete</button>
            </div>
          </div>
        </div>
      `;
    }

    // Open template modal for create/edit
    async function openTemplateModal(templateId = null) {
      await loadDocumentTypes();

      document.getElementById('template-modal-overlay').style.display = 'flex';
      document.getElementById('template-modal-title').textContent = templateId ? 'Edit Template' : 'Create Template';
      document.getElementById('template-edit-id').value = templateId || '';
      document.getElementById('template-name').value = '';
      document.getElementById('template-description').value = '';
      document.getElementById('template-category').value = 'intake';
      document.getElementById('template-items-list').innerHTML = '<div class="template-items-empty">No items yet. Click "+ Add Item" to add documents.</div>';

      if (templateId) {
        // Load existing template data
        try {
          const { data, error } = await window.sb
            .from('document_templates')
            .select('*')
            .eq('id', templateId)
            .single();

          if (error) throw error;

          document.getElementById('template-name').value = data.name || '';
          document.getElementById('template-description').value = data.description || '';
          document.getElementById('template-category').value = data.category || 'other';

          // Render existing items
          const items = data.items || [];
          if (items.length > 0) {
            document.getElementById('template-items-list').innerHTML = items.map((item, idx) =>
              renderTemplateItemRow(item, idx)
            ).join('');
          }
        } catch (err) {
          console.error('[Templates] Failed to load template:', err);
          alert('Failed to load template.');
        }
      }
    }

    // Close template modal
    function closeTemplateModal() {
      document.getElementById('template-modal-overlay').style.display = 'none';
    }

    // Edit template
    function editTemplate(templateId) {
      openTemplateModal(templateId);
    }

    // Render a template item row
    function renderTemplateItemRow(item = {}, index = 0) {
      const docTypeOptions = documentTypesCache.map(dt =>
        `<option value="${dt.code}" ${item.doc_type_code === dt.code ? 'selected' : ''}>${dt.label}</option>`
      ).join('');

      const categoryOptions = `
        <option value="dd_corporate" ${item.category_slug === 'dd_corporate' ? 'selected' : ''}>Corporate</option>
        <option value="dd_compliance" ${item.category_slug === 'dd_compliance' ? 'selected' : ''}>Compliance</option>
        <option value="dd_contracts" ${item.category_slug === 'dd_contracts' ? 'selected' : ''}>Contracts</option>
        <option value="financial" ${item.category_slug === 'financial' ? 'selected' : ''}>Financial</option>
        <option value="other" ${item.category_slug === 'other' ? 'selected' : ''}>Other</option>
      `;

      return `
        <div class="template-item-row" data-index="${index}">
          <input type="text" placeholder="Item name (e.g., Medical License)" value="${escapeHtml(item.item_name || '')}" class="item-name">
          <select class="item-category">${categoryOptions}</select>
          <label class="required-toggle">
            <input type="checkbox" ${item.required !== false ? 'checked' : ''}> Req
          </label>
          <button class="btn-remove-item" onclick="removeTemplateItem(this)">&times;</button>
        </div>
      `;
    }

    // Add a new template item row
    function addTemplateItem() {
      const list = document.getElementById('template-items-list');
      const emptyMsg = list.querySelector('.template-items-empty');
      if (emptyMsg) emptyMsg.remove();

      const index = list.querySelectorAll('.template-item-row').length;
      list.insertAdjacentHTML('beforeend', renderTemplateItemRow({}, index));
    }

    // Remove a template item row
    function removeTemplateItem(btn) {
      btn.closest('.template-item-row').remove();
      const list = document.getElementById('template-items-list');
      if (list.querySelectorAll('.template-item-row').length === 0) {
        list.innerHTML = '<div class="template-items-empty">No items yet. Click "+ Add Item" to add documents.</div>';
      }
    }

    // Save template
    async function saveTemplate() {
      const templateId = document.getElementById('template-edit-id').value;
      const name = document.getElementById('template-name').value.trim();
      const description = document.getElementById('template-description').value.trim();
      const category = document.getElementById('template-category').value;

      if (!name) {
        alert('Please enter a template name.');
        return;
      }

      // Collect items
      const items = [];
      document.querySelectorAll('#template-items-list .template-item-row').forEach(row => {
        const itemName = row.querySelector('.item-name').value.trim();
        const categorySlug = row.querySelector('.item-category').value;
        const required = row.querySelector('.required-toggle input').checked;

        if (itemName) {
          items.push({
            item_key: itemName.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
            item_name: itemName,
            category_slug: categorySlug,
            required: required,
            doc_type_code: null
          });
        }
      });

      try {
        if (templateId) {
          // Update existing
          const { error } = await window.sb
            .from('document_templates')
            .update({
              name,
              description,
              category,
              items,
              updated_at: new Date().toISOString()
            })
            .eq('id', templateId);

          if (error) throw error;
        } else {
          // Create new
          const newId = 'tmpl_' + Math.random().toString(36).substring(2, 10);
          const { error } = await window.sb
            .from('document_templates')
            .insert({
              id: newId,
              org_id: window.currentOrgId,
              name,
              description,
              category,
              items,
              created_by: window.currentUser?.email,
              is_active: true
            });

          if (error) throw error;
        }

        closeTemplateModal();
        loadTemplates();
      } catch (err) {
        console.error('[Templates] Save error:', err);
        alert('Failed to save template: ' + err.message);
      }
    }

    // Delete template
    async function deleteTemplate(templateId) {
      if (!confirm('Are you sure you want to delete this template?')) return;

      try {
        const { error } = await window.sb
          .from('document_templates')
          .delete()
          .eq('id', templateId);

        if (error) throw error;

        loadTemplates();
      } catch (err) {
        console.error('[Templates] Delete error:', err);
        alert('Failed to delete template: ' + err.message);
      }
    }

    // Populate practice filter dropdown
    async function populateAuditPracticeFilter() {
      const select = document.getElementById('audit-filter-practice');
      if (!select) return;

      // Keep the "All Practices" option
      select.innerHTML = '<option value="">All Practices</option>';

      // Add practices from the db
      if (db.practices && db.practices.length > 0) {
        db.practices.forEach(p => {
          const opt = document.createElement('option');
          opt.value = p.id;
          opt.textContent = p.name;
          select.appendChild(opt);
        });
      }
    }

    // Load audit log with filters
    async function loadAuditLog() {
      const tbody = document.getElementById('audit-tbody');
      if (!tbody) return;

      tbody.innerHTML = '<tr><td colspan="5" class="audit-empty">Loading events...</td></tr>';

      try {
        // Get filter values
        const typeFilter = document.getElementById('audit-filter-type')?.value || '';
        const practiceFilter = document.getElementById('audit-filter-practice')?.value || '';
        const fromDate = document.getElementById('audit-filter-from')?.value || '';
        const toDate = document.getElementById('audit-filter-to')?.value || '';
        const searchTerm = document.getElementById('audit-search')?.value?.toLowerCase() || '';

        // Fetch from both events and document_events tables
        const [eventsResult, docEventsResult] = await Promise.all([
          fetchPracticeEvents(typeFilter, practiceFilter, fromDate, toDate),
          fetchDocumentEvents(typeFilter, practiceFilter, fromDate, toDate)
        ]);

        // Combine and sort by timestamp (newest first)
        let allEvents = [...(eventsResult || []), ...(docEventsResult || [])];
        allEvents.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        // Apply search filter
        if (searchTerm) {
          allEvents = allEvents.filter(evt => {
            const searchable = [
              evt.event_type,
              evt.practice_name,
              evt.actor_email,
              JSON.stringify(evt.payload)
            ].join(' ').toLowerCase();
            return searchable.includes(searchTerm);
          });
        }

        auditLogData = allEvents;
        auditTotalCount = allEvents.length;
        auditCurrentPage = 1;

        renderAuditLog();
      } catch (err) {
        console.error('Error loading audit log:', err);
        tbody.innerHTML = '<tr><td colspan="5" class="audit-empty">Error loading events</td></tr>';
      }
    }

    // Fetch practice events
    async function fetchPracticeEvents(typeFilter, practiceFilter, fromDate, toDate) {
      try {
        let query = window.sb
          .from('events')
          .select('id, practice_id, event_type, actor_id, timestamp, payload')
          .order('timestamp', { ascending: false })
          .limit(500);

        // Apply filters
        if (typeFilter && ['practice_created', 'practice_edited', 'practice_deleted', 'status_changed',
            'note_added', 'tag_added', 'tag_removed', 'packet_generated', 'metric_added', 'owner_added'].includes(typeFilter)) {
          query = query.eq('event_type', typeFilter);
        }
        if (practiceFilter) {
          query = query.eq('practice_id', practiceFilter);
        }
        if (fromDate) {
          query = query.gte('timestamp', fromDate);
        }
        if (toDate) {
          query = query.lte('timestamp', toDate + 'T23:59:59');
        }

        const { data, error } = await query;
        if (error) throw error;

        // Enrich with practice names
        return (data || []).map(evt => {
          const practice = db.practices.find(p => p.id === evt.practice_id);
          return {
            ...evt,
            source: 'events',
            practice_name: practice?.name || 'Unknown',
            actor_email: evt.actor_id || 'System',
            timestamp: evt.timestamp
          };
        });
      } catch (err) {
        console.error('Error fetching practice events:', err);
        return [];
      }
    }

    // Fetch document events
    async function fetchDocumentEvents(typeFilter, practiceFilter, fromDate, toDate) {
      try {
        let query = window.sb
          .from('document_events')
          .select('id, practice_id, document_id, document_type, event_type, actor_email, payload, created_at')
          .order('created_at', { ascending: false })
          .limit(500);

        // Apply filters
        if (typeFilter && ['uploaded', 'deleted', 'extraction_confirmed', 'verified', 'unverified'].includes(typeFilter)) {
          query = query.eq('event_type', typeFilter);
        }
        if (practiceFilter) {
          query = query.eq('practice_id', practiceFilter);
        }
        if (fromDate) {
          query = query.gte('created_at', fromDate);
        }
        if (toDate) {
          query = query.lte('created_at', toDate + 'T23:59:59');
        }

        const { data, error } = await query;
        if (error) throw error;

        // Enrich with practice names
        return (data || []).map(evt => {
          const practice = db.practices.find(p => p.id === evt.practice_id);
          return {
            ...evt,
            source: 'document_events',
            practice_name: practice?.name || 'Unknown',
            actor_email: evt.actor_email || 'System',
            timestamp: evt.created_at
          };
        });
      } catch (err) {
        console.error('Error fetching document events:', err);
        return [];
      }
    }

    // Render audit log table
    function renderAuditLog() {
      const tbody = document.getElementById('audit-tbody');
      if (!tbody) return;

      const startIdx = (auditCurrentPage - 1) * auditPageSize;
      const endIdx = startIdx + auditPageSize;
      const pageData = auditLogData.slice(startIdx, endIdx);

      if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="audit-empty">No events found</td></tr>';
        updateAuditPagination();
        return;
      }

      tbody.innerHTML = pageData.map(evt => {
        const timestamp = formatAuditTimestamp(evt.timestamp);
        const eventBadge = formatEventBadge(evt.event_type, evt.source);
        const details = formatEventDetails(evt);

        return `
          <tr>
            <td class="audit-timestamp">${timestamp}</td>
            <td class="audit-practice">${escapeHtml(evt.practice_name)}</td>
            <td>${eventBadge}</td>
            <td class="audit-actor" title="${escapeHtml(evt.actor_email)}">${escapeHtml(evt.actor_email)}</td>
            <td class="audit-details" title="${escapeHtml(details)}">${escapeHtml(details)}</td>
          </tr>
        `;
      }).join('');

      updateAuditPagination();
    }

    // Format timestamp for display
    function formatAuditTimestamp(ts) {
      if (!ts) return '--';
      const date = new Date(ts);
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    }

    // Format event badge with icon
    function formatEventBadge(eventType, source) {
      const icons = {
        practice_created: '&#43;',
        practice_edited: '&#9998;',
        practice_deleted: '&#128465;',
        status_changed: '&#8634;',
        note_added: '&#128221;',
        tag_added: '&#127991;',
        tag_removed: '&#127991;',
        packet_generated: '&#128196;',
        metric_added: '&#128200;',
        owner_added: '&#128100;',
        uploaded: '&#128194;',
        deleted: '&#128465;',
        extraction_confirmed: '&#10003;',
        verified: '&#10003;',
        unverified: '&#10007;'
      };

      const labels = {
        practice_created: 'Created',
        practice_edited: 'Edited',
        practice_deleted: 'Deleted',
        status_changed: 'Status',
        note_added: 'Note',
        tag_added: 'Tag +',
        tag_removed: 'Tag -',
        packet_generated: 'Packet',
        metric_added: 'Metric',
        owner_added: 'Owner',
        uploaded: 'Uploaded',
        deleted: 'Deleted',
        extraction_confirmed: 'Extracted',
        verified: 'Verified',
        unverified: 'Unverified'
      };

      let badgeClass = 'practice';
      if (source === 'document_events') badgeClass = 'document';
      if (eventType === 'extraction_confirmed') badgeClass = 'extraction';
      if (eventType.includes('deleted')) badgeClass = 'delete';

      const icon = icons[eventType] || '&#9679;';
      const label = labels[eventType] || eventType.replace(/_/g, ' ');

      return `<span class="audit-event-badge ${badgeClass}">${icon} ${label}</span>`;
    }

    // Format event details
    function formatEventDetails(evt) {
      if (!evt.payload) return '--';

      try {
        const p = typeof evt.payload === 'string' ? JSON.parse(evt.payload) : evt.payload;

        // Status change
        if (evt.event_type === 'status_changed' && p.old && p.new) {
          return `${p.old}  ${p.new}`;
        }

        // Document upload
        if (evt.event_type === 'uploaded' && p.file_name) {
          return p.file_name;
        }

        // Extraction
        if (evt.event_type === 'extraction_confirmed') {
          if (p.deposits) return `$${Number(p.deposits).toLocaleString()} (${p.period || 'N/A'})`;
          return p.period || 'Extracted';
        }

        // Tag
        if ((evt.event_type === 'tag_added' || evt.event_type === 'tag_removed') && p.tag) {
          return p.tag;
        }

        // Note
        if (evt.event_type === 'note_added' && p.content_preview) {
          return p.content_preview;
        }

        // Generic - show first key/value
        const keys = Object.keys(p);
        if (keys.length > 0) {
          const val = p[keys[0]];
          if (typeof val === 'string' || typeof val === 'number') {
            return `${keys[0]}: ${val}`.substring(0, 50);
          }
        }

        return '--';
      } catch {
        return '--';
      }
    }

    // Update pagination controls
    function updateAuditPagination() {
      const totalPages = Math.ceil(auditTotalCount / auditPageSize) || 1;
      const pageInfo = document.getElementById('audit-page-info');
      const prevBtn = document.getElementById('audit-prev-btn');
      const nextBtn = document.getElementById('audit-next-btn');

      if (pageInfo) {
        pageInfo.textContent = `Page ${auditCurrentPage} of ${totalPages} (${auditTotalCount} events)`;
      }
      if (prevBtn) {
        prevBtn.disabled = auditCurrentPage <= 1;
      }
      if (nextBtn) {
        nextBtn.disabled = auditCurrentPage >= totalPages;
      }
    }

    // Change page
    function changeAuditPage(direction) {
      const totalPages = Math.ceil(auditTotalCount / auditPageSize) || 1;
      const newPage = auditCurrentPage + direction;

      if (newPage >= 1 && newPage <= totalPages) {
        auditCurrentPage = newPage;
        renderAuditLog();
      }
    }

    // Apply filters with debounce for search
    function applyAuditFilters() {
      loadAuditLog();
    }

    function debounceAuditSearch() {
      clearTimeout(auditSearchTimeout);
      auditSearchTimeout = setTimeout(() => {
        loadAuditLog();
      }, 300);
    }

    // Export audit log to CSV
    function exportAuditLog() {
      if (auditLogData.length === 0) {
        alert('No events to export');
        return;
      }

      const headers = ['Timestamp', 'Practice', 'Event Type', 'Actor', 'Details'];
      const rows = auditLogData.map(evt => [
        evt.timestamp,
        evt.practice_name,
        evt.event_type,
        evt.actor_email,
        formatEventDetails(evt)
      ]);

      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
      ].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `audit-log-${new Date().toISOString().split('T')[0]}.csv`;
      link.click();
    }

    // Helper to escape HTML
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // =============================================
    // END SETTINGS & AUDIT LOG FUNCTIONS
    // =============================================

    async function handleLogout() {
      try {
        await window.sb.auth.signOut();
        // Clear in-memory database
        db = {
          practices: [],
          people: [],
          practice_people: [],
          locations: [],
          notes: [],
          events: [],
          metrics: [],
          tasks: []
        };
        // Clear auth and org globals
        window.currentUser = null;
        window.currentUserRole = null;
        window.currentOrgId = null;
        window.currentOrgSlug = null;
        window.currentUserOrgRole = null;
        hideApp();
        hideAwaitingApproval();
        hideNoOrgScreen();
        console.log('Logged out successfully');
      } catch (error) {
        console.error('Logout error:', error);
      }
    }

    // =============================================
    // ALLOWLIST CHECK
    // =============================================
    window.currentUserRole = null;

    function showAwaitingApproval(email) {
      document.getElementById('auth-loading-screen').style.display = 'none';
      document.getElementById('login-screen').style.display = 'none';
      document.getElementById('app-container').classList.remove('authenticated');
      document.getElementById('awaiting-approval-screen').classList.add('visible');
      document.getElementById('approval-user-email').textContent = email;
    }

    function hideAwaitingApproval() {
      document.getElementById('awaiting-approval-screen').classList.remove('visible');
    }

    async function checkAllowlistOrBlock(user) {
      console.log('[Allowlist] checking user email:', user.email);

      try {
        // Add timeout to prevent hanging queries
        const timeoutPromise = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Allowlist query timeout')), 10000)
        );

        console.log('[Allowlist] Starting query...');
        const queryPromise = window.sb
          .from('allowed_users')
          .select('email, role, is_active')
          .ilike('email', user.email)
          .limit(1);

        const { data, error } = await Promise.race([queryPromise, timeoutPromise]);
        console.log('[Allowlist] Query completed:', { data, error });

        if (error) {
          console.error('[Allowlist] query error:', error);
          showAwaitingApproval(user.email);
          await createAccessRequestIfNeeded(user.email);
          return { allowed: false, role: null };
        }

        if (!data || data.length === 0 || !data[0].is_active) {
          console.log('[Allowlist] blocked - awaiting approval');
          showAwaitingApproval(user.email);
          await createAccessRequestIfNeeded(user.email);
          return { allowed: false, role: null };
        }

        const role = data[0].role || 'user';
        console.log('[Allowlist] allowed as role=' + role);
        window.currentUserRole = role;
        return { allowed: true, role: role };
      } catch (err) {
        console.error('[Allowlist] unexpected error:', err);
        showAwaitingApproval(user.email);
        await createAccessRequestIfNeeded(user.email);
        return { allowed: false, role: null };
      }
    }

    // =============================================
    // ACCESS REQUESTS
    // =============================================
    async function createAccessRequestIfNeeded(email) {
      const normalizedEmail = email.toLowerCase();

      try {
        // Check if request already exists
        const { data: existing, error: selectError } = await window.sb
          .from('access_requests')
          .select('id, status')
          .eq('email', normalizedEmail)
          .limit(1);

        if (selectError) {
          console.error('[AccessRequests] query error:', selectError);
          return;
        }

        if (existing && existing.length > 0) {
          const status = existing[0].status;
          if (status === 'pending') {
            console.log('[AccessRequests] pending request already exists');
            return;
          } else if (status === 'denied') {
            console.log('[AccessRequests] request was denied, keeping denied');
            return;
          } else if (status === 'approved') {
            console.log('[AccessRequests] MISMATCH: request approved but not in allowlist');
            return;
          }
        }

        // Create new pending request
        const { error: insertError } = await window.sb
          .from('access_requests')
          .insert({
            email: normalizedEmail,
            status: 'pending',
            created_at: new Date().toISOString()
          });

        if (insertError) {
          console.error('[AccessRequests] insert error:', insertError);
          return;
        }

        console.log('[AccessRequests] created pending request for', normalizedEmail);
      } catch (err) {
        console.error('[AccessRequests] unexpected error:', err);
      }
    }

    // =============================================
    // ADMIN PANEL FUNCTIONS
    // =============================================
    async function loadAllowlist() {
      if (window.currentUserRole !== 'admin') return;

      const { data, error } = await window.sb
        .from('allowed_users')
        .select('*')
        .order('email');

      if (error) {
        console.error('[Admin] failed to load allowlist:', error);
        return;
      }

      const tbody = document.getElementById('allowlist-tbody');
      tbody.innerHTML = (data || []).map(user => `
        <tr>
          <td>${escapeHtml(user.email)}</td>
          <td>${user.role}</td>
          <td>${user.is_active ? 'Active' : 'Inactive'}</td>
          <td>
            <button class="btn-toggle ${user.is_active ? 'active' : ''}" onclick="toggleAllowlistUser('${user.email}', ${!user.is_active})">
              ${user.is_active ? 'Deactivate' : 'Activate'}
            </button>
            <button class="btn-delete" onclick="deleteFromAllowlist('${user.email}')">Delete</button>
          </td>
        </tr>
      `).join('');
    }

    async function addToAllowlist() {
      const emailInput = document.getElementById('allowlist-email');
      const roleSelect = document.getElementById('allowlist-role');
      const email = emailInput.value.trim().toLowerCase();
      const role = roleSelect.value;

      if (!email) return;

      const { error } = await window.sb
        .from('allowed_users')
        .upsert({ email: email, role: role, is_active: true }, { onConflict: 'email' });

      if (error) {
        console.error('[Admin] failed to add user:', error);
        alert('Failed to add user: ' + error.message);
        return;
      }

      console.log('[Admin] added user:', email, 'as', role);
      emailInput.value = '';
      await loadAllowlist();
    }

    async function toggleAllowlistUser(email, newActiveState) {
      const { error } = await window.sb
        .from('allowed_users')
        .update({ is_active: newActiveState })
        .eq('email', email);

      if (error) {
        console.error('[Admin] failed to toggle user:', error);
        return;
      }

      console.log('[Admin] toggled user:', email, 'is_active=', newActiveState);
      await loadAllowlist();
    }

    async function deleteFromAllowlist(email) {
      if (!confirm(`Remove ${email} from allowlist?`)) return;

      const { error } = await window.sb
        .from('allowed_users')
        .delete()
        .eq('email', email);

      if (error) {
        console.error('[Admin] failed to delete user:', error);
        return;
      }

      console.log('[Admin] deleted user:', email);
      await loadAllowlist();
    }

    // =============================================
    // PENDING ACCESS REQUESTS FUNCTIONS
    // =============================================
    async function loadPendingRequests() {
      if (window.currentUserRole !== 'admin') return;

      const { data, error } = await window.sb
        .from('access_requests')
        .select('*')
        .eq('status', 'pending')
        .order('created_at', { ascending: false });

      if (error) {
        console.error('[Admin] failed to load pending requests:', error);
        return;
      }

      const tbody = document.getElementById('pending-requests-tbody');
      const noRequestsDiv = document.getElementById('no-pending-requests');
      const table = document.getElementById('pending-requests-table');

      if (!data || data.length === 0) {
        tbody.innerHTML = '';
        table.style.display = 'none';
        noRequestsDiv.style.display = 'block';
        return;
      }

      table.style.display = 'table';
      noRequestsDiv.style.display = 'none';

      tbody.innerHTML = data.map(req => `
        <tr>
          <td>${escapeHtml(req.email)}</td>
          <td>${formatDateShort(req.created_at)}</td>
          <td>
            <select id="role-select-${req.id}" style="padding: 4px; border-radius: 4px; border: 1px solid #ddd;">
              <option value="viewer">Viewer</option>
              <option value="editor" selected>Editor</option>
              <option value="admin">Admin</option>
            </select>
          </td>
          <td>
            <button class="btn-toggle active" onclick="approveAccessRequest('${req.id}', '${req.email}')">Approve</button>
            <button class="btn-delete" onclick="denyAccessRequest('${req.id}', '${req.email}')">Deny</button>
          </td>
        </tr>
      `).join('');
    }

    async function approveAccessRequest(requestId, email) {
      const normalizedEmail = email.toLowerCase();
      const now = new Date().toISOString();
      const decidedBy = currentUser?.id || 'admin';

      // Get selected role from dropdown
      const roleSelect = document.getElementById(`role-select-${requestId}`);
      const selectedOrgRole = roleSelect ? roleSelect.value : 'editor';

      try {
        // 1. Upsert into allowed_users
        const { error: upsertError } = await window.sb
          .from('allowed_users')
          .upsert({ email: normalizedEmail, role: 'user', is_active: true }, { onConflict: 'email' });

        if (upsertError) {
          console.error('[Admin] failed to add to allowlist:', upsertError);
          alert('Failed to approve: ' + upsertError.message);
          return;
        }

        // 2. Update access_requests to approved
        const { error: updateError } = await window.sb
          .from('access_requests')
          .update({
            status: 'approved',
            decided_at: now,
            decided_by: decidedBy
          })
          .eq('id', requestId);

        if (updateError) {
          console.error('[Admin] failed to update request:', updateError);
          return;
        }

        // 3. Try to add user to org_members with selected role
        // First, look up the user's auth ID by email
        const { data: userData, error: userLookupError } = await window.sb
          .rpc('get_user_id_by_email', { user_email: normalizedEmail });

        if (!userLookupError && userData) {
          // User exists in auth - add to org_members
          const { error: orgMemberError } = await window.sb
            .from('org_members')
            .upsert({
              user_id: userData,
              org_id: window.currentOrgId,
              role: selectedOrgRole,
              created_at: now
            }, { onConflict: 'user_id,org_id' });

          if (orgMemberError) {
            console.error('[Admin] failed to add to org_members:', orgMemberError);
            // Don't fail the whole operation - user is still approved
          } else {
            console.log('[Admin] added to org_members with role:', selectedOrgRole);
          }
        } else {
          console.log('[Admin] user not yet in auth.users, will be added to org on first login');
        }

        console.log('[Admin] approved request for:', normalizedEmail, 'with role:', selectedOrgRole);

        // Refresh lists
        await loadPendingRequests();
        await loadAllowlist();
        await loadTeamMembers();
      } catch (err) {
        console.error('[Admin] approve error:', err);
      }
    }

    async function denyAccessRequest(requestId, email) {
      if (!confirm(`Deny access request from ${email}?`)) return;

      const now = new Date().toISOString();
      const decidedBy = currentUser?.id || 'admin';

      try {
        const { error } = await window.sb
          .from('access_requests')
          .update({
            status: 'denied',
            decided_at: now,
            decided_by: decidedBy
          })
          .eq('id', requestId);

        if (error) {
          console.error('[Admin] failed to deny request:', error);
          return;
        }

        console.log('[Admin] denied request for:', email);
        await loadPendingRequests();
      } catch (err) {
        console.error('[Admin] deny error:', err);
      }
    }

    // =============================================
    // TEAM MEMBERS MANAGEMENT
    // =============================================

    async function loadTeamMembers() {
      if (!hasPermission('VIEW_ADMIN_PANEL')) return;

      try {
        // Query org_members joined with auth.users email
        const { data, error } = await window.sb
          .from('org_members')
          .select('user_id, role, created_at')
          .eq('org_id', window.currentOrgId);

        if (error) {
          console.error('[Admin] failed to load team members:', error);
          return;
        }

        // Get emails for each user
        const membersWithEmail = [];
        for (const member of data || []) {
          const { data: emailData } = await window.sb
            .rpc('get_user_email_by_id', { user_id: member.user_id });

          membersWithEmail.push({
            ...member,
            email: emailData || 'Unknown'
          });
        }

        renderTeamMembers(membersWithEmail);
      } catch (err) {
        console.error('[Admin] team members error:', err);
      }
    }

    function renderTeamMembers(members) {
      const tbody = document.getElementById('team-members-tbody');
      const noMembersDiv = document.getElementById('no-team-members');
      const table = document.getElementById('team-members-table');

      if (!members || members.length === 0) {
        tbody.innerHTML = '';
        table.style.display = 'none';
        noMembersDiv.style.display = 'block';
        return;
      }

      table.style.display = 'table';
      noMembersDiv.style.display = 'none';

      const currentUserId = window.currentUser?.id;

      tbody.innerHTML = members.map(member => {
        const isCurrentUser = member.user_id === currentUserId;
        const roleOptions = ['viewer', 'editor', 'admin'].map(r =>
          `<option value="${r}" ${member.role === r ? 'selected' : ''}>${r.charAt(0).toUpperCase() + r.slice(1)}</option>`
        ).join('');

        return `
          <tr>
            <td>${escapeHtml(member.email)}${isCurrentUser ? ' <span style="color:#888">(you)</span>' : ''}</td>
            <td>
              <select
                onchange="updateMemberRole('${member.user_id}', this.value)"
                style="padding: 4px; border-radius: 4px; border: 1px solid #ddd;"
                ${isCurrentUser ? 'disabled title="Cannot change your own role"' : ''}
              >
                ${roleOptions}
              </select>
            </td>
            <td>${formatDateShort(member.created_at)}</td>
            <td>
              ${!isCurrentUser ? `<button class="btn-delete" onclick="removeMember('${member.user_id}', '${member.email}')">Remove</button>` : ''}
            </td>
          </tr>
        `;
      }).join('');
    }

    async function updateMemberRole(userId, newRole) {
      if (!hasPermission('MANAGE_USERS')) {
        showPermissionDenied('manage team members');
        return;
      }

      // Prevent changing own role
      if (userId === window.currentUser?.id) {
        alert('You cannot change your own role.');
        await loadTeamMembers(); // Reset dropdown
        return;
      }

      try {
        const { error } = await window.sb
          .from('org_members')
          .update({ role: newRole })
          .eq('user_id', userId)
          .eq('org_id', window.currentOrgId);

        if (error) {
          console.error('[Admin] failed to update role:', error);
          alert('Failed to update role: ' + error.message);
          await loadTeamMembers(); // Reset dropdown
          return;
        }

        console.log('[Admin] updated role for user:', userId, 'to:', newRole);
      } catch (err) {
        console.error('[Admin] update role error:', err);
        await loadTeamMembers();
      }
    }

    async function removeMember(userId, email) {
      if (!hasPermission('MANAGE_USERS')) {
        showPermissionDenied('manage team members');
        return;
      }

      if (userId === window.currentUser?.id) {
        alert('You cannot remove yourself from the team.');
        return;
      }

      if (!confirm(`Remove ${email} from the team? They will lose access to this organization.`)) {
        return;
      }

      try {
        const { error } = await window.sb
          .from('org_members')
          .delete()
          .eq('user_id', userId)
          .eq('org_id', window.currentOrgId);

        if (error) {
          console.error('[Admin] failed to remove member:', error);
          alert('Failed to remove member: ' + error.message);
          return;
        }

        console.log('[Admin] removed member:', email);
        await loadTeamMembers();
      } catch (err) {
        console.error('[Admin] remove member error:', err);
      }
    }

    // =============================================
    // FINANCIAL DOCUMENTS MANAGEMENT
    // =============================================

    // Compute SHA-256 hash of file for dedup detection
    async function computeFileHash(file) {
      const buffer = await file.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Handle financial document upload
    async function handleFinancialDocUpload(event) {
      const files = event.target.files;
      if (!files || files.length === 0) return;

      const practiceId = selectedPracticeId;
      if (!practiceId) {
        alert('Please select a practice first.');
        return;
      }

      const docType = document.getElementById('fin-doc-type')?.value || 'bank_statement';

      for (const file of files) {
        try {
          console.log('[FinDocs] Uploading:', file.name);

          // Compute file hash for dedup
          const fileHash = await computeFileHash(file);
          console.log('[FinDocs] File hash:', fileHash);

          // Check for duplicate
          const { data: existing } = await window.sb
            .from('financial_documents')
            .select('id, file_name')
            .eq('practice_id', practiceId)
            .eq('file_hash', fileHash)
            .eq('is_deleted', false)
            .limit(1);

          if (existing && existing.length > 0) {
            alert(`This file has already been uploaded as "${existing[0].file_name}"`);
            continue;
          }

          // Build storage path: {org_id}/{practice_id}/{date}/{hash}_{filename}
          const today = new Date().toISOString().split('T')[0];
          const safeName = file.name.replace(/[^a-z0-9._-]/gi, '_');
          const storagePath = `${window.currentOrgId}/${practiceId}/${today}/${fileHash.substring(0, 8)}_${safeName}`;

          // Upload to Supabase Storage
          const { data: uploadData, error: uploadError } = await window.sb.storage
            .from('financial-documents')
            .upload(storagePath, file, {
              contentType: file.type,
              upsert: false
            });

          if (uploadError) {
            console.error('[FinDocs] Upload error:', uploadError);
            alert('Failed to upload file: ' + uploadError.message);
            continue;
          }

          console.log('[FinDocs] Uploaded to storage:', storagePath);

          // Create financial_documents record
          const docId = generateFinancialDocumentId();
          const docRecord = {
            id: docId,
            org_id: window.currentOrgId,
            practice_id: practiceId,
            file_name: file.name,
            file_type: file.type,
            file_size_bytes: file.size,
            file_hash: fileHash,
            storage_bucket: 'financial-documents',
            storage_path: storagePath,
            document_type: docType,
            processing_status: 'uploaded',
            uploaded_by_id: window.currentUser.id,
            uploaded_at: new Date().toISOString()
          };

          const { error: insertError } = await window.sb
            .from('financial_documents')
            .insert(docRecord);

          if (insertError) {
            console.error('[FinDocs] Insert error:', insertError);
            alert('Failed to save document record: ' + insertError.message);
            continue;
          }

          console.log('[FinDocs] Created document record:', docId);

          // Log upload event
          await window.sb.from('document_events').insert({
            org_id: window.currentOrgId,
            practice_id: practiceId,
            document_type: 'financial',
            document_id: docId,
            event_type: 'uploaded',
            actor_user_id: window.currentUser.id,
            actor_email: window.currentUser.email,
            payload: { file_name: file.name, document_type: docType, file_size: file.size }
          });

        } catch (err) {
          console.error('[FinDocs] Upload error:', err);
          alert('Failed to upload: ' + err.message);
        }
      }

      // Clear file input and refresh list
      event.target.value = '';
      await loadFinancialDocuments(practiceId);
    }

    // Load financial documents for a practice
    async function loadFinancialDocuments(practiceId) {
      if (!practiceId) return;

      try {
        const { data: docs, error } = await window.sb
          .from('financial_documents')
          .select('*')
          .eq('practice_id', practiceId)
          .eq('is_deleted', false)
          .order('uploaded_at', { ascending: false });

        if (error) {
          console.error('[FinDocs] Load error:', error);
          return;
        }

        renderFinancialDocuments(docs || []);
        await loadFinancialProfile(practiceId);
        await fetchMonthlyBreakdown(practiceId);

      } catch (err) {
        console.error('[FinDocs] Load error:', err);
      }
    }

    // Render financial documents list
    function renderFinancialDocuments(docs) {
      const container = document.getElementById('fin-documents-list');
      if (!container) return;

      if (!docs || docs.length === 0) {
        container.innerHTML = '<div class="fin-docs-empty">No financial documents uploaded yet.</div>';
        return;
      }

      const statusLabels = {
        'uploaded': 'Uploaded',
        'queued': 'Queued',
        'processing': 'Processing',
        'completed': 'Extracted',
        'failed': 'Failed',
        'needs_review': 'Needs Review'
      };

      container.innerHTML = docs.map(doc => {
        const icon = doc.file_type?.includes('pdf') ? '' :
                     doc.file_type?.includes('image') ? '' :
                     doc.file_type?.includes('sheet') || doc.file_type?.includes('excel') ? '' : '';
        const typeLabel = getDocTypeLabel(doc.document_type);
        const statusLabel = statusLabels[doc.processing_status] || doc.processing_status;
        const statusClass = doc.processing_status || 'uploaded';
        const uploadDate = new Date(doc.uploaded_at).toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: '2-digit' });
        const fileSize = formatFileSize(doc.file_size_bytes);

        // Format statement period if available (e.g., "Sep 2024")
        let periodDisplay = '';
        if (doc.period_start) {
          const periodDate = new Date(doc.period_start);
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          periodDisplay = `  ${monthNames[periodDate.getMonth()]} ${periodDate.getFullYear()}`;
        }

        return `
          <div class="fin-doc-item" data-doc-id="${doc.id}">
            <div class="fin-doc-icon">${icon}</div>
            <div class="fin-doc-info">
              <div class="fin-doc-name">${escapeHtml(doc.file_name)}</div>
              <div class="fin-doc-meta">${typeLabel}  ${fileSize}${periodDisplay}</div>
            </div>
            <span class="fin-doc-status ${statusClass}">
              <span class="fin-doc-status-label">${statusLabel}</span>
              <span class="fin-doc-status-date">${uploadDate}</span>
            </span>
            <div class="fin-doc-actions">
              <button onclick="viewFinancialDocument('${doc.id}')">View</button>
              <button onclick="extractFinancialDocument('${doc.id}')" ${doc.processing_status === 'processing' ? 'disabled' : ''} class="extract-btn">${doc.processing_status === 'processing' ? 'Extracting...' : 'Extract'}</button>
              <button onclick="deleteFinancialDocument('${doc.id}')">Delete</button>
            </div>
          </div>
        `;
      }).join('');
    }

    // Format file size
    function formatFileSize(bytes) {
      if (!bytes) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB'];
      let i = 0;
      while (bytes >= 1024 && i < units.length - 1) {
        bytes /= 1024;
        i++;
      }
      return bytes.toFixed(i > 0 ? 1 : 0) + ' ' + units[i];
    }

    // View financial document (open signed URL)
    async function viewFinancialDocument(docId) {
      try {
        const { data: doc } = await window.sb
          .from('financial_documents')
          .select('storage_path')
          .eq('id', docId)
          .single();

        if (!doc) {
          alert('Document not found');
          return;
        }

        const { data: signedUrl, error } = await window.sb.storage
          .from('financial-documents')
          .createSignedUrl(doc.storage_path, 3600);

        if (error) {
          alert('Failed to get document URL: ' + error.message);
          return;
        }

        window.open(signedUrl.signedUrl, '_blank');
      } catch (err) {
        console.error('[FinDocs] View error:', err);
        alert('Failed to open document');
      }
    }

    // Delete financial document
    async function deleteFinancialDocument(docId) {
      if (!confirm('Delete this financial document? This cannot be undone.')) return;

      try {
        // Soft delete
        const { error } = await window.sb
          .from('financial_documents')
          .update({
            is_deleted: true,
            deleted_at: new Date().toISOString(),
            deleted_by_id: window.currentUser.id
          })
          .eq('id', docId);

        if (error) {
          alert('Failed to delete: ' + error.message);
          return;
        }

        // Refresh list
        await loadFinancialDocuments(selectedPracticeId);
      } catch (err) {
        console.error('[FinDocs] Delete error:', err);
        alert('Failed to delete document');
      }
    }

    // =============================================
    // CANONICALIZATION - Transform extraction data into financial_facts
    // =============================================

    /**
     * Creates financial_facts rows from extraction data
     * @param {Object} params - Canonicalization parameters
     * @param {string} params.docId - financial_documents.id
     * @param {string} params.extractionId - financial_extractions.id
     * @param {string} params.practiceId - practice ID
     * @param {string} params.orgId - organization ID
     * @param {string} params.periodStart - YYYY-MM-DD
     * @param {string} params.periodEnd - YYYY-MM-DD
     * @param {number} params.depositsTotal - Total deposits amount
     * @param {number} params.endingBalance - Ending balance amount
     * @param {number} params.beginningBalance - Beginning balance (optional)
     * @param {number} params.withdrawalsTotal - Total withdrawals (optional)
     * @param {number} params.confidence - Overall confidence 0-1
     * @returns {Object} { success: boolean, factIds: string[], error?: string }
     */
    async function canonicalizeExtraction(params) {
      const {
        docId,
        extractionId,
        practiceId,
        orgId,
        periodStart,
        periodEnd,
        depositsTotal,
        endingBalance,
        beginningBalance,
        withdrawalsTotal,
        confidence
      } = params;

      console.log('[Canonicalize] Starting canonicalization:', params);

      try {
        // First, supersede any existing current facts for this practice/period
        // This handles re-extraction of the same period
        const factsToSupersede = [
          'monthly_revenue_bank_deposits',
          'monthly_ending_balance',
          'monthly_beginning_balance',
          'monthly_withdrawals'
        ];

        for (const factType of factsToSupersede) {
          const { data: existingFacts } = await window.sb
            .from('financial_facts')
            .select('id')
            .eq('practice_id', practiceId)
            .eq('fact_type', factType)
            .eq('period_start', periodStart)
            .eq('period_end', periodEnd)
            .eq('is_current', true);

          if (existingFacts && existingFacts.length > 0) {
            console.log(`[Canonicalize] Superseding ${existingFacts.length} existing ${factType} facts`);
            await window.sb
              .from('financial_facts')
              .update({
                is_current: false,
                superseded_at: new Date().toISOString()
              })
              .in('id', existingFacts.map(f => f.id));
          }
        }

        // Create new facts
        const factsToCreate = [];
        const createdFactIds = [];

        // Fact 1: Monthly Revenue (Bank Deposits)
        if (depositsTotal !== null && depositsTotal !== undefined) {
          factsToCreate.push({
            org_id: orgId,
            practice_id: practiceId,
            financial_document_id: docId,
            financial_extraction_id: extractionId,
            fact_type: 'monthly_revenue_bank_deposits',
            period_start: periodStart,
            period_end: periodEnd,
            value_numeric: depositsTotal,
            confidence: confidence,
            source_path: 'account_summary.deposits_total.value',
            is_current: true
          });
        }

        // Fact 2: Ending Balance
        if (endingBalance !== null && endingBalance !== undefined) {
          factsToCreate.push({
            org_id: orgId,
            practice_id: practiceId,
            financial_document_id: docId,
            financial_extraction_id: extractionId,
            fact_type: 'monthly_ending_balance',
            period_start: periodStart,
            period_end: periodEnd,
            value_numeric: endingBalance,
            confidence: confidence,
            source_path: 'account_summary.ending_balance.value',
            is_current: true
          });
        }

        // Fact 3: Beginning Balance (optional)
        if (beginningBalance !== null && beginningBalance !== undefined) {
          factsToCreate.push({
            org_id: orgId,
            practice_id: practiceId,
            financial_document_id: docId,
            financial_extraction_id: extractionId,
            fact_type: 'monthly_beginning_balance',
            period_start: periodStart,
            period_end: periodEnd,
            value_numeric: beginningBalance,
            confidence: confidence,
            source_path: 'account_summary.beginning_balance.value',
            is_current: true
          });
        }

        // Fact 4: Withdrawals (optional)
        if (withdrawalsTotal !== null && withdrawalsTotal !== undefined) {
          factsToCreate.push({
            org_id: orgId,
            practice_id: practiceId,
            financial_document_id: docId,
            financial_extraction_id: extractionId,
            fact_type: 'monthly_withdrawals',
            period_start: periodStart,
            period_end: periodEnd,
            value_numeric: withdrawalsTotal,
            confidence: confidence,
            source_path: 'account_summary.withdrawals_total.value',
            is_current: true
          });
        }

        // Insert all facts
        if (factsToCreate.length > 0) {
          const { data: insertedFacts, error: insertError } = await window.sb
            .from('financial_facts')
            .insert(factsToCreate)
            .select('id');

          if (insertError) {
            throw new Error('Failed to create facts: ' + insertError.message);
          }

          createdFactIds.push(...insertedFacts.map(f => f.id));
          console.log(`[Canonicalize] Created ${createdFactIds.length} facts:`, createdFactIds);
        }

        return { success: true, factIds: createdFactIds };

      } catch (err) {
        console.error('[Canonicalize] Error:', err);
        return { success: false, factIds: [], error: err.message };
      }
    }

    /**
     * Creates a financial_extractions record
     */
    async function createExtractionRecord(params) {
      const {
        docId,
        practiceId,
        orgId,
        periodStart,
        periodEnd,
        extractionJson,
        confidence,
        modelName = 'manual_entry',
        modelVersion = '1.0'
      } = params;

      const { data, error } = await window.sb
        .from('financial_extractions')
        .insert({
          org_id: orgId,
          practice_id: practiceId,
          financial_document_id: docId,
          status: 'completed',
          extraction_json: extractionJson,
          extracted_at: new Date().toISOString(),
          model_name: modelName,
          model_version: modelVersion,
          extraction_method: 'manual',
          period_start: periodStart,
          period_end: periodEnd,
          period_confidence: confidence
        })
        .select('id')
        .single();

      if (error) {
        throw new Error('Failed to create extraction record: ' + error.message);
      }

      return data.id;
    }

    // Extract financial document using AI Edge Function
    // Store pending extraction for confirmation modal
    let pendingExtraction = null;

    async function extractFinancialDocument(docId) {
      try {
        // Get current session for auth
        const { data: { session }, error: sessionError } = await window.sb.auth.getSession();
        if (sessionError || !session) {
          alert('Please log in to extract documents');
          return;
        }

        // Get document info to pre-populate period if available
        const { data: doc, error: docError } = await window.sb
          .from('financial_documents')
          .select('*')
          .eq('id', docId)
          .single();

        if (docError || !doc) {
          alert('Document not found');
          return;
        }

        // Determine period from document metadata
        let period = null;
        if (doc.period_start) {
          // Use existing period from document
          const date = new Date(doc.period_start);
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          period = `${year}-${month}`;
        } else if (doc.statement_year && doc.statement_month) {
          // Use statement_year/month if available
          period = `${doc.statement_year}-${String(doc.statement_month).padStart(2, '0')}`;
        }

        console.log('[FinDocs] Opening manual entry for document:', docId, 'period:', period);

        // Store pending extraction for manual entry
        // extractionId and factIds will be created on confirm
        pendingExtraction = {
          docId: docId,
          extractionId: null,  // Will be created on confirm
          factIds: [],         // Will be created on confirm
          period: period,
          deposits: null,      // User will enter
          balance: null,       // User will enter
          beginningBalance: null,
          withdrawals: null,
          confidence: 1.0,     // Manual entry = 100% confidence
          isManualEntry: true
        };

        showExtractionModal(pendingExtraction);

      } catch (err) {
        console.error('[FinDocs] Error opening extraction:', err);
        alert('Failed to open extraction: ' + err.message);
      }
    }

    function showExtractionModal(extraction) {
      const modal = document.getElementById('extraction-confirm-modal');
      const isManual = extraction.isManualEntry;

      // Format period for display (e.g., "2025-09" -> "September 2025")
      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                          'July', 'August', 'September', 'October', 'November', 'December'];
      let periodDisplay = extraction.period || 'Select Period';
      if (extraction.period && extraction.period.match(/^\d{4}-\d{2}$/)) {
        const [year, month] = extraction.period.split('-');
        periodDisplay = `${monthNames[parseInt(month) - 1]} ${year}`;
      }

      // Populate modal fields
      document.getElementById('extract-period-display').textContent = periodDisplay;

      // Populate input fields (for manual entry or pre-fill from AI)
      const depositsInput = document.getElementById('extract-deposits-input');
      const balanceInput = document.getElementById('extract-balance-input');
      const beginningBalanceInput = document.getElementById('extract-beginning-balance-input');
      const withdrawalsInput = document.getElementById('extract-withdrawals-input');

      depositsInput.value = extraction.deposits || '';
      balanceInput.value = extraction.balance || '';
      beginningBalanceInput.value = extraction.beginningBalance || '';
      withdrawalsInput.value = extraction.withdrawals || '';

      // For manual entry, show period edit fields by default
      if (isManual && !extraction.period) {
        document.getElementById('period-edit-fields').style.display = 'block';
        document.getElementById('edit-period-btn').textContent = 'Hide';
      }

      // Hide confidence bar for manual entry
      const confidenceRow = document.getElementById('confidence-display-row');
      if (confidenceRow) {
        confidenceRow.style.display = isManual ? 'none' : 'flex';
      }

      // Confidence bar (for AI extractions)
      const confidencePct = extraction.confidence ? Math.round(extraction.confidence * 100) : 0;
      document.getElementById('extract-confidence-bar').style.width = confidencePct + '%';
      document.getElementById('extract-confidence-text').textContent = confidencePct + '%';

      // Populate year dropdown (current year  3 years)
      const yearSelect = document.getElementById('extract-period-year');
      yearSelect.innerHTML = '';
      const currentYear = new Date().getFullYear();
      for (let y = currentYear; y >= currentYear - 5; y--) {
        const opt = document.createElement('option');
        opt.value = y;
        opt.textContent = y;
        yearSelect.appendChild(opt);
      }

      // Determine period to pre-select
      let selectedMonth, selectedYear;

      if (extraction.period && extraction.period.match(/^\d{4}-\d{2}$/)) {
        // Use provided period
        [selectedYear, selectedMonth] = extraction.period.split('-');
      } else {
        // Default to PREVIOUS month (most common use case for bank statements)
        const now = new Date();
        const prevMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        selectedYear = String(prevMonth.getFullYear());
        selectedMonth = String(prevMonth.getMonth() + 1).padStart(2, '0');
      }

      // Set the dropdowns
      document.getElementById('extract-period-month').value = selectedMonth;
      document.getElementById('extract-period-year').value = selectedYear;

      // Check if period is in TTM window and show notice
      const selectedPeriod = `${selectedYear}-${selectedMonth}`;
      checkTTMEligibility(selectedPeriod);

      // Show modal
      modal.classList.add('visible');
    }

    function checkTTMEligibility(period) {
      const notice = document.getElementById('extraction-ttm-notice');
      if (!period || !period.match(/^\d{4}-\d{2}$/)) {
        notice.innerHTML = '';
        notice.className = 'extraction-ttm-notice';
        return;
      }

      // Calculate TTM window (last 12 complete months)
      const now = new Date();
      const ttmEnd = new Date(now.getFullYear(), now.getMonth() - 1, 1); // Last month
      const ttmStart = new Date(ttmEnd.getFullYear(), ttmEnd.getMonth() - 11, 1); // 12 months before

      const ttmStartStr = `${ttmStart.getFullYear()}-${String(ttmStart.getMonth() + 1).padStart(2, '0')}`;
      const ttmEndStr = `${ttmEnd.getFullYear()}-${String(ttmEnd.getMonth() + 1).padStart(2, '0')}`;

      if (period >= ttmStartStr && period <= ttmEndStr) {
        notice.className = 'extraction-ttm-notice info';
        notice.innerHTML = `<strong> In TTM Window</strong><br>This statement (${period}) will be included in the Live Audit dashboard.`;
      } else {
        notice.className = 'extraction-ttm-notice warning';
        notice.innerHTML = `<strong> Outside TTM Window</strong><br>This statement (${period}) is outside the current TTM window (${ttmStartStr} to ${ttmEndStr}). Data will be saved but won't appear in TTM Revenue.`;
      }
    }

    function togglePeriodEdit() {
      const editFields = document.getElementById('period-edit-fields');
      const editBtn = document.getElementById('edit-period-btn');

      if (editFields.style.display === 'none') {
        editFields.style.display = 'block';
        editBtn.textContent = 'Cancel';
      } else {
        editFields.style.display = 'none';
        editBtn.textContent = 'Edit';
      }
    }

    function closeExtractionModal() {
      const modal = document.getElementById('extraction-confirm-modal');
      modal.classList.remove('visible');
      // Refresh document list
      loadFinancialDocuments(selectedPracticeId);
    }

    async function confirmExtraction() {
      if (!pendingExtraction) return;

      try {
        // Read values from input fields
        const depositsInput = document.getElementById('extract-deposits-input');
        const balanceInput = document.getElementById('extract-balance-input');
        const beginningBalanceInput = document.getElementById('extract-beginning-balance-input');
        const withdrawalsInput = document.getElementById('extract-withdrawals-input');

        const deposits = depositsInput.value ? parseFloat(depositsInput.value) : null;
        const balance = balanceInput.value ? parseFloat(balanceInput.value) : null;
        const beginningBalance = beginningBalanceInput.value ? parseFloat(beginningBalanceInput.value) : null;
        const withdrawals = withdrawalsInput.value ? parseFloat(withdrawalsInput.value) : null;

        // Validate required fields
        if (deposits === null || isNaN(deposits)) {
          alert('Please enter the Total Deposits amount.');
          depositsInput.focus();
          return;
        }

        // Get period from dropdowns or existing value
        const newMonth = document.getElementById('extract-period-month').value;
        const newYear = document.getElementById('extract-period-year').value;
        const newPeriod = `${newYear}-${newMonth}`;

        // Calculate period start/end dates
        const periodStart = `${newYear}-${newMonth}-01`;
        const lastDay = new Date(parseInt(newYear), parseInt(newMonth), 0).getDate();
        const periodEnd = `${newYear}-${newMonth}-${String(lastDay).padStart(2, '0')}`;

        console.log('[FinDocs] Confirming extraction:', {
          period: newPeriod,
          deposits,
          balance,
          beginningBalance,
          withdrawals
        });

        // Build extraction JSON for the record
        const extractionJson = {
          extraction_metadata: {
            model_name: pendingExtraction.isManualEntry ? 'manual_entry' : 'ai_extraction',
            extraction_method: pendingExtraction.isManualEntry ? 'manual' : 'ai',
            extracted_at: new Date().toISOString()
          },
          statement_period: {
            start_date: periodStart,
            end_date: periodEnd
          },
          account_summary: {
            deposits_total: { value: deposits, confidence: 1.0 },
            ending_balance: { value: balance, confidence: 1.0 },
            beginning_balance: { value: beginningBalance, confidence: 1.0 },
            withdrawals_total: { value: withdrawals, confidence: 1.0 }
          }
        };

        // Create extraction record (for manual entry or if not already created)
        let extractionId = pendingExtraction.extractionId;
        if (!extractionId) {
          extractionId = await createExtractionRecord({
            docId: pendingExtraction.docId,
            practiceId: selectedPracticeId,
            orgId: window.currentOrgId,
            periodStart,
            periodEnd,
            extractionJson,
            confidence: 1.0
          });
          console.log('[FinDocs] Created extraction record:', extractionId);
        }

        // Call canonicalization to create financial_facts
        const canonResult = await canonicalizeExtraction({
          docId: pendingExtraction.docId,
          extractionId,
          practiceId: selectedPracticeId,
          orgId: window.currentOrgId,
          periodStart,
          periodEnd,
          depositsTotal: deposits,
          endingBalance: balance,
          beginningBalance,
          withdrawalsTotal: withdrawals,
          confidence: 1.0
        });

        if (!canonResult.success) {
          throw new Error(canonResult.error || 'Canonicalization failed');
        }

        console.log('[FinDocs] Canonicalization complete, created facts:', canonResult.factIds);

        // Update document period and status
        await window.sb
          .from('financial_documents')
          .update({
            period_start: periodStart,
            period_end: periodEnd,
            processing_status: 'completed',
            last_processed_at: new Date().toISOString()
          })
          .eq('id', pendingExtraction.docId);

        // Log confirmation event
        await window.sb.from('document_events').insert({
          org_id: window.currentOrgId,
          practice_id: selectedPracticeId,
          document_type: 'financial',
          document_id: pendingExtraction.docId,
          event_type: 'extraction_confirmed',
          actor_user_id: window.currentUser.id,
          actor_email: window.currentUser.email,
          payload: {
            period: newPeriod,
            deposits,
            balance,
            extraction_id: extractionId,
            fact_ids: canonResult.factIds,
            is_manual: pendingExtraction.isManualEntry
          }
        });

        console.log('[FinDocs] Extraction confirmed successfully');

        // Close modal first
        pendingExtraction = null;
        closeExtractionModal();

        // Show success message
        showExtractionSuccess(deposits, newPeriod);

        // Refresh the documents list to show updated status
        await loadFinancialDocuments(selectedPracticeId);
        await loadFinancialProfile(selectedPracticeId);
        await fetchMonthlyBreakdown(selectedPracticeId);

      } catch (err) {
        console.error('[FinDocs] Confirm extraction error:', err);
        alert('Failed to save extraction: ' + err.message);
      }
    }

    function showExtractionSuccess(deposits, period) {
      // Format period for display
      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                          'July', 'August', 'September', 'October', 'November', 'December'];
      let periodDisplay = period;
      if (period && period.match(/^\d{4}-\d{2}$/)) {
        const [year, month] = period.split('-');
        periodDisplay = `${monthNames[parseInt(month) - 1]} ${year}`;
      }

      // Create success toast
      const toast = document.createElement('div');
      toast.className = 'extraction-success-toast';
      toast.innerHTML = `
        <div class="toast-icon">&#10003;</div>
        <div class="toast-content">
          <strong>Saved Successfully!</strong>
          <p>$${Number(deposits).toLocaleString()} for ${periodDisplay}</p>
          <small>View in Financial Profile below</small>
        </div>
      `;
      document.body.appendChild(toast);

      // Animate in
      setTimeout(() => toast.classList.add('visible'), 10);

      // Remove after 4 seconds
      setTimeout(() => {
        toast.classList.remove('visible');
        setTimeout(() => toast.remove(), 300);
      }, 4000);
    }

    async function rejectExtraction() {
      if (!pendingExtraction) return;

      if (!confirm('Reject this extraction? The extracted data will be deleted.')) return;

      try {
        // Delete the facts
        for (const factId of pendingExtraction.factIds) {
          await window.sb
            .from('financial_facts')
            .delete()
            .eq('id', factId);
        }

        // Update extraction record as rejected
        await window.sb
          .from('financial_extractions')
          .update({ status: 'rejected' })
          .eq('id', pendingExtraction.extractionId);

        // Reset document status
        await window.sb
          .from('financial_documents')
          .update({ processing_status: 'uploaded' })
          .eq('id', pendingExtraction.docId);

        console.log('[FinDocs] Extraction rejected');

        pendingExtraction = null;
        closeExtractionModal();

      } catch (err) {
        console.error('[FinDocs] Reject error:', err);
        alert('Failed to reject extraction: ' + err.message);
      }
    }

    // Load financial profile summary
    async function loadFinancialProfile(practiceId) {
      try {
        const { data: profile } = await window.sb
          .from('v_practice_financial_profile')
          .select('*')
          .eq('practice_id', practiceId)
          .single();

        renderFinancialProfile(profile);
      } catch (err) {
        // No profile data yet is fine
        renderFinancialProfile(null);
        renderMonthlyBreakdown([]);
      }
    }

    // Render financial profile summary
    function renderFinancialProfile(profile) {
      const coverageBar = document.getElementById('fin-coverage-bar');
      const coverageText = document.getElementById('fin-coverage-text');
      const confidenceBar = document.getElementById('fin-confidence-bar');
      const confidenceText = document.getElementById('fin-confidence-text');
      const t12Revenue = document.getElementById('fin-t12-revenue');
      const ttmRange = document.getElementById('fin-ttm-range');
      const ttmCoverage = document.getElementById('fin-ttm-coverage');

      // Historical data elements
      const allTimeDeposits = document.getElementById('fin-all-time-deposits');
      const avgMonthly = document.getElementById('fin-avg-monthly');
      const dataRange = document.getElementById('fin-data-range');
      const yoyGrowth = document.getElementById('fin-yoy-growth');

      if (!profile) {
        if (coverageBar) coverageBar.style.width = '0%';
        if (coverageText) coverageText.textContent = '0/36 months';
        if (confidenceBar) confidenceBar.style.width = '0%';
        if (confidenceText) confidenceText.textContent = '--';
        if (t12Revenue) t12Revenue.textContent = '--';
        if (ttmRange) ttmRange.textContent = '';
        if (ttmCoverage) ttmCoverage.textContent = '';
        // Reset historical
        if (allTimeDeposits) allTimeDeposits.textContent = '--';
        if (avgMonthly) avgMonthly.textContent = '--';
        if (dataRange) dataRange.textContent = '--';
        if (yoyGrowth) { yoyGrowth.textContent = '--'; yoyGrowth.className = 'fin-historical-value'; }
        return;
      }

      const coveragePct = profile.coverage_score || 0;
      const confidencePct = profile.confidence_score || 0;
      const monthsCovered = profile.months_covered || 0;

      if (coverageBar) coverageBar.style.width = coveragePct + '%';
      if (coverageText) coverageText.textContent = `${monthsCovered}/36 months`;
      if (confidenceBar) confidenceBar.style.width = confidencePct + '%';
      if (confidenceText) confidenceText.textContent = confidencePct > 0 ? confidencePct + '%' : '--';

      if (t12Revenue) {
        if (profile.trailing_12m_revenue) {
          t12Revenue.textContent = '$' + Number(profile.trailing_12m_revenue).toLocaleString();
        } else {
          t12Revenue.textContent = '--';
        }
      }

      // Display TTM date range (e.g., "Feb '25 - Jan '26")
      const formatPeriod = (p) => {
        if (!p) return '--';
        const [year, month] = p.split('-');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${monthNames[parseInt(month) - 1]} '${year.slice(2)}`;
      };

      if (ttmRange && profile.ttm_start && profile.ttm_end) {
        ttmRange.textContent = `(${formatPeriod(profile.ttm_start)} - ${formatPeriod(profile.ttm_end)})`;
      }

      // Display TTM data coverage (e.g., "8/12 months with data")
      if (ttmCoverage) {
        const ttmMonths = profile.ttm_months_with_data || 0;
        if (ttmMonths > 0) {
          ttmCoverage.textContent = `${ttmMonths}/12 months with data`;
        } else {
          ttmCoverage.textContent = '';
        }
      }

      // === Historical Data ===
      if (allTimeDeposits) {
        if (profile.all_time_deposits) {
          allTimeDeposits.textContent = '$' + Number(profile.all_time_deposits).toLocaleString();
        } else {
          allTimeDeposits.textContent = '--';
        }
      }

      if (avgMonthly) {
        if (profile.avg_monthly_deposits) {
          avgMonthly.textContent = '$' + Number(profile.avg_monthly_deposits).toLocaleString(undefined, {maximumFractionDigits: 0});
        } else {
          avgMonthly.textContent = '--';
        }
      }

      if (dataRange) {
        if (profile.earliest_period && profile.latest_period) {
          dataRange.textContent = `${formatPeriod(profile.earliest_period)} - ${formatPeriod(profile.latest_period)}`;
        } else {
          dataRange.textContent = '--';
        }
      }

      if (yoyGrowth) {
        if (profile.yoy_growth_pct !== null && profile.yoy_growth_pct !== undefined) {
          const pct = Number(profile.yoy_growth_pct);
          const sign = pct >= 0 ? '+' : '';
          yoyGrowth.textContent = `${sign}${pct.toFixed(1)}%`;
          yoyGrowth.className = 'fin-historical-value ' + (pct >= 0 ? 'positive' : 'negative');
        } else {
          yoyGrowth.textContent = '--';
          yoyGrowth.className = 'fin-historical-value';
        }
      }
    }

    // Track monthly breakdown state
    let monthlyBreakdownShowAll = false;
    let cachedMonthlyFacts = [];

    // Fetch monthly breakdown data from v_financial_facts_effective
    async function fetchMonthlyBreakdown(practiceId) {
      try {
        const { data, error } = await window.sb
          .from('v_financial_facts_effective')
          .select('*')
          .eq('practice_id', practiceId)
          .eq('fact_type', 'monthly_revenue_bank_deposits')
          .order('period', { ascending: false });

        if (error) throw error;
        cachedMonthlyFacts = data || [];
        renderMonthlyBreakdown(cachedMonthlyFacts);
      } catch (err) {
        console.error('Error fetching monthly breakdown:', err);
        cachedMonthlyFacts = [];
        renderMonthlyBreakdown([]);
      }
    }

    // Render monthly breakdown table
    function renderMonthlyBreakdown(facts) {
      const tbody = document.getElementById('fin-monthly-tbody');
      const toggle = document.getElementById('fin-monthly-toggle');
      if (!tbody) return;

      if (!facts || facts.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" class="fin-monthly-empty">No monthly data available yet.</td></tr>';
        if (toggle) toggle.style.display = 'none';
        return;
      }

      // Show toggle if more than 6 months
      if (toggle) {
        toggle.style.display = facts.length > 6 ? 'inline' : 'none';
        toggle.textContent = monthlyBreakdownShowAll ? 'Show Recent' : 'Show All';
      }

      // Limit to 6 months unless showing all
      const displayFacts = monthlyBreakdownShowAll ? facts : facts.slice(0, 6);

      // Format period for display (e.g., "2024-11" -> "Nov 2024")
      const formatPeriod = (period) => {
        if (!period) return '--';
        const [year, month] = period.split('-');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${monthNames[parseInt(month) - 1]} ${year}`;
      };

      // Get confidence badge class
      const getConfidenceBadge = (confidence) => {
        if (!confidence && confidence !== 0) return { class: 'medium', text: '--' };
        const pct = Math.round(confidence * 100);
        if (pct >= 90) return { class: 'high', text: pct + '%' };
        if (pct >= 70) return { class: 'medium', text: pct + '%' };
        return { class: 'low', text: pct + '%' };
      };

      tbody.innerHTML = displayFacts.map((fact, idx) => {
        const badge = getConfidenceBadge(fact.confidence);
        const overrideIndicator = fact.is_override ? '<span class="fin-override-indicator">Override</span>' : '';

        // Source link - passes fact index to retrieve full data
        const sourceHtml = fact.document_id
          ? `<a href="#" onclick="showEvidenceModal(${idx}); return false;">View Source</a>`
          : '<span style="color:#94a3b8">--</span>';

        return `
          <tr>
            <td class="fin-monthly-period">${formatPeriod(fact.period)}${overrideIndicator}</td>
            <td class="fin-monthly-value">$${Number(fact.value).toLocaleString()}</td>
            <td class="fin-monthly-source">${sourceHtml}</td>
            <td class="fin-monthly-confidence">
              <span class="fin-confidence-badge ${badge.class}">${badge.text}</span>
            </td>
          </tr>
        `;
      }).join('');
    }

    // Toggle monthly breakdown between showing all and recent 6 months
    function toggleMonthlyBreakdown() {
      monthlyBreakdownShowAll = !monthlyBreakdownShowAll;
      renderMonthlyBreakdown(cachedMonthlyFacts);
    }

    // Show evidence modal for a financial fact
    async function showEvidenceModal(displayIndex) {
      // Get the fact from the displayed list (respecting toggle state)
      const displayFacts = monthlyBreakdownShowAll ? cachedMonthlyFacts : cachedMonthlyFacts.slice(0, 6);
      const fact = displayFacts[displayIndex];

      if (!fact) {
        console.error('Fact not found at index:', displayIndex);
        return;
      }

      // Try to fetch document details if we have a document_id
      let docInfo = null;
      if (fact.document_id) {
        try {
          const { data } = await window.sb
            .from('financial_documents')
            .select('file_name, document_type, period_start, period_end')
            .eq('id', fact.document_id)
            .single();
          docInfo = data;
        } catch (err) {
          console.log('Could not fetch document info:', err);
        }
      }

      // Format period for display
      const formatPeriod = (period) => {
        if (!period) return '--';
        const [year, month] = period.split('-');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${monthNames[parseInt(month) - 1]} ${year}`;
      };

      // Format date
      const formatDate = (dateStr) => {
        if (!dateStr) return '--';
        const d = new Date(dateStr);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      };

      // Get confidence info
      const confidencePct = fact.confidence ? Math.round(fact.confidence * 100) : null;
      const confidenceClass = confidencePct >= 90 ? 'verified' : confidencePct >= 70 ? 'unverified' : 'unverified';

      // Parse source_location if it exists (JSON field)
      let sourceLocation = null;
      if (fact.source_location) {
        try {
          sourceLocation = typeof fact.source_location === 'string'
            ? JSON.parse(fact.source_location)
            : fact.source_location;
        } catch (e) {
          sourceLocation = null;
        }
      }

      // Build modal HTML
      const modalHtml = `
        <div class="evidence-modal-overlay" id="evidence-modal-overlay" onclick="closeEvidenceModal(event)">
          <div class="evidence-modal" onclick="event.stopPropagation()">
            <div class="evidence-modal-header">
              <h3 class="evidence-modal-title">Evidence Details - ${formatPeriod(fact.period)}</h3>
              <button class="evidence-modal-close" onclick="closeEvidenceModal()">&times;</button>
            </div>
            <div class="evidence-modal-body">
              <!-- Value Section -->
              <div class="evidence-section">
                <div class="evidence-section-title">Extracted Value</div>
                <div class="evidence-value">$${Number(fact.value).toLocaleString()}</div>
                ${fact.is_override ? `
                  <div style="margin-top: 0.5rem;">
                    <span class="evidence-badge override">Override Applied</span>
                    ${fact.original_value ? `<span style="color: #64748b; margin-left: 0.5rem; font-size: 0.85rem;">Original: $${Number(fact.original_value).toLocaleString()}</span>` : ''}
                  </div>
                  ${fact.override_reason ? `<div style="margin-top: 0.5rem; font-size: 0.85rem; color: #64748b;"><em>${fact.override_reason}</em></div>` : ''}
                ` : ''}
              </div>

              <!-- Confidence & Verification Section -->
              <div class="evidence-section">
                <div class="evidence-section-title">Confidence & Verification</div>
                <div class="evidence-row">
                  <span class="evidence-label">Confidence Score</span>
                  <span class="evidence-data">
                    ${confidencePct !== null ? `<span class="evidence-badge ${confidenceClass}">${confidencePct}%</span>` : '--'}
                  </span>
                </div>
                <div class="evidence-row">
                  <span class="evidence-label">Verification Status</span>
                  <span class="evidence-data">
                    <span class="evidence-badge ${fact.is_verified ? 'verified' : 'unverified'}">
                      ${fact.is_verified ? 'Verified' : 'Pending Verification'}
                    </span>
                  </span>
                </div>
                <div class="evidence-row">
                  <span class="evidence-label">Extraction Method</span>
                  <span class="evidence-data">${fact.extraction_method || '--'}</span>
                </div>
              </div>

              <!-- Source Document Section -->
              <div class="evidence-section">
                <div class="evidence-section-title">Source Document</div>
                ${docInfo ? `
                  <div class="evidence-row">
                    <span class="evidence-label">Document</span>
                    <span class="evidence-data">${docInfo.file_name || '--'}</span>
                  </div>
                  <div class="evidence-row">
                    <span class="evidence-label">Document Type</span>
                    <span class="evidence-data">${docInfo.document_type ? docInfo.document_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : '--'}</span>
                  </div>
                  <div class="evidence-row">
                    <span class="evidence-label">Statement Period</span>
                    <span class="evidence-data">${docInfo.period_start && docInfo.period_end ? `${formatDate(docInfo.period_start)} - ${formatDate(docInfo.period_end)}` : '--'}</span>
                  </div>
                ` : `
                  <div class="evidence-row">
                    <span class="evidence-label">Document ID</span>
                    <span class="evidence-data" style="font-family: monospace; font-size: 0.75rem;">${fact.document_id || '--'}</span>
                  </div>
                `}
              </div>

              <!-- Source Location Section (if available) -->
              ${sourceLocation ? `
                <div class="evidence-section">
                  <div class="evidence-section-title">Source Location</div>
                  ${sourceLocation.page ? `
                    <div class="evidence-row">
                      <span class="evidence-label">Page</span>
                      <span class="evidence-data">${sourceLocation.page}</span>
                    </div>
                  ` : ''}
                  ${sourceLocation.field_path ? `
                    <div class="evidence-row">
                      <span class="evidence-label">Field</span>
                      <span class="evidence-data" style="font-family: monospace;">${sourceLocation.field_path}</span>
                    </div>
                  ` : ''}
                  ${sourceLocation.snippet ? `
                    <div style="margin-top: 0.75rem;">
                      <div class="evidence-section-title">Source Text</div>
                      <div class="evidence-snippet">${sourceLocation.snippet}</div>
                    </div>
                  ` : ''}
                </div>
              ` : ''}

              <!-- Metadata Section -->
              <div class="evidence-section">
                <div class="evidence-section-title">Metadata</div>
                <div class="evidence-row">
                  <span class="evidence-label">Period Type</span>
                  <span class="evidence-data">${fact.period_type || 'Monthly'}</span>
                </div>
                <div class="evidence-row">
                  <span class="evidence-label">Currency</span>
                  <span class="evidence-data">${fact.currency || 'USD'}</span>
                </div>
                <div class="evidence-row">
                  <span class="evidence-label">Created</span>
                  <span class="evidence-data">${fact.created_at ? formatDate(fact.created_at) : '--'}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;

      // Remove existing modal if any
      const existingModal = document.getElementById('evidence-modal-overlay');
      if (existingModal) {
        existingModal.remove();
      }

      // Add modal to body
      document.body.insertAdjacentHTML('beforeend', modalHtml);
    }

    // Close evidence modal
    function closeEvidenceModal(event) {
      if (event && event.target.id !== 'evidence-modal-overlay') return;
      const modal = document.getElementById('evidence-modal-overlay');
      if (modal) modal.remove();
    }

    // Legacy function for backwards compatibility
    function viewFinancialDocument(documentId) {
      console.log('View document:', documentId);
      alert('Document viewer coming soon. Document ID: ' + documentId);
    }

    // Setup drag-and-drop for financial documents
    function setupFinDocDragDrop() {
      const dropzone = document.getElementById('fin-upload-dropzone');
      if (!dropzone) return;

      dropzone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropzone.classList.add('dragover');
      });

      dropzone.addEventListener('dragleave', () => {
        dropzone.classList.remove('dragover');
      });

      dropzone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropzone.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          document.getElementById('fin-file-input').files = files;
          handleFinancialDocUpload({ target: { files } });
        }
      });
    }

    // =============================================
    // DOCUMENT HUB - DD DOCUMENTS
    // =============================================

    // Switch between document tabs
    function switchDocTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.doc-hub-tab').forEach(tab => {
        tab.classList.remove('active');
        if (tab.dataset.tab === tabName) {
          tab.classList.add('active');
        }
      });

      // Update tab content
      document.querySelectorAll('.doc-tab-content').forEach(content => {
        content.classList.remove('active');
      });
      const targetTab = document.getElementById(`tab-${tabName}`);
      if (targetTab) {
        targetTab.classList.add('active');
      }
    }

    // Open bulk upload file picker
    function openBulkUpload() {
      if (!selectedPracticeId) {
        alert('Please select a practice first.');
        return;
      }
      document.getElementById('bulk-upload-input').click();
    }

    // Handle bulk upload
    let pendingBulkFiles = [];

    async function handleBulkUpload(event) {
      const files = Array.from(event.target.files);
      if (!files || files.length === 0) return;

      const practiceId = selectedPracticeId;
      if (!practiceId) return;

      // Auto-detect categories for all files
      pendingBulkFiles = files.map(file => {
        const detection = autoDetectDocumentCategory(file.name);
        return {
          file,
          category: detection?.category || 'dd_other',
          type: detection?.type || 'other',
          confidence: detection?.confidence || 'none'
        };
      });

      // Show preview modal
      showBulkUploadPreview();
    }

    function showBulkUploadPreview() {
      const categoryLabels = {
        'financial': 'Financial',
        'dd_corporate': 'Corporate',
        'dd_compliance': 'Compliance',
        'dd_contracts': 'Contracts',
        'dd_real_estate': 'Real Estate',
        'dd_insurance': 'Insurance',
        'dd_hr': 'HR & Staff',
        'dd_equipment': 'Equipment',
        'dd_it': 'IT & Systems',
        'dd_other': 'Other'
      };

      // Count by category
      const byCat = {};
      pendingBulkFiles.forEach(f => {
        byCat[f.category] = (byCat[f.category] || 0) + 1;
      });

      const summaryText = Object.entries(byCat)
        .map(([cat, count]) => `${categoryLabels[cat] || cat}: ${count}`)
        .join(', ');

      const itemsHtml = pendingBulkFiles.map((f, idx) => {
        const icon = f.file.type.includes('pdf') ? '' :
                     f.file.type.includes('image') ? '' :
                     f.file.type.includes('sheet') ? '' : '';
        const catLabel = categoryLabels[f.category] || f.category;
        const confClass = f.confidence === 'none' ? 'unknown' : '';

        return `
          <div class="bulk-upload-item" data-idx="${idx}">
            <span class="file-icon">${icon}</span>
            <div class="file-info">
              <div class="file-name">${escapeHtml(f.file.name)}</div>
              <div class="file-category ${confClass}">${catLabel} ${f.confidence === 'high' ? '' : f.confidence === 'none' ? '(undetected)' : ''}</div>
            </div>
            <select onchange="updateBulkFileCategory(${idx}, this.value)">
              ${Object.entries(categoryLabels).map(([val, label]) =>
                `<option value="${val}" ${val === f.category ? 'selected' : ''}>${label}</option>`
              ).join('')}
            </select>
          </div>
        `;
      }).join('');

      const modalHtml = `
        <div class="modal-overlay" id="bulk-upload-modal" onclick="if(event.target===this)closeBulkUploadModal()">
          <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
              <h2>Bulk Upload - ${pendingBulkFiles.length} Files</h2>
              <button class="modal-close" onclick="closeBulkUploadModal()">&times;</button>
            </div>
            <div class="modal-body">
              <div class="bulk-upload-summary">
                Auto-detected: ${summaryText}
              </div>
              <div class="bulk-upload-preview">
                ${itemsHtml}
              </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 0.5rem; justify-content: flex-end; padding: 1rem;">
              <button class="btn btn-secondary" onclick="closeBulkUploadModal()">Cancel</button>
              <button class="btn btn-primary" onclick="executeBulkUpload()">Upload All</button>
            </div>
          </div>
        </div>
      `;

      closeBulkUploadModal();
      document.body.insertAdjacentHTML('beforeend', modalHtml);
    }

    function closeBulkUploadModal() {
      const modal = document.getElementById('bulk-upload-modal');
      if (modal) modal.remove();
      document.getElementById('bulk-upload-input').value = '';
    }

    function updateBulkFileCategory(idx, category) {
      if (pendingBulkFiles[idx]) {
        pendingBulkFiles[idx].category = category;
      }
    }

    async function executeBulkUpload() {
      const practiceId = selectedPracticeId;
      if (!practiceId) return;

      const modal = document.getElementById('bulk-upload-modal');
      const uploadBtn = modal.querySelector('.btn-primary');
      uploadBtn.disabled = true;
      uploadBtn.textContent = 'Uploading...';

      let successCount = 0;
      let errorCount = 0;

      for (const item of pendingBulkFiles) {
        try {
          const file = item.file;
          const categorySlug = item.category;

          // Skip financial - those need special handling
          if (categorySlug === 'financial') {
            // Could redirect to financial upload, for now just show message
            console.log('[BulkUpload] Financial docs should use Financial tab');
            errorCount++;
            continue;
          }

          // Compute file hash
          const fileHash = await computeFileHash(file);

          // Check for duplicate
          const { data: existing } = await window.sb
            .from('dd_documents')
            .select('id')
            .eq('practice_id', practiceId)
            .eq('file_hash', fileHash)
            .limit(1);

          if (existing && existing.length > 0) {
            console.log('[BulkUpload] Duplicate:', file.name);
            errorCount++;
            continue;
          }

          // Upload file
          const safeName = file.name.replace(/[^a-z0-9._-]/gi, '_');
          const storagePath = `${window.currentOrgId}/${practiceId}/dd/${categorySlug}/${fileHash.substring(0, 8)}_${safeName}`;

          const { error: uploadError } = await window.sb.storage
            .from('financial-documents')
            .upload(storagePath, file);

          if (uploadError) {
            console.error('[BulkUpload] Upload error:', uploadError);
            errorCount++;
            continue;
          }

          // Create document record
          const docId = crypto.randomUUID();
          const { error: insertError } = await window.sb
            .from('dd_documents')
            .insert({
              id: docId,
              org_id: window.currentOrgId,
              practice_id: practiceId,
              category_slug: categorySlug,
              document_type: item.type,
              file_name: file.name,
              file_type: file.type,
              file_size_bytes: file.size,
              file_hash: fileHash,
              storage_path: storagePath,
              verification_status: 'pending',
              uploaded_by: window.currentUser.id,
              created_at: new Date().toISOString()
            });

          if (insertError) {
            console.error('[BulkUpload] Insert error:', insertError);
            errorCount++;
            continue;
          }

          successCount++;

        } catch (err) {
          console.error('[BulkUpload] Error:', err);
          errorCount++;
        }
      }

      closeBulkUploadModal();
      pendingBulkFiles = [];

      alert(`Bulk upload complete!\n${successCount} uploaded, ${errorCount} skipped/failed`);
      await loadDDDocuments(practiceId);
    }

    // Auto-detect document category based on filename
    function autoDetectDocumentCategory(filename) {
      const name = filename.toLowerCase();

      // Financial documents
      if (name.includes('bank') || name.includes('statement')) return { category: 'financial', type: 'bank_statement', confidence: 'high' };
      if (name.includes('p&l') || name.includes('pnl') || name.includes('income') || name.includes('profit')) return { category: 'financial', type: 'income_statement', confidence: 'high' };
      if (name.includes('balance') && name.includes('sheet')) return { category: 'financial', type: 'balance_sheet', confidence: 'high' };
      if (name.includes('tax') || name.includes('1099') || name.includes('w-2') || name.includes('1040')) return { category: 'financial', type: 'tax_return', confidence: 'high' };
      if (name.includes('payroll')) return { category: 'financial', type: 'payroll_report', confidence: 'high' };
      if (name.includes('ar') && name.includes('aging')) return { category: 'financial', type: 'ar_aging', confidence: 'high' };

      // Corporate documents
      if (name.includes('article') || name.includes('incorporat')) return { category: 'dd_corporate', type: 'articles_of_incorporation', confidence: 'high' };
      if (name.includes('operating') && name.includes('agreement')) return { category: 'dd_corporate', type: 'operating_agreement', confidence: 'high' };
      if (name.includes('bylaws') || name.includes('by-laws')) return { category: 'dd_corporate', type: 'bylaws', confidence: 'high' };
      if (name.includes('cap') && name.includes('table')) return { category: 'dd_corporate', type: 'cap_table', confidence: 'high' };
      if (name.includes('ein') || name.includes('tax') && name.includes('id')) return { category: 'dd_corporate', type: 'ein_letter', confidence: 'medium' };

      // Compliance documents
      if (name.includes('license') || name.includes('licence')) return { category: 'dd_compliance', type: 'medical_license', confidence: 'high' };
      if (name.includes('dea')) return { category: 'dd_compliance', type: 'dea_registration', confidence: 'high' };
      if (name.includes('clia')) return { category: 'dd_compliance', type: 'clia_certificate', confidence: 'high' };
      if (name.includes('hipaa')) return { category: 'dd_compliance', type: 'hipaa_attestation', confidence: 'high' };
      if (name.includes('malpractice') || name.includes('liability')) return { category: 'dd_compliance', type: 'malpractice_insurance', confidence: 'high' };
      if (name.includes('npi')) return { category: 'dd_compliance', type: 'npi_verification', confidence: 'high' };

      // Contracts
      if (name.includes('nda') || name.includes('confidential')) return { category: 'dd_contracts', type: 'nda', confidence: 'high' };
      if (name.includes('contract') || name.includes('agreement')) return { category: 'dd_contracts', type: 'service_agreement', confidence: 'medium' };
      if (name.includes('payer') || name.includes('payor') || name.includes('insurance')) return { category: 'dd_contracts', type: 'payer_contract', confidence: 'medium' };
      if (name.includes('employ')) return { category: 'dd_contracts', type: 'employment_contract', confidence: 'medium' };
      if (name.includes('vendor')) return { category: 'dd_contracts', type: 'vendor_agreement', confidence: 'medium' };

      // Real estate
      if (name.includes('lease') || name.includes('rent')) return { category: 'dd_real_estate', type: 'lease_agreement', confidence: 'high' };
      if (name.includes('deed') || name.includes('title')) return { category: 'dd_real_estate', type: 'property_deed', confidence: 'high' };

      // Insurance
      if (name.includes('insurance') || name.includes('policy') || name.includes('coverage')) return { category: 'dd_insurance', type: 'insurance_policy', confidence: 'medium' };

      // HR
      if (name.includes('employee') || name.includes('roster') || name.includes('staff')) return { category: 'dd_hr', type: 'employee_roster', confidence: 'medium' };
      if (name.includes('benefit') || name.includes('401k') || name.includes('health')) return { category: 'dd_hr', type: 'benefits_summary', confidence: 'medium' };
      if (name.includes('handbook') || name.includes('manual')) return { category: 'dd_hr', type: 'employee_handbook', confidence: 'medium' };

      // Equipment
      if (name.includes('equipment') || name.includes('asset') || name.includes('inventory')) return { category: 'dd_equipment', type: 'equipment_list', confidence: 'medium' };

      // IT
      if (name.includes('software') || name.includes('system') || name.includes('ehr') || name.includes('emr')) return { category: 'dd_it', type: 'software_list', confidence: 'medium' };

      // Default - could not detect
      return null;
    }

    // Show auto-categorization suggestion
    async function showCategorySuggestion(filename, docId) {
      const detection = autoDetectDocumentCategory(filename);
      if (!detection) return;

      const categoryLabels = {
        'financial': 'Financial',
        'dd_corporate': 'Corporate',
        'dd_compliance': 'Compliance',
        'dd_contracts': 'Contracts',
        'dd_real_estate': 'Real Estate',
        'dd_insurance': 'Insurance',
        'dd_hr': 'HR & Staff',
        'dd_equipment': 'Equipment',
        'dd_it': 'IT & Systems'
      };

      const catLabel = categoryLabels[detection.category] || detection.category;
      const typeLabel = getDocTypeLabel(detection.type);
      const confidence = detection.confidence === 'high' ? '(high confidence)' : '(suggested)';

      if (confirm(`Auto-detected: "${typeLabel}" in ${catLabel} ${confidence}\n\nWould you like to re-categorize this document?`)) {
        // Update document category
        await window.sb
          .from('dd_documents')
          .update({
            category_slug: detection.category,
            document_type: detection.type
          })
          .eq('id', docId);

        await loadDDDocuments(selectedPracticeId);
      }
    }

    // Handle DD document upload
    async function handleDDDocUpload(event, categorySlug) {
      const files = event.target.files;
      if (!files || files.length === 0) return;

      const practiceId = selectedPracticeId;
      if (!practiceId) {
        alert('Please select a practice first.');
        return;
      }

      for (const file of files) {
        try {
          console.log('[DDDocs] Uploading:', file.name, 'Category:', categorySlug);

          // Compute file hash for dedup
          const fileHash = await computeFileHash(file);
          console.log('[DDDocs] File hash:', fileHash);

          // Check for duplicate
          const { data: existing } = await window.sb
            .from('dd_documents')
            .select('id, file_name')
            .eq('practice_id', practiceId)
            .eq('file_hash', fileHash)
            .limit(1);

          if (existing && existing.length > 0) {
            alert(`This file has already been uploaded as "${existing[0].file_name}"`);
            continue;
          }

          // Build storage path: {org_id}/{practice_id}/dd/{category}/{hash}_{filename}
          const safeName = file.name.replace(/[^a-z0-9._-]/gi, '_');
          const storagePath = `${window.currentOrgId}/${practiceId}/dd/${categorySlug}/${fileHash.substring(0, 8)}_${safeName}`;

          // Upload to Supabase Storage
          const { data: uploadData, error: uploadError } = await window.sb.storage
            .from('financial-documents')
            .upload(storagePath, file, {
              contentType: file.type,
              upsert: false
            });

          if (uploadError) {
            console.error('[DDDocs] Upload error:', uploadError);
            alert('Failed to upload file: ' + uploadError.message);
            continue;
          }

          console.log('[DDDocs] Uploaded to storage:', storagePath);

          // Auto-detect document type from filename
          const detection = autoDetectDocumentCategory(file.name);
          const detectedCategory = detection?.category || categorySlug;
          const detectedType = detection?.type || categorySlug;

          // Create dd_documents record
          const docId = crypto.randomUUID();
          const docRecord = {
            id: docId,
            org_id: window.currentOrgId,
            practice_id: practiceId,
            category_slug: detectedCategory,
            document_type: detectedType,
            file_name: file.name,
            file_type: file.type,
            file_size_bytes: file.size,
            file_hash: fileHash,
            storage_path: storagePath,
            verification_status: 'pending',
            uploaded_by: window.currentUser.id,
            created_at: new Date().toISOString()
          };

          // Log auto-detection result if different from upload location
          if (detection && detection.category !== categorySlug) {
            console.log(`[DDDocs] Auto-detected: ${detection.type} in ${detection.category} (${detection.confidence})`);
          }

          const { error: insertError } = await window.sb
            .from('dd_documents')
            .insert(docRecord);

          if (insertError) {
            console.error('[DDDocs] Insert error:', insertError);
            alert('Failed to save document record: ' + insertError.message);
            continue;
          }

          console.log('[DDDocs] Created document record:', docId);

          // Log upload event
          await window.sb.from('document_events').insert({
            org_id: window.currentOrgId,
            practice_id: practiceId,
            document_type: 'dd',
            document_id: docId,
            event_type: 'uploaded',
            actor_user_id: window.currentUser.id,
            actor_email: window.currentUser.email,
            payload: { file_name: file.name, category: categorySlug, file_size: file.size }
          });

        } catch (err) {
          console.error('[DDDocs] Upload error:', err);
          alert('Failed to upload: ' + err.message);
        }
      }

      // Clear file input and refresh list
      event.target.value = '';
      await loadDDDocuments(practiceId);
    }

    // Load DD documents for a practice
    async function loadDDDocuments(practiceId) {
      if (!practiceId) return;

      try {
        const { data: docs, error } = await window.sb
          .from('dd_documents')
          .select('*')
          .eq('practice_id', practiceId)
          .order('created_at', { ascending: false });

        if (error) {
          console.error('[DDDocs] Load error:', error);
          return;
        }

        // Group docs by category
        const docsByCategory = {};
        (docs || []).forEach(doc => {
          const cat = doc.category_slug || 'dd_other';
          if (!docsByCategory[cat]) {
            docsByCategory[cat] = [];
          }
          docsByCategory[cat].push(doc);
        });

        // Render each category's documents
        renderDDDocsForCategory('dd_corporate', docsByCategory['dd_corporate'] || [], 'dd-docs-corporate');
        renderDDDocsForCategory('dd_compliance', docsByCategory['dd_compliance'] || [], 'dd-docs-compliance');
        renderDDDocsForCategory('dd_contracts', docsByCategory['dd_contracts'] || [], 'dd-docs-contracts');

        // Other categories go to "other" tab
        const otherDocs = [
          ...(docsByCategory['dd_real_estate'] || []),
          ...(docsByCategory['dd_insurance'] || []),
          ...(docsByCategory['dd_hr'] || []),
          ...(docsByCategory['dd_it'] || []),
          ...(docsByCategory['dd_equipment'] || []),
          ...(docsByCategory['practice_overview'] || [])
        ];
        renderDDDocsForCategory('dd_other', otherDocs, 'dd-docs-other');

        // Update DD Readiness score
        await updateDDReadiness(practiceId, docs || []);

      } catch (err) {
        console.error('[DDDocs] Load error:', err);
      }
    }

    // Render DD documents for a specific category
    function renderDDDocsForCategory(category, docs, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;

      if (!docs || docs.length === 0) {
        const emptyMessages = {
          'dd_corporate': 'No corporate documents uploaded yet.',
          'dd_compliance': 'No compliance documents uploaded yet.',
          'dd_contracts': 'No contracts uploaded yet.',
          'dd_other': 'No other DD documents uploaded yet.'
        };
        container.innerHTML = `<div class="dd-docs-empty">${emptyMessages[category] || 'No documents uploaded yet.'}</div>`;
        return;
      }

      const statusLabels = {
        'pending': 'Pending Review',
        'verified': 'Verified',
        'flagged': 'Needs Attention',
        'expired': 'Expired'
      };

      const categoryLabels = {
        'dd_corporate': 'Corporate',
        'dd_compliance': 'Compliance',
        'dd_contracts': 'Contract',
        'dd_real_estate': 'Real Estate',
        'dd_insurance': 'Insurance',
        'dd_hr': 'HR',
        'dd_it': 'IT',
        'dd_equipment': 'Equipment',
        'practice_overview': 'Overview'
      };

      container.innerHTML = docs.map(doc => {
        const icon = doc.file_type?.includes('pdf') ? '' :
                     doc.file_type?.includes('image') ? '' : '';
        const statusLabel = statusLabels[doc.verification_status] || doc.verification_status;
        const statusClass = doc.verification_status || 'pending';
        const uploadDate = new Date(doc.created_at).toLocaleDateString();
        const fileSize = formatFileSize(doc.file_size_bytes);
        const catLabel = categoryLabels[doc.category_slug] || '';

        // Expiration handling
        let expiryHtml = '';
        if (doc.expires_at) {
          const expiryDate = new Date(doc.expires_at);
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const daysUntil = Math.ceil((expiryDate - today) / (1000 * 60 * 60 * 24));
          const alertDays = doc.expiration_alert_days || 30;

          let expiryClass = 'valid';
          let expiryText = '';

          if (daysUntil < 0) {
            expiryClass = 'expired';
            expiryText = `Expired ${Math.abs(daysUntil)}d ago`;
          } else if (daysUntil <= alertDays) {
            expiryClass = 'expiring-soon';
            expiryText = daysUntil === 0 ? 'Expires today' : `Expires in ${daysUntil}d`;
          } else {
            expiryText = `Expires ${expiryDate.toLocaleDateString()}`;
          }

          expiryHtml = `<span class="expiry-badge ${expiryClass}">${expiryText}</span>`;
        }

        // Set expiry button for compliance docs
        const showExpiryBtn = ['dd_compliance', 'dd_insurance', 'dd_contracts'].includes(doc.category_slug || category);
        const expiryBtnHtml = showExpiryBtn ?
          `<button class="btn-set-expiry" onclick="showExpiryModal('${doc.id}', '${doc.expires_at || ''}')">${doc.expires_at ? 'Edit' : 'Set'} Expiry</button>` : '';

        // Version info
        const versionNum = doc.version_number || 1;
        const versionBadge = versionNum > 1 ? `<span class="version-badge">v${versionNum}</span>` : '';
        const newVersionBtn = doc.is_current_version !== false ?
          `<button class="btn-new-version" onclick="uploadNewVersion('${doc.id}', '${doc.category_slug || category}')">New Version</button>` : '';

        // Notes button
        const hasNotes = doc.notes && doc.notes.trim().length > 0;
        const notesBtn = `<button class="btn-doc-notes ${hasNotes ? 'has-notes' : 'no-notes'}" onclick="showNotesModal('${doc.id}', 'dd')">${hasNotes ? ' Notes' : '+ Note'}</button>`;

        // Extract button - only show for extractable file types
        const extractableTypes = ['application/pdf', 'image/png', 'image/jpeg', 'image/jpg'];
        const canExtract = extractableTypes.includes(doc.file_type);
        const isExtracting = doc.extraction_status === 'processing';
        const hasExtraction = doc.extraction_status === 'completed' && doc.extracted_data;

        let extractBtn = '';
        if (canExtract) {
          if (isExtracting) {
            extractBtn = `<button class="btn-extract extracting" disabled>Extracting...</button>`;
          } else if (hasExtraction) {
            extractBtn = `<button class="btn-extract" onclick="viewExtraction('${doc.id}')">View Data</button>`;
          } else {
            extractBtn = `<button class="btn-extract" onclick="extractDDDocument('${doc.id}')">Extract</button>`;
          }
        }

        // Render extracted data if available
        let extractedHtml = '';
        if (hasExtraction && doc.extracted_data) {
          extractedHtml = renderExtractedData(doc.extracted_data);
        }

        return `
          <div class="dd-doc-item" data-doc-id="${doc.id}">
            <div class="dd-doc-icon">${icon}</div>
            <div class="dd-doc-info">
              <div class="dd-doc-name">${escapeHtml(doc.file_name)}${versionBadge}${expiryHtml}</div>
              <div class="dd-doc-meta">${catLabel ? catLabel + '  ' : ''}${fileSize}  ${uploadDate} ${expiryBtnHtml}${newVersionBtn}${notesBtn}</div>
              ${extractedHtml}
            </div>
            <span class="dd-doc-status ${statusClass}">${statusLabel}</span>
            <div class="dd-doc-actions">
              <button onclick="viewDDDocument('${doc.id}')">View</button>
              ${extractBtn}
              <button onclick="verifyDDDocument('${doc.id}')" class="${doc.verification_status === 'verified' ? 'verified' : ''}">
                ${doc.verification_status === 'verified' ? ' Verified' : 'Verify'}
              </button>
              <button onclick="deleteDDDocument('${doc.id}')">Delete</button>
            </div>
          </div>
        `;
      }).join('');
    }

    // View DD document
    async function viewDDDocument(docId) {
      try {
        const { data: doc, error } = await window.sb
          .from('dd_documents')
          .select('*')
          .eq('id', docId)
          .single();

        if (error || !doc) {
          alert('Document not found');
          return;
        }

        // Get signed URL
        const { data: urlData, error: urlError } = await window.sb.storage
          .from('financial-documents')
          .createSignedUrl(doc.storage_path, 300);

        if (urlError) {
          alert('Failed to get document URL: ' + urlError.message);
          return;
        }

        window.open(urlData.signedUrl, '_blank');

      } catch (err) {
        console.error('[DDDocs] View error:', err);
        alert('Failed to view document: ' + err.message);
      }
    }

    // Verify DD document
    async function verifyDDDocument(docId) {
      try {
        const { data: doc } = await window.sb
          .from('dd_documents')
          .select('verification_status')
          .eq('id', docId)
          .single();

        const newStatus = doc?.verification_status === 'verified' ? 'pending' : 'verified';

        const { error } = await window.sb
          .from('dd_documents')
          .update({
            verification_status: newStatus,
            verified_by: newStatus === 'verified' ? window.currentUser.id : null,
            verified_at: newStatus === 'verified' ? new Date().toISOString() : null
          })
          .eq('id', docId);

        if (error) {
          alert('Failed to update status: ' + error.message);
          return;
        }

        // Log verify/unverify event
        await window.sb.from('document_events').insert({
          org_id: window.currentOrgId,
          practice_id: selectedPracticeId,
          document_type: 'dd',
          document_id: docId,
          event_type: newStatus === 'verified' ? 'verified' : 'unverified',
          actor_user_id: window.currentUser.id,
          actor_email: window.currentUser.email,
          payload: { new_status: newStatus }
        });

        await loadDDDocuments(selectedPracticeId);

      } catch (err) {
        console.error('[DDDocs] Verify error:', err);
        alert('Failed to verify document: ' + err.message);
      }
    }

    // Extraction prompts by document category
    const EXTRACTION_PROMPTS = {
      'dd_compliance': {
        types: ['license', 'certification', 'dea', 'npi'],
        prompt: `Extract the following information from this document. Return ONLY a JSON object with these fields (use null for missing values):
{
  "document_type": "license|certification|dea_registration|npi|other",
  "license_number": "the license/certificate/DEA number",
  "holder_name": "name of the person or entity",
  "issuing_authority": "state board, agency, or organization that issued it",
  "issue_date": "YYYY-MM-DD format",
  "expiration_date": "YYYY-MM-DD format",
  "status": "active|expired|pending",
  "specialty": "medical specialty if applicable",
  "state": "two-letter state code if applicable"
}`
      },
      'dd_corporate': {
        types: ['articles', 'operating_agreement', 'bylaws', 'ein'],
        prompt: `Extract the following information from this corporate document. Return ONLY a JSON object with these fields (use null for missing values):
{
  "document_type": "articles_of_incorporation|operating_agreement|bylaws|ein_letter|other",
  "entity_name": "legal name of the entity",
  "entity_type": "LLC|Corporation|Partnership|Sole Proprietorship|other",
  "formation_date": "YYYY-MM-DD format",
  "state_of_formation": "two-letter state code",
  "ein": "XX-XXXXXXX format if present",
  "registered_agent": "name of registered agent",
  "principal_address": "main business address",
  "members_or_officers": ["list of member/officer names"]
}`
      },
      'dd_contracts': {
        types: ['lease', 'employment', 'vendor', 'partnership'],
        prompt: `Extract the following information from this contract. Return ONLY a JSON object with these fields (use null for missing values):
{
  "document_type": "lease|employment_agreement|vendor_contract|partnership_agreement|other",
  "parties": ["list of parties to the contract"],
  "effective_date": "YYYY-MM-DD format",
  "expiration_date": "YYYY-MM-DD format or null if no end date",
  "term_length": "e.g., '5 years', '12 months'",
  "monthly_amount": numeric value in dollars if applicable,
  "total_value": numeric total contract value if stated,
  "auto_renews": true/false,
  "notice_period": "e.g., '30 days', '90 days'",
  "key_terms": ["list of important terms or conditions"]
}`
      },
      'dd_insurance': {
        types: ['malpractice', 'general_liability', 'property', 'workers_comp'],
        prompt: `Extract the following information from this insurance document. Return ONLY a JSON object with these fields (use null for missing values):
{
  "document_type": "malpractice|general_liability|property|workers_comp|other",
  "policy_number": "the policy number",
  "carrier_name": "insurance company name",
  "insured_name": "name of the insured party",
  "effective_date": "YYYY-MM-DD format",
  "expiration_date": "YYYY-MM-DD format",
  "coverage_amount": numeric value (per occurrence limit)",
  "aggregate_limit": numeric value (aggregate limit)",
  "deductible": numeric value,
  "premium": numeric annual premium if stated
}`
      },
      'dd_other': {
        types: ['other'],
        prompt: `Extract key information from this document. Return ONLY a JSON object with these fields (use null for missing values):
{
  "document_type": "brief description of document type",
  "title": "document title if present",
  "date": "YYYY-MM-DD format of primary date",
  "parties": ["list of relevant parties/names"],
  "key_values": {"label": "value pairs for important numbers or data"},
  "summary": "one sentence summary of what this document is"
}`
      }
    };

    // Extract data from DD document using Claude
    async function extractDDDocument(docId) {
      try {
        // Get document info
        const { data: doc, error: docError } = await window.sb
          .from('dd_documents')
          .select('*')
          .eq('id', docId)
          .single();

        if (docError || !doc) {
          alert('Document not found');
          return;
        }

        // Check if API key is configured
        const apiKey = localStorage.getItem('claude_api_key');
        if (!apiKey) {
          alert('Please configure your Claude API key in Settings to use extraction.');
          return;
        }

        // Update status to processing
        await window.sb
          .from('dd_documents')
          .update({ extraction_status: 'processing' })
          .eq('id', docId);

        // Refresh UI to show processing state
        await loadDDDocuments(selectedPracticeId);

        // Get signed URL for the document
        const { data: urlData, error: urlError } = await window.sb.storage
          .from('financial-documents')
          .createSignedUrl(doc.storage_path, 300);

        if (urlError) {
          throw new Error('Failed to get document URL: ' + urlError.message);
        }

        // Determine extraction prompt based on category
        const category = doc.category_slug || 'dd_other';
        const promptConfig = EXTRACTION_PROMPTS[category] || EXTRACTION_PROMPTS['dd_other'];

        // Fetch the document as base64 for Claude
        const response = await fetch(urlData.signedUrl);
        const blob = await response.blob();
        const base64 = await blobToBase64(blob);

        // Determine media type
        let mediaType = doc.file_type;
        if (mediaType === 'application/pdf') {
          mediaType = 'application/pdf';
        } else if (mediaType.startsWith('image/')) {
          // Keep as is
        } else {
          mediaType = 'image/png'; // fallback
        }

        // Call Claude API
        const claudeResponse = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 1024,
            messages: [{
              role: 'user',
              content: [
                {
                  type: mediaType === 'application/pdf' ? 'document' : 'image',
                  source: {
                    type: 'base64',
                    media_type: mediaType,
                    data: base64.split(',')[1]
                  }
                },
                {
                  type: 'text',
                  text: promptConfig.prompt
                }
              ]
            }]
          })
        });

        if (!claudeResponse.ok) {
          const errorData = await claudeResponse.json();
          throw new Error(errorData.error?.message || 'Claude API error');
        }

        const claudeData = await claudeResponse.json();
        const extractedText = claudeData.content[0]?.text || '';

        // Parse JSON from response
        let extractedData;
        try {
          // Try to extract JSON from the response
          const jsonMatch = extractedText.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            extractedData = JSON.parse(jsonMatch[0]);
          } else {
            throw new Error('No JSON found in response');
          }
        } catch (parseErr) {
          console.error('[Extract] Parse error:', parseErr, extractedText);
          throw new Error('Failed to parse extraction results');
        }

        // Save extracted data
        await window.sb
          .from('dd_documents')
          .update({
            extracted_data: extractedData,
            extraction_status: 'completed',
            extracted_at: new Date().toISOString()
          })
          .eq('id', docId);

        // Auto-set expiration if extracted
        if (extractedData.expiration_date && !doc.expires_at) {
          await window.sb
            .from('dd_documents')
            .update({ expires_at: extractedData.expiration_date })
            .eq('id', docId);
        }

        // Log extraction event
        await window.sb.from('document_events').insert({
          org_id: window.currentOrgId,
          practice_id: selectedPracticeId,
          document_type: 'dd',
          document_id: docId,
          event_type: 'extraction_completed',
          actor_user_id: window.currentUser.id,
          actor_email: window.currentUser.email,
          payload: { fields_extracted: Object.keys(extractedData).length }
        });

        // Refresh UI
        await loadDDDocuments(selectedPracticeId);

        // Show extraction modal with results
        showExtractionResultModal(doc, extractedData);

      } catch (err) {
        console.error('[Extract] Error:', err);

        // Update status to failed
        await window.sb
          .from('dd_documents')
          .update({ extraction_status: 'failed' })
          .eq('id', docId);

        await loadDDDocuments(selectedPracticeId);
        alert('Extraction failed: ' + err.message);
      }
    }

    // Convert blob to base64
    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // Render extracted data on document card
    function renderExtractedData(data) {
      if (!data || typeof data !== 'object') return '';

      // Define display fields by document type
      const displayFields = {
        // Compliance docs
        'license_number': 'License #',
        'holder_name': 'Holder',
        'expiration_date': 'Expires',
        'issuing_authority': 'Issuer',
        'state': 'State',
        // Corporate docs
        'entity_name': 'Entity',
        'entity_type': 'Type',
        'ein': 'EIN',
        'formation_date': 'Formed',
        // Contracts
        'parties': 'Parties',
        'effective_date': 'Effective',
        'monthly_amount': 'Monthly',
        'term_length': 'Term',
        // Insurance
        'policy_number': 'Policy #',
        'carrier_name': 'Carrier',
        'coverage_amount': 'Coverage',
        // General
        'document_type': 'Type'
      };

      // Get non-null fields
      const fields = Object.entries(data)
        .filter(([key, value]) => value !== null && value !== undefined && displayFields[key])
        .slice(0, 4); // Show max 4 fields

      if (fields.length === 0) return '';

      const fieldsHtml = fields.map(([key, value]) => {
        let displayValue = value;

        // Format values
        if (Array.isArray(value)) {
          displayValue = value.slice(0, 2).join(', ');
          if (value.length > 2) displayValue += '...';
        } else if (typeof value === 'number') {
          displayValue = '$' + value.toLocaleString();
        } else if (key.includes('date') && value) {
          try {
            displayValue = new Date(value).toLocaleDateString();
          } catch (e) {
            displayValue = value;
          }
        }

        return `
          <div class="dd-doc-extracted-field">
            <span class="dd-doc-extracted-label">${displayFields[key]}</span>
            <span class="dd-doc-extracted-value">${escapeHtml(String(displayValue))}</span>
          </div>
        `;
      }).join('');

      return `
        <div class="dd-doc-extracted">
          <div class="dd-doc-extracted-header">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M9 11l3 3L22 4"/>
              <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/>
            </svg>
            Extracted Data
          </div>
          <div class="dd-doc-extracted-grid">
            ${fieldsHtml}
          </div>
        </div>
      `;
    }

    // View extraction results
    async function viewExtraction(docId) {
      try {
        const { data: doc, error } = await window.sb
          .from('dd_documents')
          .select('*')
          .eq('id', docId)
          .single();

        if (error || !doc || !doc.extracted_data) {
          alert('No extraction data found');
          return;
        }

        showExtractionResultModal(doc, doc.extracted_data);

      } catch (err) {
        console.error('[Extract] View error:', err);
        alert('Failed to load extraction data');
      }
    }

    // Show extraction result modal
    function showExtractionResultModal(doc, data) {
      // Remove existing modal if any
      const existingModal = document.getElementById('extraction-result-modal');
      if (existingModal) existingModal.remove();

      // Build fields HTML
      const fieldsHtml = Object.entries(data)
        .filter(([key, value]) => value !== null && value !== undefined)
        .map(([key, value]) => {
          let displayValue = value;
          let inputType = 'text';

          if (Array.isArray(value)) {
            displayValue = value.join(', ');
          } else if (typeof value === 'object') {
            displayValue = JSON.stringify(value);
          } else if (typeof value === 'number') {
            inputType = 'number';
          }

          const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

          return `
            <div class="extraction-field">
              <label>${label}</label>
              <input type="${inputType}" name="${key}" value="${escapeHtml(String(displayValue))}" />
            </div>
          `;
        }).join('');

      const modal = document.createElement('div');
      modal.id = 'extraction-result-modal';
      modal.className = 'modal-overlay visible';
      modal.innerHTML = `
        <div class="modal extraction-modal-content">
          <div class="modal-header">
            <h3>Extracted Data</h3>
            <button class="modal-close" onclick="closeExtractionResultModal()">&times;</button>
          </div>
          <div class="modal-body">
            <div style="margin-bottom: 0.75rem; font-size: 0.85rem; color: #6b7280;">
              From: <strong>${escapeHtml(doc.file_name)}</strong>
            </div>
            <div class="extraction-fields">
              ${fieldsHtml}
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeExtractionResultModal()">Close</button>
            <button class="btn btn-primary" onclick="saveExtractionEdits('${doc.id}')">Save Changes</button>
            <button class="btn btn-secondary" onclick="reExtractDocument('${doc.id}')">Re-Extract</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }

    function closeExtractionResultModal() {
      const modal = document.getElementById('extraction-result-modal');
      if (modal) modal.remove();
    }

    async function saveExtractionEdits(docId) {
      const modal = document.getElementById('extraction-result-modal');
      if (!modal) return;

      const inputs = modal.querySelectorAll('.extraction-field input');
      const updatedData = {};

      inputs.forEach(input => {
        let value = input.value;
        // Try to parse numbers
        if (input.type === 'number' && value) {
          value = parseFloat(value);
        }
        // Try to parse arrays (comma-separated)
        if (value && value.includes(',') && !value.match(/^\d{4}-\d{2}-\d{2}$/)) {
          value = value.split(',').map(s => s.trim());
        }
        updatedData[input.name] = value || null;
      });

      try {
        await window.sb
          .from('dd_documents')
          .update({ extracted_data: updatedData })
          .eq('id', docId);

        closeExtractionResultModal();
        await loadDDDocuments(selectedPracticeId);

      } catch (err) {
        console.error('[Extract] Save error:', err);
        alert('Failed to save changes');
      }
    }

    async function reExtractDocument(docId) {
      closeExtractionResultModal();

      // Reset extraction status
      await window.sb
        .from('dd_documents')
        .update({
          extracted_data: null,
          extraction_status: null,
          extracted_at: null
        })
        .eq('id', docId);

      await loadDDDocuments(selectedPracticeId);

      // Run extraction again
      await extractDDDocument(docId);
    }

    // Delete DD document
    async function deleteDDDocument(docId) {
      if (!confirm('Are you sure you want to delete this document?')) return;

      try {
        const { data: doc } = await window.sb
          .from('dd_documents')
          .select('storage_path, file_name, category_slug')
          .eq('id', docId)
          .single();

        // Log delete event BEFORE deleting
        await window.sb.from('document_events').insert({
          org_id: window.currentOrgId,
          practice_id: selectedPracticeId,
          document_type: 'dd',
          document_id: docId,
          event_type: 'deleted',
          actor_user_id: window.currentUser.id,
          actor_email: window.currentUser.email,
          payload: { file_name: doc?.file_name, category: doc?.category_slug }
        });

        // Delete from storage
        if (doc?.storage_path) {
          await window.sb.storage
            .from('financial-documents')
            .remove([doc.storage_path]);
        }

        // Delete record
        const { error } = await window.sb
          .from('dd_documents')
          .delete()
          .eq('id', docId);

        if (error) {
          alert('Failed to delete document: ' + error.message);
          return;
        }

        await loadDDDocuments(selectedPracticeId);

      } catch (err) {
        console.error('[DDDocs] Delete error:', err);
        alert('Failed to delete document: ' + err.message);
      }
    }

    // Show expiry date modal
    function showExpiryModal(docId, currentExpiry) {
      // Create modal
      const modalHtml = `
        <div class="modal-overlay" id="expiry-modal" onclick="if(event.target===this)closeExpiryModal()">
          <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
              <h2>Set Expiration Date</h2>
              <button class="modal-close" onclick="closeExpiryModal()">&times;</button>
            </div>
            <div class="expiry-modal-content">
              <div class="expiry-form-group">
                <label>Expiration Date</label>
                <input type="date" id="expiry-date-input" value="${currentExpiry ? currentExpiry.split('T')[0] : ''}">
              </div>
              <div class="expiry-form-group">
                <label>Alert Days Before (default: 30)</label>
                <input type="number" id="expiry-alert-days" value="30" min="1" max="365">
              </div>
              <div class="expiry-form-actions">
                ${currentExpiry ? `<button class="btn btn-secondary" onclick="clearDocumentExpiry('${docId}')">Clear Expiry</button>` : ''}
                <button class="btn btn-secondary" onclick="closeExpiryModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveDocumentExpiry('${docId}')">Save</button>
              </div>
            </div>
          </div>
        </div>
      `;

      // Remove any existing modal
      closeExpiryModal();

      // Add modal to body
      document.body.insertAdjacentHTML('beforeend', modalHtml);
    }

    function closeExpiryModal() {
      const modal = document.getElementById('expiry-modal');
      if (modal) modal.remove();
    }

    async function saveDocumentExpiry(docId) {
      const expiryDate = document.getElementById('expiry-date-input').value;
      const alertDays = parseInt(document.getElementById('expiry-alert-days').value) || 30;

      if (!expiryDate) {
        alert('Please select an expiration date');
        return;
      }

      try {
        const { error } = await window.sb
          .from('dd_documents')
          .update({
            expires_at: expiryDate,
            expiration_alert_days: alertDays
          })
          .eq('id', docId);

        if (error) {
          alert('Failed to save expiry: ' + error.message);
          return;
        }

        // Log event
        await window.sb.from('document_events').insert({
          id: crypto.randomUUID(),
          practice_id: selectedPracticeId,
          document_id: docId,
          document_source: 'dd_documents',
          event_type: 'expiry_set',
          event_data: { expires_at: expiryDate, alert_days: alertDays },
          performed_by: window.currentUser?.id,
          performed_at: new Date().toISOString()
        });

        closeExpiryModal();
        await loadDDDocuments(selectedPracticeId);

      } catch (err) {
        console.error('[Expiry] Save error:', err);
        alert('Failed to save expiry: ' + err.message);
      }
    }

    async function clearDocumentExpiry(docId) {
      try {
        const { error } = await window.sb
          .from('dd_documents')
          .update({
            expires_at: null,
            expiration_alert_days: null
          })
          .eq('id', docId);

        if (error) {
          alert('Failed to clear expiry: ' + error.message);
          return;
        }

        closeExpiryModal();
        await loadDDDocuments(selectedPracticeId);

      } catch (err) {
        console.error('[Expiry] Clear error:', err);
        alert('Failed to clear expiry: ' + err.message);
      }
    }

    // Document type guidance for notes - helps users understand what each doc type should contain
    const documentTypeGuidance = {
      // Financial
      'bank_statement': {
        label: 'Bank Statement',
        guidance: 'Monthly bank statements showing deposits and account activity.',
        what_to_submit: '12+ months of statements for TTM analysis'
      },
      'income_statement': {
        label: 'Income Statement / P&L',
        guidance: 'Profit & Loss showing revenue, expenses, and net income.',
        what_to_submit: 'YTD or annual P&L from QuickBooks/accountant'
      },
      'balance_sheet': {
        label: 'Balance Sheet',
        guidance: 'Snapshot of assets, liabilities, and equity.',
        what_to_submit: 'Most recent month-end or year-end balance sheet'
      },
      'tax_return': {
        label: 'Tax Return',
        guidance: 'Business tax returns (1120, 1120S, 1065, Schedule C).',
        what_to_submit: '3 years of complete returns with all schedules'
      },
      'ar_aging': {
        label: 'AR Aging Report',
        guidance: 'Accounts receivable aging showing outstanding patient/payer balances.',
        what_to_submit: 'Current AR aging report from billing system'
      },
      // Corporate
      'articles_of_incorporation': {
        label: 'Articles of Incorporation',
        guidance: 'State filing document that legally creates the entity.',
        what_to_submit: 'Certificate of Formation or Articles from Secretary of State'
      },
      'operating_agreement': {
        label: 'Operating Agreement',
        guidance: 'LLC operating agreement showing ownership structure.',
        what_to_submit: 'Signed agreement with ownership percentages'
      },
      'bylaws': {
        label: 'Corporate Bylaws',
        guidance: 'Rules governing corporate operations.',
        what_to_submit: 'Current adopted bylaws document'
      },
      // Compliance
      'medical_license': {
        label: 'Medical License',
        guidance: 'State medical license for each provider.',
        what_to_submit: 'Current license showing expiration date'
      },
      'dea_registration': {
        label: 'DEA Registration',
        guidance: 'DEA certificate for controlled substance prescribing.',
        what_to_submit: 'Current DEA registration certificate'
      },
      'malpractice_insurance': {
        label: 'Malpractice Insurance',
        guidance: 'Professional liability coverage.',
        what_to_submit: 'Policy declarations page showing coverage limits'
      },
      'npi_verification': {
        label: 'NPI Verification',
        guidance: 'National Provider Identifier verification.',
        what_to_submit: 'NPI confirmation letter or NPPES printout'
      },
      // Contracts
      'payer_contract': {
        label: 'Payer Contract',
        guidance: 'Insurance company contracts.',
        what_to_submit: 'Signed payer agreements with fee schedules if available'
      },
      'lease_agreement': {
        label: 'Lease Agreement',
        guidance: 'Property lease for practice location.',
        what_to_submit: 'Current lease showing term, rent, and renewal options'
      },
      'employment_contract': {
        label: 'Employment Contract',
        guidance: 'Provider or key staff employment agreements.',
        what_to_submit: 'Signed contracts with compensation terms'
      },
      // Default
      'default': {
        label: 'Document',
        guidance: 'Supporting documentation for due diligence.',
        what_to_submit: 'Relevant supporting documents'
      }
    };

    // Get guidance for a document type
    function getDocumentGuidance(documentType) {
      return documentTypeGuidance[documentType] || documentTypeGuidance['default'];
    }

    // Show notes modal for a document
    async function showNotesModal(docId, docType) {
      // Fetch current notes
      const table = docType === 'dd' ? 'dd_documents' : 'financial_documents';
      const { data: doc, error } = await window.sb
        .from(table)
        .select('notes, notes_updated_at, notes_updated_by, file_name, document_type')
        .eq('id', docId)
        .single();

      if (error) {
        alert('Failed to load document notes');
        return;
      }

      const notesValue = doc?.notes || '';
      const lastUpdated = doc?.notes_updated_at ?
        `Last updated: ${new Date(doc.notes_updated_at).toLocaleString()}` : '';

      // Get guidance for this document type
      const guidance = getDocumentGuidance(doc?.document_type);

      const modalHtml = `
        <div class="modal-overlay" id="notes-modal" onclick="if(event.target===this)closeNotesModal()">
          <div class="modal" style="max-width: 520px;">
            <div class="modal-header">
              <h2>Document Notes</h2>
              <button class="modal-close" onclick="closeNotesModal()">&times;</button>
            </div>
            <div class="notes-modal-content">
              <p style="margin-bottom: 0.5rem; font-weight: 500;">${escapeHtml(doc?.file_name || 'Document')}</p>

              <div style="background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 6px; padding: 0.75rem; margin-bottom: 1rem;">
                <div style="font-weight: 600; color: #0369a1; font-size: 0.9rem;">${guidance.label}</div>
                <div style="font-size: 0.8rem; color: #475569; margin-top: 0.25rem;">${guidance.guidance}</div>
                <div style="font-size: 0.75rem; color: #0369a1; margin-top: 0.5rem; background: #e0f2fe; padding: 0.35rem 0.5rem; border-radius: 4px;">
                  <strong>What to submit:</strong> ${guidance.what_to_submit}
                </div>
              </div>

              <textarea class="notes-textarea" id="notes-textarea" placeholder="Add notes about this document...

Suggested info to include:
 Source (who prepared/provided it)
 Date range or period covered
 Any issues, flags, or follow-ups needed">${escapeHtml(notesValue)}</textarea>
              ${lastUpdated ? `<div class="notes-meta">${lastUpdated}</div>` : ''}
              <div class="expiry-form-actions">
                <button class="btn btn-secondary" onclick="closeNotesModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveDocumentNotes('${docId}', '${docType}')">Save Notes</button>
              </div>
            </div>
          </div>
        </div>
      `;

      closeNotesModal();
      document.body.insertAdjacentHTML('beforeend', modalHtml);
    }

    function closeNotesModal() {
      const modal = document.getElementById('notes-modal');
      if (modal) modal.remove();
    }

    async function saveDocumentNotes(docId, docType) {
      const notes = document.getElementById('notes-textarea').value;
      const table = docType === 'dd' ? 'dd_documents' : 'financial_documents';

      try {
        const { error } = await window.sb
          .from(table)
          .update({
            notes: notes,
            notes_updated_at: new Date().toISOString(),
            notes_updated_by: window.currentUser?.id
          })
          .eq('id', docId);

        if (error) {
          alert('Failed to save notes: ' + error.message);
          return;
        }

        closeNotesModal();

        // Refresh the appropriate document list
        if (docType === 'dd') {
          await loadDDDocuments(selectedPracticeId);
        } else {
          await loadFinancialDocuments(selectedPracticeId);
        }

      } catch (err) {
        console.error('[Notes] Save error:', err);
        alert('Failed to save notes: ' + err.message);
      }
    }

    // Upload new version of a document
    let pendingVersionUpload = null;

    function uploadNewVersion(parentDocId, categorySlug) {
      pendingVersionUpload = { parentDocId, categorySlug };

      // Create hidden file input
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.pdf,.png,.jpg,.jpeg,.doc,.docx';
      input.onchange = handleVersionUpload;
      input.click();
    }

    async function handleVersionUpload(event) {
      const file = event.target.files[0];
      if (!file || !pendingVersionUpload) return;

      const { parentDocId, categorySlug } = pendingVersionUpload;
      pendingVersionUpload = null;

      const practiceId = selectedPracticeId;
      if (!practiceId) return;

      try {
        // Get parent document info
        const { data: parentDoc } = await window.sb
          .from('dd_documents')
          .select('version_number, file_name, document_type, expires_at, expiration_alert_days')
          .eq('id', parentDocId)
          .single();

        const newVersion = (parentDoc?.version_number || 1) + 1;

        // Upload file to storage
        const timestamp = Date.now();
        const safeName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
        const storagePath = `${practiceId}/dd/${categorySlug}/${timestamp}_${safeName}`;

        const { error: uploadError } = await window.sb.storage
          .from('financial-documents')
          .upload(storagePath, file);

        if (uploadError) {
          alert('Failed to upload file: ' + uploadError.message);
          return;
        }

        // Create new document record
        const newDocId = crypto.randomUUID();
        const newDocRecord = {
          id: newDocId,
          practice_id: practiceId,
          file_name: file.name,
          file_type: file.type,
          file_size_bytes: file.size,
          storage_path: storagePath,
          category_slug: categorySlug,
          document_type: parentDoc?.document_type || categorySlug,
          verification_status: 'pending',
          version_number: newVersion,
          parent_document_id: parentDocId,
          is_current_version: true,
          expires_at: parentDoc?.expires_at,
          expiration_alert_days: parentDoc?.expiration_alert_days,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };

        const { error: insertError } = await window.sb
          .from('dd_documents')
          .insert(newDocRecord);

        if (insertError) {
          alert('Failed to create document record: ' + insertError.message);
          return;
        }

        // Mark old document as superseded
        await window.sb
          .from('dd_documents')
          .update({
            is_current_version: false,
            superseded_at: new Date().toISOString(),
            superseded_by: newDocId
          })
          .eq('id', parentDocId);

        // Log event
        await window.sb.from('document_events').insert({
          id: crypto.randomUUID(),
          practice_id: practiceId,
          document_id: newDocId,
          document_source: 'dd_documents',
          event_type: 'new_version_uploaded',
          event_data: { parent_id: parentDocId, version: newVersion },
          performed_by: window.currentUser?.id,
          performed_at: new Date().toISOString()
        });

        alert(`Version ${newVersion} uploaded successfully!`);
        await loadDDDocuments(practiceId);

      } catch (err) {
        console.error('[Version] Upload error:', err);
        alert('Failed to upload new version: ' + err.message);
      }
    }

    // Built-in document request templates
    const BUILT_IN_TEMPLATES = [
      {
        id: 'standard-dd',
        name: 'Standard DD Package',
        description: 'Complete due diligence package for practice acquisitions',
        is_default: true,
        items: [
          { category: 'financial', name: 'Bank Statements (12+ months)', required: true },
          { category: 'financial', name: 'Income Statement / P&L (YTD + prior 2 years)', required: true },
          { category: 'financial', name: 'Balance Sheet (current)', required: true },
          { category: 'financial', name: 'Tax Returns (3 years)', required: true },
          { category: 'financial', name: 'Accounts Receivable Aging Report', required: false },
          { category: 'financial', name: 'Accounts Payable Summary', required: false },
          { category: 'dd_compliance', name: 'Medical License (all providers)', required: true },
          { category: 'dd_compliance', name: 'DEA Registration', required: true },
          { category: 'dd_compliance', name: 'NPI Documentation', required: true },
          { category: 'dd_compliance', name: 'Malpractice Insurance Certificate', required: true },
          { category: 'dd_compliance', name: 'State Medical Board Verification', required: false },
          { category: 'dd_corporate', name: 'Articles of Incorporation/Organization', required: true },
          { category: 'dd_corporate', name: 'Operating Agreement / Bylaws', required: true },
          { category: 'dd_corporate', name: 'EIN Letter (IRS SS-4)', required: true },
          { category: 'dd_corporate', name: 'Good Standing Certificate', required: false },
          { category: 'dd_contracts', name: 'Facility Lease Agreement', required: true },
          { category: 'dd_contracts', name: 'Equipment Leases', required: false },
          { category: 'dd_contracts', name: 'Payor Contracts Summary', required: true },
          { category: 'dd_contracts', name: 'Employment Agreements (key staff)', required: false }
        ]
      },
      {
        id: 'compliance-audit',
        name: 'Compliance Audit',
        description: 'Focus on licenses, certifications, and regulatory compliance',
        items: [
          { category: 'dd_compliance', name: 'Medical License (all providers)', required: true },
          { category: 'dd_compliance', name: 'DEA Registration', required: true },
          { category: 'dd_compliance', name: 'State Controlled Substance License', required: true },
          { category: 'dd_compliance', name: 'NPI Documentation', required: true },
          { category: 'dd_compliance', name: 'Board Certifications', required: true },
          { category: 'dd_compliance', name: 'Malpractice Insurance Certificate', required: true },
          { category: 'dd_compliance', name: 'HIPAA Compliance Documentation', required: true },
          { category: 'dd_compliance', name: 'OSHA Compliance Records', required: false },
          { category: 'dd_compliance', name: 'Medicare/Medicaid Enrollment', required: true },
          { category: 'dd_compliance', name: 'Credentialing Documentation', required: false },
          { category: 'dd_compliance', name: 'Liability Insurance Policy', required: true },
          { category: 'dd_compliance', name: 'Workers Compensation Certificate', required: false }
        ]
      },
      {
        id: 'financial-review',
        name: 'Financial Review',
        description: 'Comprehensive financial documentation for valuation',
        items: [
          { category: 'financial', name: 'Bank Statements (24 months)', required: true },
          { category: 'financial', name: 'Tax Returns (3 years - business)', required: true },
          { category: 'financial', name: 'Tax Returns (3 years - personal if pass-through)', required: true },
          { category: 'financial', name: 'Income Statement / P&L (monthly, 3 years)', required: true },
          { category: 'financial', name: 'Balance Sheet (year-end, 3 years)', required: true },
          { category: 'financial', name: 'Accounts Receivable Aging', required: true },
          { category: 'financial', name: 'Accounts Payable Aging', required: true },
          { category: 'financial', name: 'Debt Schedule', required: true },
          { category: 'financial', name: 'Payroll Reports (12 months)', required: true },
          { category: 'financial', name: 'Production Reports by Provider', required: true },
          { category: 'financial', name: 'Fee Schedule', required: false },
          { category: 'financial', name: 'Payor Mix Report', required: true }
        ]
      },
      {
        id: 'real-estate-dd',
        name: 'Real Estate DD',
        description: 'Documents for facility and property due diligence',
        items: [
          { category: 'dd_contracts', name: 'Facility Lease Agreement', required: true },
          { category: 'dd_contracts', name: 'Lease Amendments/Addendums', required: false },
          { category: 'dd_contracts', name: 'Landlord Estoppel Certificate', required: true },
          { category: 'dd_contracts', name: 'Property Tax Statements', required: false },
          { category: 'dd_other', name: 'Floor Plan / Layout', required: true },
          { category: 'dd_other', name: 'Property Photos', required: true },
          { category: 'dd_other', name: 'Certificate of Occupancy', required: true },
          { category: 'dd_other', name: 'Environmental Reports', required: false },
          { category: 'dd_other', name: 'ADA Compliance Documentation', required: false },
          { category: 'dd_contracts', name: 'Equipment List with Values', required: true },
          { category: 'dd_contracts', name: 'Equipment Lease Agreements', required: false },
          { category: 'dd_other', name: 'Maintenance Records', required: false }
        ]
      },
      {
        id: 'corporate-docs',
        name: 'Corporate Documents',
        description: 'Entity formation and governance documents',
        items: [
          { category: 'dd_corporate', name: 'Articles of Incorporation/Organization', required: true },
          { category: 'dd_corporate', name: 'Operating Agreement / Bylaws', required: true },
          { category: 'dd_corporate', name: 'Amendments to Formation Documents', required: false },
          { category: 'dd_corporate', name: 'EIN Letter (IRS SS-4)', required: true },
          { category: 'dd_corporate', name: 'Good Standing Certificate', required: true },
          { category: 'dd_corporate', name: 'Stock/Membership Certificates', required: true },
          { category: 'dd_corporate', name: 'Cap Table / Ownership Summary', required: true },
          { category: 'dd_corporate', name: 'Board Meeting Minutes', required: false },
          { category: 'dd_corporate', name: 'Shareholder/Member Resolutions', required: false },
          { category: 'dd_corporate', name: 'Buy-Sell Agreement', required: false },
          { category: 'dd_corporate', name: 'Organization Chart', required: true }
        ]
      }
    ];

    // Selected template state
    let selectedTemplateId = null;

    // Show template picker modal
    function showTemplatePickerModal() {
      if (!selectedPracticeId) {
        alert('Please select a practice first.');
        return;
      }

      // Remove existing modal
      const existingModal = document.getElementById('template-picker-modal');
      if (existingModal) existingModal.remove();

      // Build template cards
      const templateCardsHtml = BUILT_IN_TEMPLATES.map(template => {
        const categoryGroups = {};
        template.items.forEach(item => {
          if (!categoryGroups[item.category]) categoryGroups[item.category] = 0;
          categoryGroups[item.category]++;
        });

        const categoryLabels = {
          'financial': 'Financial',
          'dd_compliance': 'Compliance',
          'dd_corporate': 'Corporate',
          'dd_contracts': 'Contracts',
          'dd_other': 'Other'
        };

        const previewTags = Object.entries(categoryGroups).map(([cat, count]) =>
          `<span class="template-item-tag category">${categoryLabels[cat] || cat}: ${count}</span>`
        ).join('');

        const defaultBadge = template.is_default ? '<span class="template-card-badge">Default</span>' : '';

        return `
          <div class="template-card" data-template-id="${template.id}" onclick="selectTemplate('${template.id}')">
            <div class="template-card-header">
              <span class="template-card-name">${escapeHtml(template.name)}</span>
              ${defaultBadge}
            </div>
            <div class="template-card-desc">${escapeHtml(template.description)}</div>
            <div class="template-card-preview">
              ${previewTags}
              <span class="template-item-tag">${template.items.length} items total</span>
            </div>
          </div>
        `;
      }).join('');

      const modal = document.createElement('div');
      modal.id = 'template-picker-modal';
      modal.className = 'modal-overlay visible';
      modal.innerHTML = `
        <div class="modal template-picker-modal">
          <div class="modal-header">
            <h3>Apply Document Template</h3>
            <button class="modal-close" onclick="closeTemplatePickerModal()">&times;</button>
          </div>
          <div class="modal-body">
            <p style="margin-bottom: 1rem; color: #6b7280; font-size: 0.85rem;">
              Select a template to create a DD checklist for this practice. Items will be added to the requirements list.
            </p>
            <div class="template-list">
              ${templateCardsHtml}
            </div>
            <div class="template-options">
              <label class="template-option">
                <input type="checkbox" id="template-send-email" checked>
                Generate email request after applying
              </label>
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeTemplatePickerModal()">Cancel</button>
            <button class="btn btn-primary" id="apply-template-btn" onclick="applySelectedTemplate()" disabled>
              Apply Template
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Select default template
      const defaultTemplate = BUILT_IN_TEMPLATES.find(t => t.is_default);
      if (defaultTemplate) {
        selectTemplate(defaultTemplate.id);
      }
    }

    function selectTemplate(templateId) {
      selectedTemplateId = templateId;

      // Update UI
      document.querySelectorAll('.template-card').forEach(card => {
        card.classList.toggle('selected', card.dataset.templateId === templateId);
      });

      // Enable apply button
      const applyBtn = document.getElementById('apply-template-btn');
      if (applyBtn) applyBtn.disabled = false;
    }

    function closeTemplatePickerModal() {
      const modal = document.getElementById('template-picker-modal');
      if (modal) modal.remove();
      selectedTemplateId = null;
    }

    // Apply selected template
    async function applySelectedTemplate() {
      if (!selectedTemplateId || !selectedPracticeId) return;

      const template = BUILT_IN_TEMPLATES.find(t => t.id === selectedTemplateId);
      if (!template) return;

      const sendEmail = document.getElementById('template-send-email')?.checked;
      const applyBtn = document.getElementById('apply-template-btn');

      try {
        applyBtn.disabled = true;
        applyBtn.textContent = 'Applying...';

        // Check for existing items
        const { data: existingItems } = await window.sb
          .from('dd_checklist_items')
          .select('item_name')
          .eq('practice_id', selectedPracticeId);

        const existingNames = new Set((existingItems || []).map(i => i.item_name.toLowerCase()));

        // Filter out duplicates
        const newItems = template.items.filter(item =>
          !existingNames.has(item.name.toLowerCase())
        );

        if (newItems.length === 0) {
          alert('All items from this template already exist in the checklist.');
          closeTemplatePickerModal();
          return;
        }

        // Insert new checklist items
        const itemsToInsert = newItems.map(item => ({
          id: crypto.randomUUID(),
          org_id: window.currentOrgId,
          practice_id: selectedPracticeId,
          category_slug: item.category,
          item_name: item.name,
          is_required: item.required,
          is_complete: false,
          created_at: new Date().toISOString()
        }));

        const { error: insertError } = await window.sb
          .from('dd_checklist_items')
          .insert(itemsToInsert);

        if (insertError) {
          throw new Error(insertError.message);
        }

        // Log event
        await window.sb.from('document_events').insert({
          org_id: window.currentOrgId,
          practice_id: selectedPracticeId,
          document_type: 'dd',
          document_id: template.id,
          event_type: 'metadata_updated',
          actor_user_id: window.currentUser.id,
          actor_email: window.currentUser.email,
          payload: { action: 'applied_template', template_name: template.name, items_created: newItems.length }
        });

        closeTemplatePickerModal();

        // Update button state
        const mainBtn = document.getElementById('btn-apply-template');
        if (mainBtn) {
          mainBtn.classList.add('applied');
          mainBtn.textContent = ' Template Applied';
        }

        // Reload checklist
        await loadDDDocuments(selectedPracticeId);
        await loadDDChecklist(selectedPracticeId);

        // Expand checklist
        const content = document.getElementById('dd-checklist-content');
        const icon = document.getElementById('checklist-toggle-icon');
        if (content) content.style.display = 'block';
        if (icon) icon.classList.add('open');

        // Generate email if requested
        if (sendEmail) {
          setTimeout(() => {
            generateTemplateEmail(template, newItems);
          }, 300);
        } else {
          alert(`Template applied! ${newItems.length} checklist items created.`);
        }

      } catch (err) {
        console.error('[Template] Apply error:', err);
        alert('Failed to apply template: ' + err.message);
        applyBtn.disabled = false;
        applyBtn.textContent = 'Apply Template';
      }
    }

    // Generate email for template items
    function generateTemplateEmail(template, items) {
      const practice = getPracticeById(selectedPracticeId);
      const practiceName = practice?.name || practice?.dba_name || 'Practice';

      const categoryLabels = {
        'financial': 'Financial Documents',
        'dd_compliance': 'Compliance & Licensing',
        'dd_corporate': 'Corporate Documents',
        'dd_contracts': 'Contracts & Agreements',
        'dd_other': 'Other Documents'
      };

      // Group items by category
      const grouped = {};
      items.forEach(item => {
        const cat = item.category || 'dd_other';
        if (!grouped[cat]) grouped[cat] = [];
        grouped[cat].push(item);
      });

      // Build email body
      let emailBody = `Hello,

We are requesting the following documents for ${practiceName} as part of our due diligence process using the "${template.name}" template.

REQUESTED DOCUMENTS
==================
`;

      Object.entries(grouped).forEach(([category, catItems]) => {
        emailBody += `\n${categoryLabels[category] || category}\n`;
        emailBody += '-'.repeat(30) + '\n';
        catItems.forEach(item => {
          const reqLabel = item.required ? ' *' : '';
          emailBody += `   ${item.name}${reqLabel}\n`;
        });
      });

      emailBody += `\n* = Required document

==================

Please upload these documents to our secure portal or reply to this email with the requested files attached.

If you have any questions about what's needed, please don't hesitate to reach out.

Thank you!`;

      const subject = `Document Request - ${practiceName} - ${template.name}`;

      // Show email modal
      showTemplateEmailModal(subject, emailBody, practiceName);
    }

    function showTemplateEmailModal(subject, body, practiceName) {
      const existingModal = document.getElementById('template-email-modal');
      if (existingModal) existingModal.remove();

      const modal = document.createElement('div');
      modal.id = 'template-email-modal';
      modal.className = 'modal-overlay visible';
      modal.innerHTML = `
        <div class="modal" style="max-width: 600px;">
          <div class="modal-header">
            <h3>Document Request Email</h3>
            <button class="modal-close" onclick="closeTemplateEmailModal()">&times;</button>
          </div>
          <div class="modal-body">
            <p style="margin-bottom: 1rem; color: #059669; font-size: 0.85rem;">
               Template applied successfully! Send this email to request the documents.
            </p>
            <div style="margin-bottom: 1rem;">
              <label style="font-size: 0.75rem; font-weight: 600; color: #374151; display: block; margin-bottom: 0.25rem;">Subject</label>
              <input type="text" id="template-email-subject" value="${escapeHtml(subject)}" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 6px;">
            </div>
            <div>
              <label style="font-size: 0.75rem; font-weight: 600; color: #374151; display: block; margin-bottom: 0.25rem;">Email Body</label>
              <textarea id="template-email-body" style="width: 100%; height: 300px; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 6px; font-family: monospace; font-size: 0.8rem;">${escapeHtml(body)}</textarea>
            </div>
          </div>
          <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeTemplateEmailModal()">Close</button>
            <button class="btn btn-secondary" onclick="copyTemplateEmail()">Copy to Clipboard</button>
            <button class="btn btn-primary" onclick="openTemplateEmailClient()">Open in Email App</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }

    function closeTemplateEmailModal() {
      const modal = document.getElementById('template-email-modal');
      if (modal) modal.remove();
    }

    function copyTemplateEmail() {
      const subject = document.getElementById('template-email-subject').value;
      const body = document.getElementById('template-email-body').value;
      const fullText = `Subject: ${subject}\n\n${body}`;

      navigator.clipboard.writeText(fullText).then(() => {
        alert('Email copied to clipboard!');
      }).catch(err => {
        console.error('Copy failed:', err);
        alert('Failed to copy. Please select and copy manually.');
      });
    }

    function openTemplateEmailClient() {
      const subject = encodeURIComponent(document.getElementById('template-email-subject').value);
      const body = encodeURIComponent(document.getElementById('template-email-body').value);
      window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
    }

    // Apply DD Checklist Template to practice (legacy - now uses modal)
    async function applyDDTemplate() {
      if (!selectedPracticeId) {
        alert('Please select a practice first.');
        return;
      }

      const btn = document.getElementById('btn-apply-template');

      try {
        btn.disabled = true;
        btn.textContent = 'Applying...';

        // Check if checklist items already exist for this practice
        const { data: existingItems, error: checkError } = await window.sb
          .from('dd_checklist_items')
          .select('id')
          .eq('practice_id', selectedPracticeId)
          .limit(1);

        if (existingItems && existingItems.length > 0) {
          if (!confirm('This practice already has checklist items. Apply template anyway? (Duplicates will be skipped)')) {
            btn.disabled = false;
            btn.textContent = 'Apply DD Checklist';
            return;
          }
        }

        // Get the default template
        const { data: templates, error: templateError } = await window.sb
          .from('dd_checklist_templates')
          .select('id, name')
          .eq('is_default', true)
          .eq('is_active', true)
          .limit(1);

        if (templateError || !templates || templates.length === 0) {
          alert('No default template found. Please contact administrator.');
          btn.disabled = false;
          btn.textContent = 'Apply DD Checklist';
          return;
        }

        const template = templates[0];
        console.log('[DDChecklist] Applying template:', template.name);

        // Call the function to generate checklist items
        const { data: result, error: applyError } = await window.sb
          .rpc('generate_checklist_from_template', {
            p_practice_id: selectedPracticeId,
            p_template_id: template.id,
            p_org_id: window.currentOrgId
          });

        if (applyError) {
          throw new Error(applyError.message);
        }

        console.log('[DDChecklist] Created', result, 'checklist items');

        // Log event
        await window.sb.from('document_events').insert({
          org_id: window.currentOrgId,
          practice_id: selectedPracticeId,
          document_type: 'dd',
          document_id: template.id,
          event_type: 'metadata_updated',
          actor_user_id: window.currentUser.id,
          actor_email: window.currentUser.email,
          payload: { action: 'applied_template', template_name: template.name, items_created: result }
        });

        // Update button state
        btn.classList.add('applied');
        btn.textContent = ' Checklist Applied';

        // Reload DD readiness and checklist
        await loadDDDocuments(selectedPracticeId);
        await loadDDChecklist(selectedPracticeId);

        // Expand checklist to show items
        const content = document.getElementById('dd-checklist-content');
        const icon = document.getElementById('checklist-toggle-icon');
        content.style.display = 'block';
        icon.classList.add('open');

        alert(`DD Checklist applied! ${result} items created.`);

      } catch (err) {
        console.error('[DDChecklist] Apply error:', err);
        alert('Failed to apply template: ' + err.message);
        btn.disabled = false;
        btn.textContent = 'Apply DD Checklist';
      }
    }

    // Check if practice has checklist and update button state
    async function checkDDChecklistStatus(practiceId) {
      const btn = document.getElementById('btn-apply-template');
      if (!btn) return;

      try {
        const { data: items } = await window.sb
          .from('dd_checklist_items')
          .select('id')
          .eq('practice_id', practiceId)
          .limit(1);

        if (items && items.length > 0) {
          btn.classList.add('applied');
          btn.textContent = ' Checklist Applied';
        } else {
          btn.classList.remove('applied');
          btn.textContent = 'Apply DD Checklist';
          btn.disabled = false;
        }
      } catch (err) {
        console.error('[DDChecklist] Status check error:', err);
      }
    }

    // Toggle checklist view open/closed
    function toggleChecklistView() {
      const content = document.getElementById('dd-checklist-content');
      const icon = document.getElementById('checklist-toggle-icon');

      if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.classList.add('open');
      } else {
        content.style.display = 'none';
        icon.classList.remove('open');
      }
    }

    // Load and render DD checklist items
    async function loadDDChecklist(practiceId) {
      if (!practiceId) return;

      const listContainer = document.getElementById('dd-checklist-list');
      const summaryEl = document.getElementById('dd-checklist-summary');

      try {
        // Load checklist items
        const { data: items, error } = await window.sb
          .from('dd_checklist_items')
          .select('*')
          .eq('practice_id', practiceId)
          .order('sort_order', { ascending: true });

        if (error) {
          console.error('[DDChecklist] Load error:', error);
          return;
        }

        if (!items || items.length === 0) {
          listContainer.innerHTML = '<div class="dd-checklist-empty">No checklist items. Click "Apply DD Checklist" to get started.</div>';
          summaryEl.textContent = '0/0 complete';
          return;
        }

        // Load linked documents with details
        const { data: linkedDocs } = await window.sb
          .from('dd_checklist_item_documents')
          .select('id, checklist_item_id, dd_document_id, financial_document_id')
          .eq('practice_id', practiceId);

        // Count docs per checklist item and collect linked doc IDs
        const docCountByItem = {};
        const linkedDocsByItem = {}; // { itemId: [{ linkId, docId, docType }] }
        const ddDocIds = new Set();
        const finDocIds = new Set();

        (linkedDocs || []).forEach(link => {
          const itemId = link.checklist_item_id;
          docCountByItem[itemId] = (docCountByItem[itemId] || 0) + 1;

          if (!linkedDocsByItem[itemId]) linkedDocsByItem[itemId] = [];

          if (link.dd_document_id) {
            ddDocIds.add(link.dd_document_id);
            linkedDocsByItem[itemId].push({
              linkId: link.id,
              docId: link.dd_document_id,
              docType: 'dd'
            });
          }
          if (link.financial_document_id) {
            finDocIds.add(link.financial_document_id);
            linkedDocsByItem[itemId].push({
              linkId: link.id,
              docId: link.financial_document_id,
              docType: 'financial'
            });
          }
        });

        // Fetch document names for linked docs
        let ddDocNames = {};
        let finDocNames = {};

        if (ddDocIds.size > 0) {
          const { data: ddDocs } = await window.sb
            .from('dd_documents')
            .select('id, file_name')
            .in('id', Array.from(ddDocIds));
          (ddDocs || []).forEach(d => { ddDocNames[d.id] = d.file_name; });
        }

        if (finDocIds.size > 0) {
          const { data: fDocs } = await window.sb
            .from('financial_documents')
            .select('id, file_name')
            .in('id', Array.from(finDocIds));
          (fDocs || []).forEach(d => { finDocNames[d.id] = d.file_name; });
        }

        // Also count financial documents by type for financial checklist items
        const { data: finDocs } = await window.sb
          .from('financial_documents')
          .select('id, document_type, processing_status')
          .eq('practice_id', practiceId)
          .eq('is_deleted', false);

        const finDocsByType = {};
        (finDocs || []).forEach(doc => {
          const type = doc.document_type || 'other';
          finDocsByType[type] = (finDocsByType[type] || 0) + 1;
        });

        // Group items by category
        const itemsByCategory = {};
        items.forEach(item => {
          const cat = item.category_id || 'other';
          if (!itemsByCategory[cat]) {
            itemsByCategory[cat] = [];
          }
          itemsByCategory[cat].push(item);
        });

        // Category labels
        const categoryLabels = {
          'financial': 'Financial',
          'dd_corporate': 'Corporate & Ownership',
          'dd_compliance': 'Licenses & Compliance',
          'dd_contracts': 'Contracts',
          'dd_real_estate': 'Real Estate',
          'dd_equipment': 'Equipment',
          'dd_hr': 'HR & Staff',
          'other': 'Other'
        };

        // Calculate completion
        let totalItems = items.length;
        let completedItems = 0;

        // Render checklist
        let html = '';

        // Sort categories
        const categoryOrder = ['financial', 'dd_corporate', 'dd_compliance', 'dd_contracts', 'dd_real_estate', 'dd_equipment', 'dd_hr', 'other'];
        const sortedCategories = Object.keys(itemsByCategory).sort((a, b) => {
          return categoryOrder.indexOf(a) - categoryOrder.indexOf(b);
        });

        for (const catId of sortedCategories) {
          const catItems = itemsByCategory[catId];
          const catLabel = categoryLabels[catId] || catId;

          html += `<div class="checklist-category-header">${catLabel}</div>`;

          for (const item of catItems) {
            // Calculate completion for this item
            let linkedCount = docCountByItem[item.id] || 0;

            // For financial items, also check financial_documents by type
            if (item.item_key === 'bank_statements_12mo') {
              linkedCount = finDocsByType['bank_statement'] || 0;
            } else if (item.item_key === 'tax_returns_3yr') {
              linkedCount = finDocsByType['tax_return'] || 0;
            } else if (item.item_key === 'pnl_ytd') {
              linkedCount = finDocsByType['income_statement'] || 0;
            }

            const required = item.required_count || 1;
            const isComplete = linkedCount >= required;
            const progressPct = Math.min(100, Math.round((linkedCount / required) * 100));

            if (isComplete) completedItems++;

            const blockerClass = item.is_blocker ? 'blocker' : '';
            const completedClass = isComplete ? 'completed' : '';
            const checkboxClass = isComplete ? 'checked' : '';

            // Build linked docs chips
            const itemLinkedDocs = linkedDocsByItem[item.id] || [];
            let linkedDocsHtml = '';
            if (itemLinkedDocs.length > 0) {
              linkedDocsHtml = '<div class="linked-docs-list">';
              for (const ld of itemLinkedDocs) {
                const docName = ld.docType === 'dd' ? ddDocNames[ld.docId] : finDocNames[ld.docId];
                const shortName = (docName || 'Document').substring(0, 25);
                linkedDocsHtml += `
                  <div class="linked-doc-chip">
                    <span class="doc-name" title="${escapeHtml(docName || '')}">${escapeHtml(shortName)}</span>
                    <span class="unlink-btn" onclick="unlinkDocument('${ld.linkId}')" title="Unlink"></span>
                  </div>
                `;
              }
              linkedDocsHtml += '</div>';
            }

            html += `
              <div class="dd-checklist-item ${blockerClass} ${completedClass}" data-item-id="${item.id}" data-category="${item.category_id || ''}">
                <div class="checklist-checkbox ${checkboxClass}">${isComplete ? '' : ''}</div>
                <div class="checklist-item-content">
                  <div class="checklist-item-title">
                    ${escapeHtml(item.title)}
                    ${item.is_blocker ? '<span class="blocker-badge">Required</span>' : ''}
                  </div>
                  ${item.description ? `<div class="checklist-item-desc">${escapeHtml(item.description)}</div>` : ''}
                  <div class="checklist-item-progress">
                    <div class="progress-bar">
                      <div class="progress-fill" style="width: ${progressPct}%"></div>
                    </div>
                    <span>${linkedCount}/${required} ${required === 1 ? 'doc' : 'docs'}</span>
                  </div>
                  ${linkedDocsHtml}
                  <div class="checklist-item-actions">
                    <button class="btn-link-doc" onclick="showDocPicker('${item.id}', '${item.category_id || ''}', this)">+ Link Doc</button>
                  </div>
                </div>
              </div>
            `;
          }
        }

        listContainer.innerHTML = html;
        summaryEl.textContent = `${completedItems}/${totalItems} complete`;

        // Update summary color based on completion
        if (completedItems === totalItems) {
          summaryEl.style.color = '#22c55e';
        } else if (completedItems > 0) {
          summaryEl.style.color = '#f59e0b';
        } else {
          summaryEl.style.color = '#666';
        }

      } catch (err) {
        console.error('[DDChecklist] Load error:', err);
        listContainer.innerHTML = '<div class="dd-checklist-empty">Error loading checklist.</div>';
      }
    }

    // Close any open doc picker
    function closeDocPicker() {
      const existing = document.querySelector('.doc-picker-dropdown');
      if (existing) existing.remove();
    }

    // Show document picker dropdown
    async function showDocPicker(itemId, category, buttonEl) {
      closeDocPicker();

      const practiceId = selectedPracticeId;
      if (!practiceId) return;

      // Create dropdown
      const dropdown = document.createElement('div');
      dropdown.className = 'doc-picker-dropdown';
      dropdown.innerHTML = `
        <div class="doc-picker-header">
          <span>Link Document</span>
          <span class="doc-picker-close" onclick="closeDocPicker()"></span>
        </div>
        <div class="doc-picker-list">
          <div class="doc-picker-empty">Loading...</div>
        </div>
      `;

      // Position near button
      const rect = buttonEl.getBoundingClientRect();
      dropdown.style.position = 'fixed';
      dropdown.style.top = (rect.bottom + 5) + 'px';
      dropdown.style.left = rect.left + 'px';

      document.body.appendChild(dropdown);

      // Load documents
      try {
        // Get already linked doc IDs for this item
        const { data: alreadyLinked } = await window.sb
          .from('dd_checklist_item_documents')
          .select('dd_document_id, financial_document_id')
          .eq('checklist_item_id', itemId);

        const linkedDdIds = new Set((alreadyLinked || []).filter(l => l.dd_document_id).map(l => l.dd_document_id));
        const linkedFinIds = new Set((alreadyLinked || []).filter(l => l.financial_document_id).map(l => l.financial_document_id));

        // Fetch DD documents
        const { data: ddDocs } = await window.sb
          .from('dd_documents')
          .select('id, file_name, document_type')
          .eq('practice_id', practiceId)
          .order('created_at', { ascending: false });

        // Fetch financial documents
        const { data: finDocs } = await window.sb
          .from('financial_documents')
          .select('id, file_name, document_type')
          .eq('practice_id', practiceId)
          .eq('is_deleted', false)
          .order('uploaded_at', { ascending: false });

        const listEl = dropdown.querySelector('.doc-picker-list');
        let html = '';

        // Filter by category if financial
        const isFinancialCategory = category === 'financial';

        if (!isFinancialCategory && ddDocs && ddDocs.length > 0) {
          html += '<div style="padding: 0.25rem 0.5rem; font-size: 0.7rem; color: #6b7280; font-weight: 600;">DD Documents</div>';
          for (const doc of ddDocs) {
            const isLinked = linkedDdIds.has(doc.id);
            html += `
              <div class="doc-picker-item ${isLinked ? 'already-linked' : ''}"
                   ${isLinked ? '' : `onclick="linkDocument('${itemId}', '${doc.id}', 'dd')"`}>
                <span class="doc-icon"></span>
                <div class="doc-info">
                  <div class="doc-name">${escapeHtml(doc.file_name)}</div>
                  <div class="doc-type">${getDocTypeLabel(doc.document_type)}</div>
                </div>
                ${isLinked ? '<span style="color:#22c55e"></span>' : ''}
              </div>
            `;
          }
        }

        if (finDocs && finDocs.length > 0) {
          html += '<div style="padding: 0.25rem 0.5rem; font-size: 0.7rem; color: #6b7280; font-weight: 600;">Financial Documents</div>';
          for (const doc of finDocs) {
            const isLinked = linkedFinIds.has(doc.id);
            html += `
              <div class="doc-picker-item ${isLinked ? 'already-linked' : ''}"
                   ${isLinked ? '' : `onclick="linkDocument('${itemId}', '${doc.id}', 'financial')"`}>
                <span class="doc-icon"></span>
                <div class="doc-info">
                  <div class="doc-name">${escapeHtml(doc.file_name)}</div>
                  <div class="doc-type">${getDocTypeLabel(doc.document_type)}</div>
                </div>
                ${isLinked ? '<span style="color:#22c55e"></span>' : ''}
              </div>
            `;
          }
        }

        if (!html) {
          html = '<div class="doc-picker-empty">No documents available. Upload some first.</div>';
        }

        listEl.innerHTML = html;

      } catch (err) {
        console.error('[DocPicker] Error:', err);
        dropdown.querySelector('.doc-picker-list').innerHTML = '<div class="doc-picker-empty">Error loading documents.</div>';
      }

      // Close on outside click
      setTimeout(() => {
        document.addEventListener('click', function handler(e) {
          if (!dropdown.contains(e.target) && e.target !== buttonEl) {
            closeDocPicker();
            document.removeEventListener('click', handler);
          }
        });
      }, 100);
    }

    // Link a document to a checklist item
    async function linkDocument(itemId, docId, docType) {
      const practiceId = selectedPracticeId;
      if (!practiceId) return;

      try {
        const linkRecord = {
          id: crypto.randomUUID(),
          practice_id: practiceId,
          checklist_item_id: itemId,
          linked_at: new Date().toISOString()
        };

        if (docType === 'dd') {
          linkRecord.dd_document_id = docId;
        } else {
          linkRecord.financial_document_id = docId;
        }

        const { error } = await window.sb
          .from('dd_checklist_item_documents')
          .insert(linkRecord);

        if (error) {
          console.error('[LinkDoc] Error:', error);
          alert('Failed to link document.');
          return;
        }

        // Log event
        await window.sb.from('document_events').insert({
          id: crypto.randomUUID(),
          practice_id: practiceId,
          document_id: docId,
          document_source: docType === 'dd' ? 'dd_documents' : 'financial_documents',
          event_type: 'linked_to_checklist',
          event_data: { checklist_item_id: itemId },
          performed_by: window.currentUser?.id,
          performed_at: new Date().toISOString()
        });

        closeDocPicker();
        await loadDDChecklist(practiceId);

      } catch (err) {
        console.error('[LinkDoc] Error:', err);
        alert('Failed to link document.');
      }
    }

    // Unlink a document from a checklist item
    async function unlinkDocument(linkId) {
      const practiceId = selectedPracticeId;
      if (!practiceId) return;

      try {
        const { error } = await window.sb
          .from('dd_checklist_item_documents')
          .delete()
          .eq('id', linkId);

        if (error) {
          console.error('[UnlinkDoc] Error:', error);
          alert('Failed to unlink document.');
          return;
        }

        await loadDDChecklist(practiceId);

      } catch (err) {
        console.error('[UnlinkDoc] Error:', err);
        alert('Failed to unlink document.');
      }
    }

    // Update DD Readiness score
    async function updateDDReadiness(practiceId, docs) {
      // Define category weights
      const categoryWeights = {
        'financial': 0.30,      // Financial docs (from financial_documents table)
        'dd_corporate': 0.20,
        'dd_compliance': 0.20,
        'dd_contracts': 0.15,
        'dd_other': 0.15        // Real estate, insurance, HR, IT, equipment
      };

      // Count verified docs per category
      const verifiedByCategory = {};
      docs.forEach(doc => {
        if (doc.verification_status === 'verified') {
          const cat = doc.category_slug || 'dd_other';
          verifiedByCategory[cat] = (verifiedByCategory[cat] || 0) + 1;
        }
      });

      // Check financial documents separately
      let financialScore = 0;
      try {
        const { data: finDocs } = await window.sb
          .from('financial_documents')
          .select('processing_status')
          .eq('practice_id', practiceId)
          .eq('is_deleted', false);

        if (finDocs && finDocs.length > 0) {
          const extracted = finDocs.filter(d => d.processing_status === 'completed').length;
          financialScore = Math.min(100, (extracted / 12) * 100); // 12 months = 100%
        }
      } catch (err) {
        console.error('[DDReadiness] Error loading financial docs:', err);
      }

      // Calculate weighted score
      let totalScore = financialScore * categoryWeights['financial'];

      // Score each DD category (1 verified doc = 50%, 2+ = 100%)
      ['dd_corporate', 'dd_compliance', 'dd_contracts'].forEach(cat => {
        const count = verifiedByCategory[cat] || 0;
        const catScore = count >= 2 ? 100 : count === 1 ? 50 : 0;
        totalScore += catScore * categoryWeights[cat];
      });

      // Other DD categories combined
      const otherCount = (verifiedByCategory['dd_real_estate'] || 0) +
                        (verifiedByCategory['dd_insurance'] || 0) +
                        (verifiedByCategory['dd_hr'] || 0) +
                        (verifiedByCategory['dd_it'] || 0) +
                        (verifiedByCategory['dd_equipment'] || 0) +
                        (verifiedByCategory['practice_overview'] || 0);
      const otherScore = otherCount >= 3 ? 100 : otherCount >= 1 ? 50 : 0;
      totalScore += otherScore * categoryWeights['dd_other'];

      const roundedScore = Math.round(totalScore);

      // Update UI
      const fill = document.getElementById('dd-readiness-fill');
      const pct = document.getElementById('dd-readiness-pct');
      if (fill) {
        fill.style.width = `${roundedScore}%`;
        fill.style.backgroundColor = roundedScore >= 80 ? '#2e7d32' :
                                     roundedScore >= 50 ? '#ed6c02' : '#d32f2f';
      }
      if (pct) {
        pct.textContent = `${roundedScore}%`;
      }

      // Save to history (throttled - only once per hour max)
      try {
        const { data: lastRecord } = await window.sb
          .from('dd_readiness_history')
          .select('recorded_at, score')
          .eq('practice_id', practiceId)
          .order('recorded_at', { ascending: false })
          .limit(1)
          .single();

        const hourAgo = new Date(Date.now() - 60 * 60 * 1000);
        const shouldRecord = !lastRecord ||
          new Date(lastRecord.recorded_at) < hourAgo ||
          lastRecord.score !== roundedScore;

        if (shouldRecord) {
          await window.sb.from('dd_readiness_history').insert({
            practice_id: practiceId,
            score: roundedScore,
            doc_counts: {
              financial: financialScore,
              ...verifiedByCategory,
              other_total: otherCount
            }
          });
        }
      } catch (err) {
        // Silently fail - history is optional
        console.log('[DDReadiness] History save skipped:', err.message);
      }

      // Load and display trend
      await loadReadinessTrend(practiceId);
    }

    // Generate Missing Docs Report across all practices
    async function showMissingDocsReport() {
      try {
        // Get all practices
        const practices = db.practices || [];
        if (practices.length === 0) {
          alert('No practices found.');
          return;
        }

        // Load checklist items and documents for each practice
        const reportData = [];

        for (const practice of practices) {
          // Get checklist items
          const { data: checklistItems } = await window.sb
            .from('dd_checklist_items')
            .select('*')
            .eq('practice_id', practice.id);

          if (!checklistItems || checklistItems.length === 0) continue;

          // Get linked documents count
          const { data: linkedDocs } = await window.sb
            .from('dd_checklist_item_documents')
            .select('checklist_item_id')
            .eq('practice_id', practice.id);

          const docCountByItem = {};
          (linkedDocs || []).forEach(link => {
            docCountByItem[link.checklist_item_id] = (docCountByItem[link.checklist_item_id] || 0) + 1;
          });

          // Get financial docs count
          const { data: finDocs } = await window.sb
            .from('financial_documents')
            .select('document_type')
            .eq('practice_id', practice.id)
            .eq('is_deleted', false);

          const finDocsByType = {};
          (finDocs || []).forEach(doc => {
            finDocsByType[doc.document_type] = (finDocsByType[doc.document_type] || 0) + 1;
          });

          // Analyze missing items
          const missingItems = [];
          let completedCount = 0;

          for (const item of checklistItems) {
            let linkedCount = docCountByItem[item.id] || 0;

            // Check financial items
            if (item.item_key === 'bank_statements_12mo') linkedCount = finDocsByType['bank_statement'] || 0;
            else if (item.item_key === 'tax_returns_3yr') linkedCount = finDocsByType['tax_return'] || 0;
            else if (item.item_key === 'pnl_ytd') linkedCount = finDocsByType['income_statement'] || 0;

            const required = item.required_count || 1;
            const isComplete = linkedCount >= required;

            if (isComplete) {
              completedCount++;
            } else {
              missingItems.push({
                title: item.title,
                have: linkedCount,
                need: required,
                isBlocker: item.is_blocker
              });
            }
          }

          const score = Math.round((completedCount / checklistItems.length) * 100);

          if (missingItems.length > 0) {
            reportData.push({
              practice: practice,
              score: score,
              totalItems: checklistItems.length,
              completedItems: completedCount,
              missingItems: missingItems
            });
          }
        }

        // Sort by score ascending (worst first)
        reportData.sort((a, b) => a.score - b.score);

        // Generate modal HTML
        let reportHtml = '';
        if (reportData.length === 0) {
          reportHtml = '<p style="text-align: center; color: #22c55e; padding: 2rem;">All practices have complete documentation!</p>';
        } else {
          reportHtml = reportData.map(r => {
            const scoreClass = r.score < 50 ? 'low' : r.score < 80 ? 'medium' : 'high';
            const missingHtml = r.missingItems.map(m => `
              <div class="missing-doc-item ${m.isBlocker ? 'blocker' : ''}">
                <span class="missing-icon"></span>
                <span>${escapeHtml(m.title)} (${m.have}/${m.need})</span>
                ${m.isBlocker ? '<span style="font-size:0.7rem;background:#fee2e2;padding:0.1rem 0.3rem;border-radius:3px;">BLOCKER</span>' : ''}
              </div>
            `).join('');

            return `
              <div class="missing-docs-practice">
                <div class="missing-docs-practice-header">
                  <span class="missing-docs-practice-name">${escapeHtml(r.practice.dba_name || r.practice.name || 'Unknown')}</span>
                  <span class="missing-docs-practice-score ${scoreClass}">${r.score}% Complete</span>
                </div>
                <div class="missing-docs-list">
                  ${missingHtml}
                </div>
              </div>
            `;
          }).join('');
        }

        const modalHtml = `
          <div class="modal-overlay" id="missing-docs-modal" onclick="if(event.target===this)closeMissingDocsModal()">
            <div class="modal" style="max-width: 700px;">
              <div class="modal-header">
                <h2>Missing Documents Report</h2>
                <button class="modal-close" onclick="closeMissingDocsModal()">&times;</button>
              </div>
              <div class="modal-body">
                <p style="margin-bottom: 1rem; color: #6b7280;">
                  ${reportData.length} practice${reportData.length !== 1 ? 's' : ''} with incomplete documentation
                </p>
                <div class="missing-docs-report">
                  ${reportHtml}
                </div>
              </div>
            </div>
          </div>
        `;

        closeMissingDocsModal();
        document.body.insertAdjacentHTML('beforeend', modalHtml);

      } catch (err) {
        console.error('[MissingDocs] Error:', err);
        alert('Failed to generate report: ' + err.message);
      }
    }

    function closeMissingDocsModal() {
      const modal = document.getElementById('missing-docs-modal');
      if (modal) modal.remove();
    }

    // Load and display readiness trend
    async function loadReadinessTrend(practiceId) {
      const trendContainer = document.getElementById('dd-readiness-trend');
      if (!trendContainer) return;

      try {
        const { data: history } = await window.sb
          .from('dd_readiness_history')
          .select('score, recorded_at')
          .eq('practice_id', practiceId)
          .order('recorded_at', { ascending: true })
          .limit(30);

        if (!history || history.length < 2) {
          trendContainer.innerHTML = '<span class="trend-empty">Not enough data for trend</span>';
          return;
        }

        // Calculate trend direction
        const recent = history.slice(-5);
        const older = history.slice(0, Math.min(5, history.length - 5));
        const recentAvg = recent.reduce((a, b) => a + b.score, 0) / recent.length;
        const olderAvg = older.length > 0 ? older.reduce((a, b) => a + b.score, 0) / older.length : recentAvg;
        const trendDiff = recentAvg - olderAvg;

        let trendIcon = '';
        let trendClass = 'neutral';
        if (trendDiff > 5) {
          trendIcon = '';
          trendClass = 'up';
        } else if (trendDiff < -5) {
          trendIcon = '';
          trendClass = 'down';
        }

        // Create mini sparkline
        const maxScore = Math.max(...history.map(h => h.score));
        const minScore = Math.min(...history.map(h => h.score));
        const range = maxScore - minScore || 1;

        const sparklinePoints = history.map((h, i) => {
          const x = (i / (history.length - 1)) * 60;
          const y = 20 - ((h.score - minScore) / range) * 16;
          return `${x},${y}`;
        }).join(' ');

        trendContainer.innerHTML = `
          <span class="trend-indicator ${trendClass}">${trendIcon}</span>
        `;

      } catch (err) {
        console.error('[Trend] Error:', err);
        trendContainer.innerHTML = '';
      }
    }

    // Initialize DD document dropzones
    function initDDDocDropzones() {
      const dropzones = document.querySelectorAll('.dd-upload-dropzone');
      dropzones.forEach(dropzone => {
        dropzone.addEventListener('dragover', (e) => {
          e.preventDefault();
          dropzone.classList.add('dragover');
        });

        dropzone.addEventListener('dragleave', () => {
          dropzone.classList.remove('dragover');
        });

        dropzone.addEventListener('drop', (e) => {
          e.preventDefault();
          dropzone.classList.remove('dragover');

          // Find the file input in the same upload area
          const uploadArea = dropzone.closest('.dd-upload-area');
          if (!uploadArea) return;

          const fileInput = uploadArea.querySelector('input[type="file"]');
          if (!fileInput) return;

          const files = e.dataTransfer.files;
          if (files.length > 0) {
            // Get category from the onchange attribute
            const onchangeAttr = fileInput.getAttribute('onchange');
            const categoryMatch = onchangeAttr?.match(/handleDDDocUpload\(event,\s*['"]?([^'")\s]+)['"]?\)/);
            let category = categoryMatch ? categoryMatch[1] : 'dd_other';

            // Handle dynamic category (dd-other-category select)
            if (category.includes('getElementById')) {
              const select = document.getElementById('dd-other-category');
              category = select?.value || 'dd_other';
            }

            handleDDDocUpload({ target: { files } }, category);
          }
        });
      });
    }

    // =============================================
    // TEAM INVITES MANAGEMENT
    // =============================================

    async function createTeamInvite() {
      if (!hasPermission('MANAGE_USERS')) {
        showPermissionDenied('invite team members');
        return;
      }

      const emailInput = document.getElementById('invite-email');
      const roleSelect = document.getElementById('invite-role');
      const email = emailInput.value.trim().toLowerCase();
      const role = roleSelect.value;

      if (!email) {
        alert('Please enter an email address.');
        return;
      }

      // Basic email validation
      if (!email.includes('@') || !email.includes('.')) {
        alert('Please enter a valid email address.');
        return;
      }

      try {
        // Check if user is already a member
        const { data: existingMember } = await window.sb
          .from('org_members')
          .select('user_id')
          .eq('org_id', window.currentOrgId)
          .eq('user_id', (await window.sb.rpc('get_user_id_by_email', { user_email: email })).data)
          .limit(1);

        if (existingMember && existingMember.length > 0) {
          alert('This user is already a team member.');
          return;
        }

        // Check for existing pending invite
        const { data: existingInvite } = await window.sb
          .from('team_invites')
          .select('id')
          .eq('org_id', window.currentOrgId)
          .eq('email', email)
          .eq('status', 'pending')
          .limit(1);

        if (existingInvite && existingInvite.length > 0) {
          alert('An invite is already pending for this email.');
          return;
        }

        // Create the invite
        const { data: invite, error } = await window.sb
          .from('team_invites')
          .insert({
            org_id: window.currentOrgId,
            email: email,
            role: role,
            invited_by_id: window.currentUser.id
          })
          .select()
          .single();

        if (error) {
          console.error('[Invites] failed to create invite:', error);
          alert('Failed to create invite: ' + error.message);
          return;
        }

        console.log('[Invites] created invite:', invite);
        emailInput.value = '';

        // Copy link to clipboard automatically
        const inviteLink = `${window.location.origin}${window.location.pathname}?invite=${invite.token}`;
        await navigator.clipboard.writeText(inviteLink);
        alert(`Invite created! Link copied to clipboard:\n\n${inviteLink}`);

        await loadPendingInvites();
      } catch (err) {
        console.error('[Invites] create error:', err);
        alert('Failed to create invite.');
      }
    }

    async function loadPendingInvites() {
      if (!hasPermission('VIEW_ADMIN_PANEL')) return;

      try {
        const { data, error } = await window.sb
          .from('team_invites')
          .select('*')
          .eq('org_id', window.currentOrgId)
          .eq('status', 'pending')
          .order('invited_at', { ascending: false });

        if (error) {
          console.error('[Invites] failed to load invites:', error);
          return;
        }

        renderPendingInvites(data || []);
      } catch (err) {
        console.error('[Invites] load error:', err);
      }
    }

    function renderPendingInvites(invites) {
      const tbody = document.getElementById('pending-invites-tbody');
      const noInvitesDiv = document.getElementById('no-pending-invites');
      const table = document.getElementById('pending-invites-table');

      if (!invites || invites.length === 0) {
        tbody.innerHTML = '';
        table.style.display = 'none';
        noInvitesDiv.style.display = 'block';
        return;
      }

      table.style.display = 'table';
      noInvitesDiv.style.display = 'none';

      tbody.innerHTML = invites.map(invite => {
        const expiresDate = new Date(invite.expires_at);
        const isExpired = expiresDate < new Date();
        const expiresText = isExpired ? '<span style="color:red">Expired</span>' : formatDateShort(invite.expires_at);

        return `
          <tr>
            <td>${escapeHtml(invite.email)}</td>
            <td>${invite.role.charAt(0).toUpperCase() + invite.role.slice(1)}</td>
            <td>${expiresText}</td>
            <td>
              <button class="btn-toggle" onclick="copyInviteLink('${invite.token}')" style="margin-right: 4px;">Copy Link</button>
              <button class="btn-delete" onclick="revokeInvite('${invite.id}')">Revoke</button>
            </td>
          </tr>
        `;
      }).join('');
    }

    async function copyInviteLink(token) {
      const inviteLink = `${window.location.origin}${window.location.pathname}?invite=${token}`;
      try {
        await navigator.clipboard.writeText(inviteLink);
        alert('Invite link copied to clipboard!');
      } catch (err) {
        // Fallback for older browsers
        prompt('Copy this invite link:', inviteLink);
      }
    }

    async function revokeInvite(inviteId) {
      if (!hasPermission('MANAGE_USERS')) {
        showPermissionDenied('manage invites');
        return;
      }

      if (!confirm('Revoke this invite? The link will no longer work.')) {
        return;
      }

      try {
        const { error } = await window.sb
          .from('team_invites')
          .update({ status: 'revoked' })
          .eq('id', inviteId);

        if (error) {
          console.error('[Invites] failed to revoke:', error);
          alert('Failed to revoke invite: ' + error.message);
          return;
        }

        console.log('[Invites] revoked invite:', inviteId);
        await loadPendingInvites();
      } catch (err) {
        console.error('[Invites] revoke error:', err);
      }
    }

    function showAdminPanel() {
      if (window.currentUserRole === 'admin') {
        document.getElementById('admin-panel').style.display = 'block';
        // Show settings button for admins
        const settingsBtn = document.getElementById('settings-btn');
        if (settingsBtn) settingsBtn.style.display = 'flex';
        // Populate org info
        const orgSlugEl = document.getElementById('admin-org-slug');
        const orgIdEl = document.getElementById('admin-org-id');
        if (orgSlugEl) {
          orgSlugEl.textContent = window.currentOrgSlug || 'Unknown';
        }
        if (orgIdEl) {
          orgIdEl.textContent = window.currentOrgId ? `(${window.currentOrgId.substring(0, 8)}...)` : '';
        }
        loadPendingRequests();
        loadPendingInvites();
        loadAllowlist();
        loadTeamMembers();
      }
    }

    // =============================================
    // APP INITIALIZATION (auth-gated)
    // =============================================
    async function initializeApp() {
      await initializeDatabase();
      initializeSpecialtyDropdowns();
      initializeTagDropdown();
      await initializeDocumentTypeDropdowns();
      renderTable();
      updateMetrics();
      initNotifications();
    }

    // =============================================
    // AUTH STATE LISTENER & INITIAL LOAD
    // =============================================
    let isAuthenticating = false;

    async function handleAuthenticatedUser(user) {
      console.log('[handleAuthenticatedUser] Called for:', user?.email);
      // Prevent concurrent calls, but with timeout fallback
      if (isAuthenticating) {
        console.log('[handleAuthenticatedUser] Already authenticating, skipping duplicate call');
        return;
      }
      isAuthenticating = true;
      console.log('[handleAuthenticatedUser] Set isAuthenticating = true');

      // Store current user globally
      window.currentUser = user;

      // Safety timeout: reset guard after 15 seconds if something hangs
      const guardTimeout = setTimeout(() => {
        console.warn('[handleAuthenticatedUser] Guard timeout - resetting isAuthenticating');
        isAuthenticating = false;
      }, 15000);

      try {
        // Check for pending invite FIRST (before allowlist check)
        console.log('[handleAuthenticatedUser] Checking for pending invite...');
        const urlParams = new URLSearchParams(window.location.search);
        const inviteToken = urlParams.get('invite') || sessionStorage.getItem('pendingInviteToken');

        if (inviteToken) {
          console.log('[handleAuthenticatedUser] Found invite token:', inviteToken);
          const { data: tokenInvite } = await window.sb
            .from('team_invites')
            .select('*')
            .eq('token', inviteToken)
            .eq('status', 'pending')
            .limit(1);

          if (tokenInvite && tokenInvite.length > 0) {
            const invite = tokenInvite[0];
            console.log('[handleAuthenticatedUser] Found invite:', invite);

            // Verify email matches
            if (invite.email.toLowerCase() === user.email.toLowerCase()) {
              // Check if expired
              if (new Date(invite.expires_at) < new Date()) {
                console.log('[handleAuthenticatedUser] Invite expired');
                alert('This invite has expired. Please request a new invite from your administrator.');
                sessionStorage.removeItem('pendingInviteToken');
              } else {
                // Accept the invite - add to org_members
                console.log('[handleAuthenticatedUser] Accepting invite...');
                const { error: memberError } = await window.sb
                  .from('org_members')
                  .insert({
                    user_id: user.id,
                    org_id: invite.org_id,
                    role: invite.role,
                    created_at: new Date().toISOString()
                  });

                if (!memberError) {
                  console.log('[handleAuthenticatedUser] Added to org via invite with role:', invite.role);

                  // Update invite status to accepted
                  await window.sb
                    .from('team_invites')
                    .update({ status: 'accepted', accepted_at: new Date().toISOString() })
                    .eq('id', invite.id);

                  // Add to allowed_users so allowlist check passes
                  await window.sb
                    .from('allowed_users')
                    .upsert({ email: user.email.toLowerCase(), role: 'user', is_active: true }, { onConflict: 'email' });

                  console.log('[handleAuthenticatedUser] Invite accepted successfully');
                } else {
                  console.error('[handleAuthenticatedUser] Failed to add via invite:', memberError);
                }

                // Clear invite token
                sessionStorage.removeItem('pendingInviteToken');
                if (urlParams.get('invite')) {
                  window.history.replaceState({}, '', window.location.pathname);
                }
              }
            } else {
              console.log('[handleAuthenticatedUser] Invite email mismatch:', invite.email, 'vs', user.email);
              alert('This invite was sent to a different email address. Please sign in with the correct email.');
              sessionStorage.removeItem('pendingInviteToken');
            }
          } else {
            console.log('[handleAuthenticatedUser] No valid invite found for token');
            sessionStorage.removeItem('pendingInviteToken');
          }
        }

        // Check allowlist BEFORE loading any data
        console.log('[handleAuthenticatedUser] Checking allowlist...');
        const { allowed, role } = await checkAllowlistOrBlock(user);
        console.log('[handleAuthenticatedUser] Allowlist result:', { allowed, role });

        if (!allowed) {
          // User is blocked - awaiting approval screen is already shown
          console.log('[handleAuthenticatedUser] User not allowed, showing approval screen');
          resetLoginButton();
          return;
        }

        // Resolve organization membership BEFORE loading data
        console.log('[handleAuthenticatedUser] Resolving org membership...');
        const hasOrg = await resolveCurrentOrgId();
        console.log('[handleAuthenticatedUser] hasOrg:', hasOrg);
        if (!hasOrg) {
          // User has no org membership - no-org screen is already shown
          console.log('[handleAuthenticatedUser] No org, showing no-org screen');
          resetLoginButton();
          return;
        }

        // User is allowed and has org - show app and initialize
        console.log('[handleAuthenticatedUser] User allowed with org, showing app...');
        hideAwaitingApproval();
        hideNoOrgScreen();
        showApp(user);
        console.log('[handleAuthenticatedUser] Initializing app...');
        await initializeApp();
        showAdminPanel(); // Only shows if role === 'admin'
        updateUIForRole(); // Apply role-based UI restrictions
        console.log('[handleAuthenticatedUser] Complete!');
        resetLoginButton();
      } catch (error) {
        console.error('[handleAuthenticatedUser] Error:', error);
        resetLoginButton();
      } finally {
        clearTimeout(guardTimeout);
        isAuthenticating = false;
        console.log('[handleAuthenticatedUser] Set isAuthenticating = false');
      }
    }

    (async function() {
      console.log('[Auth Init] Setting up auth state listener');
      console.log('[Auth Init] localStorage zenyte-auth:', localStorage.getItem('zenyte-auth'));

      // Capture invite token from URL before auth kicks in
      const urlParams = new URLSearchParams(window.location.search);
      const inviteToken = urlParams.get('invite');
      if (inviteToken) {
        console.log('[Auth Init] Found invite token in URL, storing for later:', inviteToken);
        sessionStorage.setItem('pendingInviteToken', inviteToken);
      }

      let initialLoadComplete = false;

      // Set up auth state change listener
      window.sb.auth.onAuthStateChange(async (event, session) => {
        console.log('[Auth Event]', event, 'session:', !!session, 'user:', session?.user?.email, 'initialLoadComplete:', initialLoadComplete);

        // Skip SIGNED_IN/INITIAL_SESSION during initial load - getSession will handle it
        if (!initialLoadComplete && (event === 'SIGNED_IN' || event === 'INITIAL_SESSION')) {
          console.log('[Auth Event] Skipping', event, '- initial load not complete');
          return;
        }

        if ((event === 'SIGNED_IN' || event === 'INITIAL_SESSION') && session?.user) {
          console.log('[Auth Event] Calling handleAuthenticatedUser for', event);
          await handleAuthenticatedUser(session.user);
        } else if (event === 'SIGNED_OUT') {
          console.log('[Auth Event] Signed out, resetting state');
          isAuthenticating = false; // Reset guard on sign out
          hideApp();
          hideAwaitingApproval();
          hideNoOrgScreen();
          document.getElementById('admin-panel').style.display = 'none';
          // Hide admin-only settings button
          const settingsBtn = document.getElementById('settings-btn');
          if (settingsBtn) settingsBtn.style.display = 'none';
          resetLoginButton();
        }
      });

      // Check for existing session on page load
      console.log('[Auth Init] Checking for existing session...');
      const { data: { session }, error } = await window.sb.auth.getSession();
      console.log('[Auth Init] getSession result - session:', !!session, 'error:', error);

      if (session?.user) {
        console.log('[Auth Init] Found existing session for:', session.user.email);
        await handleAuthenticatedUser(session.user);
      } else {
        // No session - hide loading screen and show login screen
        console.log('[Auth Init] No active session, showing login screen');
        document.getElementById('auth-loading-screen').style.display = 'none';
        document.getElementById('login-screen').style.display = 'flex';
      }

      // Mark initial load as complete - now onAuthStateChange can handle events
      initialLoadComplete = true;
      console.log('[Auth Init] Initial load complete');
    })();

    // Login form submission
    document.getElementById('login-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const email = document.getElementById('login-email').value.trim();
      const password = document.getElementById('login-password').value;
      handleLogin(email, password);
    });
  </script>

    <!-- Data Source Banner -->
    <div id="data-source-banner" class="data-source-banner local">
      Data Source: Local
    </div>
  </div> <!-- Close app-container -->
</body>
</html>
